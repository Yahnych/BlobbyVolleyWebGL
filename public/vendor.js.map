{"version":3,"sources":["node_modules/base64-js/index.js","node_modules/buffer/index.js","node_modules/ieee754/index.js","node_modules/isarray/index.js","node_modules/lodash/lodash.js","node_modules/process/browser.js","node_modules/stats.js/build/stats.min.js","node_modules/three-orbit-controls/index.js","node_modules/three-window-resize/index.js","node_modules/three/three.js","node_modules/auto-reload-brunch/vendor/auto-reload.js"],"names":["WebSocket","window","MozWebSocket","br","brunch","ar","disabled","_ar","cacheBuster","url","date","Math","round","Date","now","toString","replace","indexOf","browser","navigator","userAgent","toLowerCase","forceRepaint","reloaders","page","location","reload","stylesheet","slice","call","document","querySelectorAll","filter","link","val","getAttribute","href","forEach","setTimeout","body","offsetHeight","javascript","scripts","textScripts","map","script","text","length","srcScripts","src","loaded","all","onLoad","eval","remove","newScript","createElement","async","onload","head","appendChild","port","host","server","hostname","connect","connection","onmessage","event","message","data","reloader","onerror","readyState","close","onclose"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACr7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5lhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtnuCA;AACA,CAAC,YAAW;AACV,MAAIA,YAAYC,OAAOD,SAAP,IAAoBC,OAAOC,YAA3C;AACA,MAAIC,KAAKF,OAAOG,MAAP,GAAiBH,OAAOG,MAAP,IAAiB,EAA3C;AACA,MAAIC,KAAKF,GAAG,aAAH,IAAqBA,GAAG,aAAH,KAAqB,EAAnD;AACA,MAAI,CAACH,SAAD,IAAcK,GAAGC,QAArB,EAA+B;AAC/B,MAAIL,OAAOM,GAAX,EAAgB;AAChBN,SAAOM,GAAP,GAAa,IAAb;;AAEA,MAAIC,cAAc,SAAdA,WAAc,CAASC,GAAT,EAAa;AAC7B,QAAIC,OAAOC,KAAKC,KAAL,CAAWC,KAAKC,GAAL,KAAa,IAAxB,EAA8BC,QAA9B,EAAX;AACAN,UAAMA,IAAIO,OAAJ,CAAY,yBAAZ,EAAuC,EAAvC,CAAN;AACA,WAAOP,OAAOA,IAAIQ,OAAJ,CAAY,GAAZ,KAAoB,CAApB,GAAwB,GAAxB,GAA8B,GAArC,IAA2C,cAA3C,GAA4DP,IAAnE;AACD,GAJD;;AAMA,MAAIQ,UAAUC,UAAUC,SAAV,CAAoBC,WAApB,EAAd;AACA,MAAIC,eAAejB,GAAGiB,YAAH,IAAmBJ,QAAQD,OAAR,CAAgB,QAAhB,IAA4B,CAAC,CAAnE;;AAEA,MAAIM,YAAY;AACdC,UAAM,gBAAU;AACdvB,aAAOwB,QAAP,CAAgBC,MAAhB,CAAuB,IAAvB;AACD,KAHa;;AAKdC,gBAAY,sBAAU;AACpB,SAAGC,KAAH,CACGC,IADH,CACQC,SAASC,gBAAT,CAA0B,sBAA1B,CADR,EAEGC,MAFH,CAEU,UAASC,IAAT,EAAe;AACrB,YAAIC,MAAMD,KAAKE,YAAL,CAAkB,iBAAlB,CAAV;AACA,eAAOF,KAAKG,IAAL,IAAaF,OAAO,OAA3B;AACD,OALH,EAMGG,OANH,CAMW,UAASJ,IAAT,EAAe;AACtBA,aAAKG,IAAL,GAAY5B,YAAYyB,KAAKG,IAAjB,CAAZ;AACD,OARH;;AAUA;AACA,UAAId,YAAJ,EAAkBgB,WAAW,YAAW;AAAER,iBAASS,IAAT,CAAcC,YAAd;AAA6B,OAArD,EAAuD,EAAvD;AACnB,KAlBa;;AAoBdC,gBAAY,sBAAU;AACpB,UAAIC,UAAU,GAAGd,KAAH,CAASC,IAAT,CAAcC,SAASC,gBAAT,CAA0B,QAA1B,CAAd,CAAd;AACA,UAAIY,cAAcD,QAAQE,GAAR,CAAY,UAASC,MAAT,EAAiB;AAAE,eAAOA,OAAOC,IAAd;AAAoB,OAAnD,EAAqDd,MAArD,CAA4D,UAASc,IAAT,EAAe;AAAE,eAAOA,KAAKC,MAAL,GAAc,CAArB;AAAwB,OAArG,CAAlB;AACA,UAAIC,aAAaN,QAAQV,MAAR,CAAe,UAASa,MAAT,EAAiB;AAAE,eAAOA,OAAOI,GAAd;AAAmB,OAArD,CAAjB;;AAEA,UAAIC,SAAS,CAAb;AACA,UAAIC,MAAMH,WAAWD,MAArB;AACA,UAAIK,SAAS,SAATA,MAAS,GAAW;AACtBF,iBAASA,SAAS,CAAlB;AACA,YAAIA,WAAWC,GAAf,EAAoB;AAClBR,sBAAYN,OAAZ,CAAoB,UAASQ,MAAT,EAAiB;AAAEQ,iBAAKR,MAAL;AAAe,WAAtD;AACD;AACF,OALD;;AAOAG,iBACGX,OADH,CACW,UAASQ,MAAT,EAAiB;AACxB,YAAII,MAAMJ,OAAOI,GAAjB;AACAJ,eAAOS,MAAP;AACA,YAAIC,YAAYzB,SAAS0B,aAAT,CAAuB,QAAvB,CAAhB;AACAD,kBAAUN,GAAV,GAAgBzC,YAAYyC,GAAZ,CAAhB;AACAM,kBAAUE,KAAV,GAAkB,IAAlB;AACAF,kBAAUG,MAAV,GAAmBN,MAAnB;AACAtB,iBAAS6B,IAAT,CAAcC,WAAd,CAA0BL,SAA1B;AACD,OATH;AAUD;AA5Ca,GAAhB;AA8CA,MAAIM,OAAOxD,GAAGwD,IAAH,IAAW,IAAtB;AACA,MAAIC,OAAO3D,GAAG4D,MAAH,IAAa9D,OAAOwB,QAAP,CAAgBuC,QAA7B,IAAyC,WAApD;;AAEA,MAAIC,UAAU,SAAVA,OAAU,GAAU;AACtB,QAAIC,aAAa,IAAIlE,SAAJ,CAAc,UAAU8D,IAAV,GAAiB,GAAjB,GAAuBD,IAArC,CAAjB;AACAK,eAAWC,SAAX,GAAuB,UAASC,KAAT,EAAe;AACpC,UAAI/D,GAAGC,QAAP,EAAiB;AACjB,UAAI+D,UAAUD,MAAME,IAApB;AACA,UAAIC,WAAWhD,UAAU8C,OAAV,KAAsB9C,UAAUC,IAA/C;AACA+C;AACD,KALD;AAMAL,eAAWM,OAAX,GAAqB,YAAU;AAC7B,UAAIN,WAAWO,UAAf,EAA2BP,WAAWQ,KAAX;AAC5B,KAFD;AAGAR,eAAWS,OAAX,GAAqB,YAAU;AAC7B1E,aAAOqC,UAAP,CAAkB2B,OAAlB,EAA2B,IAA3B;AACD,KAFD;AAGD,GAdD;AAeAA;AACD,CAlFD;AAmFA","file":"public/vendor.js","sourcesContent":["\nrequire.register(\"base64-js/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"base64-js\");\n  (function() {\n    'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n  })();\n});","\nrequire.register(\"buffer/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"buffer\");\n  var _Buffer = require('buffer'); var Buffer = _Buffer && _Buffer.Buffer;\n(function() {\n    /*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(array)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n  })();\n});","\nrequire.register(\"ieee754/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"ieee754\");\n  (function() {\n    exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n  })();\n});","\nrequire.register(\"isarray/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"isarray\");\n  (function() {\n    var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n  })();\n});","\nrequire.register(\"lodash/lodash.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"lodash\");\n  var _Buffer = require('buffer'); var Buffer = _Buffer && _Buffer.Buffer;\n(function() {\n    /**\n * @license\n * lodash <https://lodash.com/>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.16.4';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://github.com/es-shims.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for function metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64,\n      ARY_FLAG = 128,\n      REARG_FLAG = 256,\n      FLIP_FLAG = 512;\n\n  /** Used to compose bitmasks for comparison styles. */\n  var UNORDERED_COMPARE_FLAG = 1,\n      PARTIAL_COMPARE_FLAG = 2;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 500,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', ARY_FLAG],\n    ['bind', BIND_FLAG],\n    ['bindKey', BIND_KEY_FLAG],\n    ['curry', CURRY_FLAG],\n    ['curryRight', CURRY_RIGHT_FLAG],\n    ['flip', FLIP_FLAG],\n    ['partial', PARTIAL_FLAG],\n    ['partialRight', PARTIAL_RIGHT_FLAG],\n    ['rearg', REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      reLeadingDot = /^\\./,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\n    rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,\n    rsUpper + '+' + rsOptUpperContr,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      return freeProcess && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */\n  function addMapEntry(map, pair) {\n    // Don't return `map.set` because it's not chainable in IE 11.\n    map.set(pair[0], pair[1]);\n    return map;\n  }\n\n  /**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */\n  function addSetEntry(set, value) {\n    // Don't return `set.add` because it's not chainable in IE 11.\n    set.add(value);\n    return set;\n  }\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array ? array.length : 0;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array ? array.length : 0;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array ? array.length : 0;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array ? array.length : 0;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objectToString = objectProto.toString;\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        iteratorSymbol = Symbol ? Symbol.iterator : undefined,\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array of at least `200` elements\n     * and any iteratees accept only one argument. The heuristic for whether a\n     * section qualifies for shortcut fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||\n          (arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries ? entries.length : 0;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries ? entries.length : 0;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries ? entries.length : 0;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values ? values.length : 0;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function assignInDefaults(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths of elements to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          isNil = object == null,\n          length = paths.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = isNil ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {boolean} [isFull] Specify a clone including symbols.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = initCloneObject(isFunc ? {} : value);\n          if (!isDeep) {\n            return copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, baseClone, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      var props = isArr ? undefined : (isFull ? getAllKeys : keys)(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = isKey(path, object) ? [path] : castPath(path);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      return objectToString.call(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      if (!isKey(path, object)) {\n        path = castPath(path);\n        object = parent(object, path);\n        path = last(path);\n      }\n      var func = object == null ? object : object[toKey(path)];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && objectToString.call(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && objectToString.call(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {boolean} [bitmask] The bitmask of comparison flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - Unordered comparison\n     *     2 - Partial comparison\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, customizer, bitmask, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = getTag(object);\n        objTag = objTag == argsTag ? objectTag : objTag;\n      }\n      if (!othIsArr) {\n        othTag = getTag(other);\n        othTag = othTag == argsTag ? objectTag : othTag;\n      }\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n          : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n      }\n      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObject(value) && objectToString.call(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        if (isObject(srcValue)) {\n          stack || (stack = new Stack);\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = object[key],\n          srcValue = source[key],\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1;\n      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property identifiers to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, props) {\n      object = Object(object);\n      return basePickBy(object, props, function(value, key) {\n        return key in object;\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property identifiers to pick from.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, props, predicate) {\n      var index = -1,\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key];\n\n        if (predicate(value, key)) {\n          baseAssignValue(result, key, value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          }\n          else if (!isKey(index, array)) {\n            var path = castPath(index),\n                object = parent(array, path);\n\n            if (object != null) {\n              delete object[toKey(last(path))];\n            }\n          }\n          else {\n            delete array[toKey(index)];\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = isKey(path, object) ? [path] : castPath(path);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array ? array.length : 0,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = isKey(path, object) ? [path] : castPath(path);\n      object = parent(object, path);\n\n      var key = toKey(last(path));\n      return !(object != null && hasOwnProperty.call(object, key)) || delete object[key];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var index = -1,\n          length = arrays.length;\n\n      while (++index < length) {\n        var result = result\n          ? arrayPush(\n              baseDifference(result, arrays[index], iteratee, comparator),\n              baseDifference(arrays[index], result, iteratee, comparator)\n            )\n          : arrays[index];\n      }\n      return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value) {\n      return isArray(value) ? value : stringToPath(value);\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `map`.\n     *\n     * @private\n     * @param {Object} map The map to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned map.\n     */\n    function cloneMap(map, isDeep, cloneFunc) {\n      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n      return arrayReduce(array, addMapEntry, new map.constructor);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of `set`.\n     *\n     * @private\n     * @param {Object} set The set to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned set.\n     */\n    function cloneSet(set, isDeep, cloneFunc) {\n      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n      return arrayReduce(array, addSetEntry, new set.constructor);\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbol properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 &&\n              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & ARY_FLAG,\n          isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),\n          isFlip = bitmask & FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n      if (!(bitmask & CURRY_BOUND_FLAG)) {\n        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = nativeMin(toInteger(precision), 292);\n        if (precision) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - `_.bind`\n     *     2 - `_.bindKey`\n     *     4 - `_.curry` or `_.curryRight` of a bound function\n     *     8 - `_.curry`\n     *    16 - `_.curryRight`\n     *    32 - `_.partial`\n     *    64 - `_.partialRight`\n     *   128 - `_.rearg`\n     *   256 - `_.ary`\n     *   512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] == null\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, customizer, bitmask, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= UNORDERED_COMPARE_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n          objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbol properties of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n    /**\n     * Creates an array of the own and inherited enumerable symbol properties\n     * of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = objectToString.call(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : undefined;\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = isKey(path, object) ? [path] : castPath(path);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object ? object.length : 0;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, cloneFunc, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return cloneMap(object, isDeep, cloneFunc);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return cloneSet(object, isDeep, cloneFunc);\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return !!length &&\n        (typeof value == 'number' || reIsUint.test(value)) &&\n        (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||\n        ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function mergeDefaults(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      string = toString(string);\n\n      var result = [];\n      if (reLeadingDot.test(string)) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to process.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array ? array.length : 0;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs ? pairs.length : 0,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array ? array.length : 0;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (comparator === last(mapped)) {\n        comparator = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array ? nativeJoin.call(array, separator) : '';\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array ? array.length : 0;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array ? array.length : 0,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array ? nativeReverse.call(array) : array;\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array ? array.length : 0;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array ? array.length : 0;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array ? array.length : 0;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false},\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length)\n        ? baseUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      return (array && array.length)\n        ? baseUniq(array, undefined, comparator)\n        : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths of elements to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity]\n     *  The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity]\n     *  The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity]\n     *  The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          isProp = isKey(path),\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\n        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity]\n     *  The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            result = wait - timeSinceLastCall;\n\n        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      wrapper = wrapper == null ? identity : wrapper;\n      return partial(wrapper, value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, false, true);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      return baseClone(value, false, true, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, true, true);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      return baseClone(value, true, true, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && objectToString.call(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return value != null && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are **not** supported.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      return (objectToString.call(value) == errorTag) ||\n        (typeof value.message == 'string' && typeof value.name == 'string');\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed array and other constructors.\n      var tag = isObject(value) ? objectToString.call(value) : '';\n      return tag == funcTag || tag == genTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && objectToString.call(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || objectToString.call(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return (typeof Ctor == 'function' &&\n        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && objectToString.call(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && objectToString.call(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (iteratorSymbol && value[iteratorSymbol]) {\n        return iteratorToArray(value[iteratorSymbol]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths of elements to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? baseAssign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(args) {\n      args.push(undefined, assignInDefaults);\n      return apply(assignInWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, mergeDefaults);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable string keyed properties of `object` that are\n     * not omitted.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [props] The property identifiers to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      props = arrayMap(props, toKey);\n      return basePick(object, baseDifference(getAllKeysIn(object), props));\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [props] The property identifiers to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, props) {\n      return object == null ? {} : basePick(object, arrayMap(props, toKey));\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      return object == null ? {} : basePickBy(object, getAllKeysIn(object), getIteratee(predicate));\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = isKey(path, object) ? [path] : castPath(path);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        object = undefined;\n        length = 1;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object ? baseValues(object, keys(object)) : [];\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = baseClamp(toInteger(position), 0, string.length);\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, assignInDefaults);\n\n      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs ? pairs.length : 0,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, true));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(value));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        var filtered = this.__filtered__;\n        if (filtered && !index) {\n          return new LazyWrapper(this);\n        }\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = this.clone();\n        if (filtered) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = (lodashFunc.name + ''),\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (iteratorSymbol) {\n      lodash.prototype[iteratorSymbol] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n  })();\n});","\nrequire.register(\"process/browser.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"process\");\n  (function() {\n    // shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n  })();\n});","\nrequire.register(\"stats.js/build/stats.min.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"stats.js\");\n  (function() {\n    // stats.js - http://github.com/mrdoob/stats.js\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n  })();\n});","\nrequire.register(\"three-orbit-controls/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"three-orbit-controls\");\n  (function() {\n    module.exports = function(THREE) {\n\tvar MOUSE = THREE.MOUSE\n\tif (!MOUSE)\n\t\tMOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\t/*global THREE, console */\n\n\tfunction OrbitConstraint ( object ) {\n\n\t\tthis.object = object;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\t// and where it pans with respect to.\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// Limits to how far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t////////////\n\t\t// internals\n\n\t\tvar scope = this;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// Current position in spherical coordinate system.\n\t\tvar theta;\n\t\tvar phi;\n\n\t\t// Pending changes\n\t\tvar phiDelta = 0;\n\t\tvar thetaDelta = 0;\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\t// API\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn theta;\n\n\t\t};\n\n\t\tthis.rotateLeft = function ( angle ) {\n\n\t\t\tthetaDelta -= angle;\n\n\t\t};\n\n\t\tthis.rotateUp = function ( angle ) {\n\n\t\t\tphiDelta -= angle;\n\n\t\t};\n\n\t\t// pass in distance in world space to move left\n\t\tthis.panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft ( distance ) {\n\n\t\t\t\tvar te = this.object.matrix.elements;\n\n\t\t\t\t// get X column of matrix\n\t\t\t\tv.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// pass in distance in world space to move up\n\t\tthis.panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp ( distance ) {\n\n\t\t\t\tvar te = this.object.matrix.elements;\n\n\t\t\t\t// get Y column of matrix\n\t\t\t\tv.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// pass in x,y of change desired in pixel space,\n\t\t// right and down are positive\n\t\tthis.pan = function ( deltaX, deltaY, screenWidth, screenHeight ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\tscope.panLeft( 2 * deltaX * targetDistance / screenHeight );\n\t\t\t\tscope.panUp( 2 * deltaY * targetDistance / screenHeight );\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t// orthographic\n\t\t\t\tscope.panLeft( deltaX * ( scope.object.right - scope.object.left ) / screenWidth );\n\t\t\t\tscope.panUp( deltaY * ( scope.object.top - scope.object.bottom ) / screenHeight );\n\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic or perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dollyIn = function ( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dollyOut = function ( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function () {\n\n\t\t\t\tvar position = this.object.position;\n\n\t\t\t\toffset.copy( position ).sub( this.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\n\t\t\t\ttheta = Math.atan2( offset.x, offset.z );\n\n\t\t\t\t// angle from y-axis\n\n\t\t\t\tphi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\t\t\ttheta += thetaDelta;\n\t\t\t\tphi += phiDelta;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\ttheta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\t\t\tvar radius = offset.length() * scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tthis.target.add( panOffset );\n\n\t\t\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\t\t\toffset.y = radius * Math.cos( phi );\n\t\t\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( this.target ).add( offset );\n\n\t\t\t\tthis.object.lookAt( this.target );\n\n\t\t\t\tif ( this.enableDamping === true ) {\n\n\t\t\t\t\tthetaDelta *= ( 1 - this.dampingFactor );\n\t\t\t\t\tphiDelta *= ( 1 - this.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthetaDelta = 0;\n\t\t\t\t\tphiDelta = 0;\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\t lastPosition.distanceToSquared( this.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( this.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tlastPosition.copy( this.object.position );\n\t\t\t\t\tlastQuaternion.copy( this.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t};\n\n\n\t// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n\t// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n\t// supported.\n\t//\n\t//    Orbit - left mouse / touch: one finger move\n\t//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n\t//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls ( object, domElement ) {\n\n\t\tvar constraint = new OrbitConstraint( object );\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// API\n\n\t\tObject.defineProperty( this, 'constraint', {\n\n\t\t\tget: function() {\n\n\t\t\t\treturn constraint;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn constraint.getPolarAngle();\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn constraint.getAzimuthalAngle();\n\n\t\t};\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// center is old, deprecated; use \"target\" instead\n\t\tthis.center = this.target;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t\t// backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t////////////\n\t\t// internals\n\n\t\tvar scope = this;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\t// for reset\n\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// events\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\t// pass in x,y of change desired in pixel space,\n\t\t// right and down are positive\n\t\tfunction pan( deltaX, deltaY ) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tconstraint.pan( deltaX, deltaY, element.clientWidth, element.clientHeight );\n\n\t\t}\n\n\t\tthis.update = function () {\n\n\t\t\tif ( this.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\tconstraint.rotateLeft( getAutoRotationAngle() );\n\n\t\t\t}\n\n\t\t\tif ( constraint.update() === true ) {\n\n\t\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tstate = STATE.NONE;\n\n\t\t\tthis.target.copy( this.target0 );\n\t\t\tthis.object.position.copy( this.position0 );\n\t\t\tthis.object.zoom = this.zoom0;\n\n\t\t\tthis.object.updateProjectionMatrix();\n\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tthis.update();\n\n\t\t};\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tconstraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tconstraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\n\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) scope.update();\n\n\t\t}\n\n\t\tfunction onMouseUp( /* event */ ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\t\tscope.dispatchEvent( endEvent );\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tvar delta = 0;\n\n\t\t\tif ( event.wheelDelta !== undefined ) {\n\n\t\t\t\t// WebKit / Opera / Explorer 9\n\n\t\t\t\tdelta = event.wheelDelta;\n\n\t\t\t} else if ( event.detail !== undefined ) {\n\n\t\t\t\t// Firefox\n\n\t\t\t\tdelta = - event.detail;\n\n\t\t\t}\n\n\t\t\tif ( delta > 0 ) {\n\n\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\n\t\t\t} else if ( delta < 0 ) {\n\n\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\t\t\tscope.dispatchEvent( startEvent );\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction touchstart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\n\t\t}\n\n\t\tfunction touchmove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\n\t\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\t\tconstraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\t\tconstraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\n\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\n\t\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\n\t\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction touchend( /* event */ ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tscope.dispatchEvent( endEvent );\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction contextmenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tthis.dispose = function() {\n\n\t\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\n\t\t\tthis.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tthis.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );\n\t\t\tthis.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\n\n\t\t\tthis.domElement.removeEventListener( 'touchstart', touchstart, false );\n\t\t\tthis.domElement.removeEventListener( 'touchend', touchend, false );\n\t\t\tthis.domElement.removeEventListener( 'touchmove', touchmove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t}\n\n\t\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\n\n\t\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\t\tthis.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\n\n\t\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\t\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\t\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tobject: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.object;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttarget: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.target;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: target is now immutable. Use target.set() instead.' );\n\t\t\t\tthis.constraint.target.copy( value );\n\n\t\t\t}\n\n\t\t},\n\n\t\tminDistance : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minDistance;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minDistance = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxDistance : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxDistance;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxDistance = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tminZoom : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minZoom = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxZoom : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxZoom = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tminPolarAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minPolarAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minPolarAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxPolarAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxPolarAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxPolarAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tminAzimuthAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minAzimuthAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minAzimuthAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxAzimuthAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxAzimuthAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxAzimuthAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tenableDamping : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.enableDamping = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.dampingFactor = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.constraint.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.constraint.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.constraint.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.constraint.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n}\n  })();\n});","\nrequire.register(\"three-window-resize/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"three-window-resize\");\n  (function() {\n    module.exports = function (renderer, camera, dimension) {\n\n  /**\n   * @author jeromeetienne / https://github.com/jeromeetienne\n   * @author SebastianNette / https://github.com/SebastianNette\n   */\n\n\tdimension = dimension || function () {\n    return {\n      width: window.innerWidth,\n      height: window.innerHeight\n    }\n  }\n\n\tvar callback\t= function(){\n\t\t// fetch target renderer size\n\t\tvar rendererSize = dimension();\n\n\t\t// notify the renderer of the size change\n\t\trenderer.setSize(rendererSize.width, rendererSize.height)\n\n\t\t// update the camera\n\t\tcamera.aspect\t= rendererSize.width / rendererSize.height\n\t\tcamera.updateProjectionMatrix()\n\t}\n\n\t// bind the resize event\n\twindow.addEventListener('resize', callback, false)\n\n\t// return .stop() the function to stop watching window resize\n\treturn {\n\t\ttrigger\t: function(){\n\t\t\tcallback()\n\t\t},\n  // Stop watching window resize\n\t\tdestroy\t: function(){\n\t\t\twindow.removeEventListener('resize', callback)\n\t\t}\n\t}\n\n}\n  })();\n});","\nrequire.register(\"three/three.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"three\");\n  (function() {\n    var self = self || {};/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Larry Battle / http://bateru.com/news\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nvar THREE = { REVISION: '66.87' };\r\n\r\nself.console = self.console || {\r\n\r\n\tinfo: function () {},\r\n\tlog: function () {},\r\n\tdebug: function () {},\r\n\twarn: function () {},\r\n\terror: function () {}\r\n\r\n};\r\n\r\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n\r\n// requestAnimationFrame polyfill by Erik Möller\r\n// fixes from Paul Irish and Tino Zijdel\r\n// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.\r\n( function () {\r\n\r\n\tvar lastTime = 0;\r\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\r\n\r\n\tfor ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {\r\n\r\n\t\tself.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];\r\n\t\tself.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\r\n\r\n\t}\r\n\r\n\tif ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {\r\n\r\n\t\tself.requestAnimationFrame = function ( callback ) {\r\n\r\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\r\n\t\t\tvar id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\r\n\t\t\tlastTime = currTime + timeToCall;\r\n\t\t\treturn id;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tif( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {\r\n\r\n\t\tself.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };\r\n\r\n\t}\r\n\r\n}() );\r\n\r\nTHREE.ExceptionErrorHandler = function( message, optionalData ) {\r\n\tconsole.error( message );\r\n\tconsole.error( optionalData );\r\n\tvar error = new Error( message );\r\n\terror.optionalData = optionalData;\r\n\tthrow error;\r\n};\r\n\r\nTHREE.ConsoleErrorHandler = function( message, optionalData ) {\r\n\tconsole.error( message );\r\n\tconsole.error( optionalData );\r\n};\r\n\r\nTHREE.ConsoleWarningHandler = function( message, optionalData ) {\r\n\tconsole.warn( message );\r\n\tconsole.warn( optionalData );\r\n};\r\n\r\nTHREE.NullHandler = function( message, optionalData ) {\r\n};\r\n\r\n// the default error handler is exception\r\nTHREE.onerror = THREE.ExceptionErrorHandler;\r\n\r\nTHREE.onwarning = THREE.ConsoleWarningHandler;\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.NoShading = 0;\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n//  mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = function () {};\r\n\r\nTHREE.CubeReflectionMapping = function () {};\r\nTHREE.CubeRefractionMapping = function () {};\r\n\r\nTHREE.SphericalReflectionMapping = function () {};\r\nTHREE.SphericalRefractionMapping = function () {};\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Texture Decoders\r\n\r\nTHREE.Linear = 3000;\r\nTHREE.sRGB = 3001;\r\nTHREE.RGBE = 3002;\r\nTHREE.LogLUV = 3003;\r\nTHREE.RGBM7 = 3004;\r\nTHREE.RGBM16 = 3005;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfType = 2005;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n\r\n// Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n/*\r\n// Potential future PVRTC compressed texture formats\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n*/\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n\tif ( arguments.length === 3 ) {\r\n\r\n\t\treturn this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\r\n\t}\r\n\r\n\treturn this.set( color )\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n\tconstructor: THREE.Color,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof THREE.Color ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function ( h, s, l ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( s === 0 ) {\r\n\r\n\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\t// rgb(255,0,0)\r\n\r\n\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// rgb(100%,0%,0%)\r\n\r\n\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #ff0000\r\n\r\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #f00\r\n\r\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// red\r\n\r\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\r\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color ) {\r\n\r\n\t\tthis.r = color.r * color.r;\r\n\t\tthis.g = color.g * color.g;\r\n\t\tthis.b = color.b * color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color ) {\r\n\r\n\t\tthis.r = Math.sqrt( color.r );\r\n\t\tthis.g = Math.sqrt( color.g );\r\n\t\tthis.b = Math.sqrt( color.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( optionalTarget ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\thsl.h = hue;\r\n\t\thsl.s = saturation;\r\n\t\thsl.l = lightness;\r\n\r\n\t\treturn hsl;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.r = array[ 0 ];\r\n\t\tthis.g = array[ 1 ];\r\n\t\tthis.b = array[ 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.r, this.g, this.b ];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\r\n\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\r\n\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\r\n\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\r\n\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\r\n\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\r\n\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\r\n\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\r\n\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\r\n\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\r\n\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\r\n\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\r\n\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\r\n\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\r\n\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\r\n\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\r\n\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\r\n\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\r\n\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\r\n\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\r\n\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\r\n\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\r\n\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\r\n\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n\tconstructor: THREE.Quaternion,\r\n\r\n\t_x: 0,_y: 0, _z: 0, _w: 0,\r\n\r\n\t_euler: undefined,\r\n\r\n\t_updateEuler: function ( callback ) {\r\n\r\n\t\tif ( this._euler !== undefined ) {\r\n\r\n\t\t\tthis._euler.setFromQuaternion( this, undefined, false );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis._updateEuler();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis._updateEuler();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis._updateEuler();\r\n\r\n\t},\r\n\r\n\tget w () {\r\n\r\n\t\treturn this._w;\r\n\r\n\t},\r\n\r\n\tset w ( value ) {\r\n\r\n\t\tthis._w = value;\r\n\t\tthis._updateEuler();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion._x;\r\n\t\tthis._y = quaternion._y;\r\n\t\tthis._z = quaternion._z;\r\n\t\tthis._w = quaternion._w;\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( ! ( euler instanceof THREE.Euler ) ) return THREE.onerror( 'expecting a Euler', euler );\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\t// axis have to be normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\t\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\r\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\r\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = (m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = (m12 + m21 ) / s;\r\n\t\t\tthis._z = (m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = (m13 - m31 ) / s;\r\n\t\t\tthis._x = (m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = (m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tadd: function ( q ) {\r\n\r\n\t\tthis._x += q._x;\r\n\t\tthis._y += q._y;\r\n\t\tthis._z += q._z;\r\n\t\tthis._w += q._w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( q ) {\r\n\r\n\t\tthis._x -= q._x;\r\n\t\tthis._y -= q._y;\r\n\t\tthis._z -= q._z;\r\n\t\tthis._w -= q._w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis._x *= s;\r\n\t\tthis._y *= s;\r\n\t\tthis._z *= s;\r\n\t\tthis._w *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= -1;\r\n\t\tthis._y *= -1;\r\n\t\tthis._z *= -1;\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\treturn vector.applyQuaternion( this );\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = -qb._w;\r\n\t\t\tthis._x = -qb._x;\r\n\t\t\tthis._y = -qb._y;\r\n\t\t\tthis._z = -qb._z;\r\n\r\n\t\t\tcosHalfTheta = -cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tthis._w = array[ 3 ];\r\n\r\n\t\tthis._updateEuler();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this._x, this._y, this._z, this._w ];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n}\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n\tconstructor: THREE.Vector2,\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: return THREE.onerror( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: return THREE.onerror( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\tmax = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\t\t\r\n\t} )(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\treturn this.multiplyScalar( - 1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.x = array[ 0 ];\r\n\t\tthis.y = array[ 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y ];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector2( this.x, this.y );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n\tconstructor: THREE.Vector3,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: return THREE.onerror( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: return THREE.onerror( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarningn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function ( euler ) {\r\n\r\n\t\t\tif ( ! ( euler instanceof THREE.Euler ) ) return THREE.onerror( 'expecting an Euler', euler );\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\t//if ( ! ( m instanceof THREE.Matrix3 ) ) return THREE.onerror( 'expecting an Matrix3', m );\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\r\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\r\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting an Matrix4', m );\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting an Matrix4', m );\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\r\n\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\r\n\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = -qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\t\t\tthis.z *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\tmax = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\treturn this.multiplyScalar( - 1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1, dot;\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\r\n\t\t\tdot = this.dot( v1 );\r\n\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( planeNormal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( normal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n\t\tTHREE.onerror( \"REMOVED: Vector3\\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.\");\r\n\r\n\t},\r\n\r\n\tsetEulerFromQuaternion: function ( q, order ) {\r\n\r\n\t\tTHREE.onerror( \"REMOVED: Vector3\\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.\");\r\n\r\n\t},\r\n\r\n\tgetPositionFromMatrix: function ( m ) {\r\n\r\n\t\tTHREE.onwarning( \"DEPRECATED: Vector3\\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.\" );\r\n\r\n\t\treturn this.setFromMatrixPosition( m );\r\n\r\n\t},\r\n\r\n\tgetScaleFromMatrix: function ( m ) {\r\n\r\n\t\tTHREE.onwarning( \"DEPRECATED: Vector3\\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.\" );\r\n\r\n\t\treturn this.setFromMatrixScale( m );\r\n\t},\r\n\r\n\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\r\n\t\tTHREE.onwarning( \"DEPRECATED: Vector3\\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.\" );\r\n\r\n\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\tthis.x = m.elements[ 12 ];\r\n\t\tthis.y = m.elements[ 13 ];\r\n\t\tthis.z = m.elements[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\r\n\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\r\n\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( index, matrix ) {\r\n\r\n\t\tvar offset = index * 4;\r\n\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tthis.x = me[ offset ];\r\n\t\tthis.y = me[ offset + 1 ];\r\n\t\tthis.z = me[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.x = array[ 0 ];\r\n\t\tthis.y = array[ 1 ];\r\n\t\tthis.z = array[ 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y, this.z ];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n\tconstructor: THREE.Vector4,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: return THREE.onerror( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: return THREE.onerror( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\tthis.w *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\t\t\tthis.z *= invScalar;\r\n\t\t\tthis.w *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\r\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\r\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w > v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < min.w ) {\r\n\r\n\t\t\tthis.w = min.w;\r\n\r\n\t\t} else if ( this.w > max.w ) {\r\n\r\n\t\t\tthis.w = max.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\tmax = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n    floor: function () {\r\n\r\n        this.x = Math.floor( this.x );\r\n        this.y = Math.floor( this.y );\r\n        this.z = Math.floor( this.z );\r\n        this.w = Math.floor( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    ceil: function () {\r\n\r\n        this.x = Math.ceil( this.x );\r\n        this.y = Math.ceil( this.y );\r\n        this.z = Math.ceil( this.z );\r\n        this.w = Math.ceil( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    round: function () {\r\n\r\n        this.x = Math.round( this.x );\r\n        this.y = Math.round( this.y );\r\n        this.z = Math.round( this.z );\r\n        this.w = Math.round( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    roundToZero: function () {\r\n\r\n        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n\tnegate: function () {\r\n\r\n\t\treturn this.multiplyScalar( -1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.x = array[ 0 ];\r\n\t\tthis.y = array[ 1 ];\r\n\t\tthis.z = array[ 2 ];\r\n\t\tthis.w = array[ 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y, this.z, this.w ];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n\tconstructor: THREE.Euler,\r\n\r\n\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\r\n\r\n\t_quaternion: undefined,\r\n\r\n\t_updateQuaternion: function () {\r\n\r\n\t\tif ( this._quaternion !== undefined ) {\r\n\r\n\t\t\tthis._quaternion.setFromEuler( this, false );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis._updateQuaternion();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis._updateQuaternion();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis._updateQuaternion();\r\n\r\n\t},\r\n\r\n\tget order () {\r\n\r\n\t\treturn this._order;\r\n\r\n\t},\r\n\r\n\tset order ( value ) {\r\n\r\n\t\tthis._order = value;\r\n\t\tthis._updateQuaternion();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis._updateQuaternion();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromVector: function ( v, order ) {\r\n\r\n\t\tthis._x = v.x;\r\n\t\tthis._y = v.y;\r\n\t\tthis._z = v.z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis._updateQuaternion();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis._updateQuaternion();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\tfunction clamp( x ) {\r\n\r\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\r\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\r\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.onwarning( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this._updateQuaternion();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function() {\r\n\r\n\t   var mIntermediate = null;\r\n\t   \r\n\t   return function( q, order, update ) {\r\n\t   \r\n\t   \t  mIntermediate = mIntermediate || new THREE.Matrix4();\r\n\t      mIntermediate.makeRotationFromQuaternion( q );\r\n\t      this.setFromRotationMatrix( mIntermediate, order, update );\r\n\t   \r\n\t      return this;\r\n\t   };\r\n\r\n\t}(),\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new THREE.Quaternion();\r\n\r\n\t\treturn function ( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\r\n\t}(),\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis._updateQuaternion();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this._x, this._y, this._z, this._order ];\r\n\r\n\t},\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif( optionalResult ) {\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n\tconstructor: THREE.Line3,\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function() {\r\n\r\n\t\tvar startP = new THREE.Vector3();\r\n\t\tvar startEnd = new THREE.Vector3();\r\n\r\n\t\treturn function ( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Line3().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n\tconstructor: THREE.Box2,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\tvar point = points[ 0 ];\r\n\r\n\t\t\tthis.min.copy( point );\r\n\t\t\tthis.max.copy( point );\r\n\r\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpoint = points[ i ];\r\n\r\n\t\t\t\tif ( point.x < this.min.x ) {\r\n\r\n\t\t\t\t\tthis.min.x = point.x;\r\n\r\n\t\t\t\t} else if ( point.x > this.max.x ) {\r\n\r\n\t\t\t\t\tthis.max.x = point.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.y < this.min.y ) {\r\n\r\n\t\t\t\t\tthis.min.y = point.y;\r\n\r\n\t\t\t\t} else if ( point.y > this.max.y ) {\r\n\r\n\t\t\t\t\tthis.max.y = point.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = Infinity;\r\n\t\tthis.max.x = this.max.y = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( -scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box2().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n\tconstructor: THREE.Box3,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x ) {\r\n\r\n\t\t\tthis.min.x = point.x;\r\n\r\n\t\t} else if ( point.x > this.max.x ) {\r\n\r\n\t\t\tthis.max.x = point.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( point.y < this.min.y ) {\r\n\r\n\t\t\tthis.min.y = point.y;\r\n\r\n\t\t} else if ( point.y > this.max.y ) {\r\n\r\n\t\t\tthis.max.y = point.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( point.z < this.min.z ) {\r\n\r\n\t\t\tthis.min.z = point.z;\r\n\r\n\t\t} else if ( point.z > this.max.z ) {\r\n\r\n\t\t\tthis.max.z = point.z;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\tvar point = points[ 0 ];\r\n\r\n\t\t\tthis.min.copy( point );\r\n\t\t\tthis.max.copy( point );\r\n\r\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tthis.addPoint( points[ i ] )\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function() {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and childrens', world transforms\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function( object ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tif ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {\r\n\r\n\t\t\t\t\tvar vertices = node.geometry.vertices;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i++ ) {\r\n\r\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\r\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( -scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function() {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n\t\t\tthis.makeEmpty();\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box3().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\tthis.elements = new Float32Array(9);\r\n\r\n\tthis.set(\r\n\r\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\r\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\r\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\r\n\r\n\t);\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n\tconstructor: THREE.Matrix3,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] = n11; te[3] = n12; te[6] = n13;\r\n\t\tte[1] = n21; te[4] = n22; te[7] = n23;\r\n\t\tte[2] = n31; te[5] = n32; te[8] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[0], me[3], me[6],\r\n\t\t\tme[1], me[4], me[7],\r\n\t\t\tme[2], me[5], me[8]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix3( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a ) {\r\n\r\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tv1.x = a[ i ];\r\n\t\t\t\tv1.y = a[ i + 1 ];\r\n\t\t\t\tv1.z = a[ i + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix3(this);\r\n\r\n\t\t\t\ta[ i ]     = v1.x;\r\n\t\t\t\ta[ i + 1 ] = v1.y;\r\n\t\t\t\ta[ i + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\r\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\r\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[0], b = te[1], c = te[2],\r\n\t\t\td = te[3], e = te[4], f = te[5],\r\n\t\t\tg = te[6], h = te[7], i = te[8];\r\n\r\n\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, errorOnInvertible ) {\r\n\r\n\t\tif ( ! ( matrix instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', matrix );\r\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n\t\tvar me = matrix.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\r\n\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\r\n\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\r\n\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\r\n\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\r\n\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\r\n\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\r\n\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\r\n\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n\t\t// no inverse\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tif ( errorOnInvertible === true ) {\r\n\r\n\t\t\t\treturn THREE.onerror( \"Matrix3.getInverse(): can't invert matrix, determinant is 0\", this );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1.0 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\r\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\r\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( m ) {\r\n\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );\r\n\r\n\t\tthis.getInverse( m ).transpose();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn new THREE.Matrix3(\r\n\r\n\t\t\tte[0], te[3], te[6],\r\n\t\t\tte[1], te[4], te[7],\r\n\t\t\tte[2], te[5], te[8]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n\r\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\tthis.elements = new Float32Array( 16 );\r\n\r\n\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\r\n\t//   we should not support semi specification of Matrix4, it is just weird.\r\n\r\n\tvar te = this.elements;\r\n\r\n\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\r\n\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\r\n\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\r\n\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n\tconstructor: THREE.Matrix4,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\r\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\r\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\r\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tthis.elements.set( m.elements );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractPosition: function ( m ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .extractPosition() has been renamed to .copyPosition().' );\r\n\t\treturn this.copyPosition( m );\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[12] = me[12];\r\n\t\tte[13] = me[13];\r\n\t\tte[14] = me[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\txAxis.set( te[0], te[1], te[2] );\r\n\t\tyAxis.set( te[4], te[5], te[6] );\r\n\t\tzAxis.set( te[8], te[9], te[10] );\r\n\r\n\t\treturn this;\r\n\t\t\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.identity();\r\n\r\n\t\tvar te = this.elements;\r\n\t    te.elements[0] = xAxis.x; te.elements[1] = xAxis.y; te.elements[2] = xAxis.z;\r\n\t    te.elements[4] = yAxis.x; te.elements[5] = yAxis.y; te.elements[6] = yAxis.z;\r\n\t    te.elements[8] = zAxis.x; te.elements[9] = zAxis.y; te.elements[10] = zAxis.z;\r\n\r\n\t    return this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\r\n\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\r\n\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\r\n\r\n\t\t\tte[0] = me[0] * scaleX;\r\n\t\t\tte[1] = me[1] * scaleX;\r\n\t\t\tte[2] = me[2] * scaleX;\r\n\r\n\t\t\tte[4] = me[4] * scaleY;\r\n\t\t\tte[5] = me[5] * scaleY;\r\n\t\t\tte[6] = me[6] * scaleY;\r\n\r\n\t\t\tte[8] = me[8] * scaleZ;\r\n\t\t\tte[9] = me[9] * scaleZ;\r\n\t\t\tte[10] = me[10] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( ! ( euler instanceof THREE.Euler ) ) return THREE.onerror( 'expecting a Euler', euler );\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = - c * f;\r\n\t\t\tte[8] = d;\r\n\r\n\t\t\tte[1] = af + be * d;\r\n\t\t\tte[5] = ae - bf * d;\r\n\t\t\tte[9] = - b * c;\r\n\r\n\t\t\tte[2] = bf - ae * d;\r\n\t\t\tte[6] = be + af * d;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[0] = ce + df * b;\r\n\t\t\tte[4] = de * b - cf;\r\n\t\t\tte[8] = a * d;\r\n\r\n\t\t\tte[1] = a * f;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = - b;\r\n\r\n\t\t\tte[2] = cf * b - de;\r\n\t\t\tte[6] = df + ce * b;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[0] = ce - df * b;\r\n\t\t\tte[4] = - a * f;\r\n\t\t\tte[8] = de + cf * b;\r\n\r\n\t\t\tte[1] = cf + de * b;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = df - ce * b;\r\n\r\n\t\t\tte[2] = - a * d;\r\n\t\t\tte[6] = b;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = be * d - af;\r\n\t\t\tte[8] = ae * d + bf;\r\n\r\n\t\t\tte[1] = c * f;\r\n\t\t\tte[5] = bf * d + ae;\r\n\t\t\tte[9] = af * d - be;\r\n\r\n\t\t\tte[2] = - d;\r\n\t\t\tte[6] = b * c;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = bd - ac * f;\r\n\t\t\tte[8] = bc * f + ad;\r\n\r\n\t\t\tte[1] = f;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = - b * e;\r\n\r\n\t\t\tte[2] = - d * e;\r\n\t\t\tte[6] = ad * f + bc;\r\n\t\t\tte[10] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = - f;\r\n\t\t\tte[8] = d * e;\r\n\r\n\t\t\tte[1] = ac * f + bd;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = ad * f - bc;\r\n\r\n\t\t\tte[2] = bc * f - ad;\r\n\t\t\tte[6] = b * e;\r\n\t\t\tte[10] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// last column\r\n\t\tte[3] = 0;\r\n\t\tte[7] = 0;\r\n\t\tte[11] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[12] = 0;\r\n\t\tte[13] = 0;\r\n\t\tte[14] = 0;\r\n\t\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );\r\n\r\n\t\treturn this.makeRotationFromQuaternion( q );\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[0] = 1 - ( yy + zz );\r\n\t\tte[4] = xy - wz;\r\n\t\tte[8] = xz + wy;\r\n\r\n\t\tte[1] = xy + wz;\r\n\t\tte[5] = 1 - ( xx + zz );\r\n\t\tte[9] = yz - wx;\r\n\r\n\t\tte[2] = xz - wy;\r\n\t\tte[6] = yz + wx;\r\n\t\tte[10] = 1 - ( xx + yy );\r\n\r\n\t\t// last column\r\n\t\tte[3] = 0;\r\n\t\tte[7] = 0;\r\n\t\tte[11] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[12] = 0;\r\n\t\tte[13] = 0;\r\n\t\tte[14] = 0;\r\n\t\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function() {\r\n\r\n\t\tvar x = new THREE.Vector3();\r\n\t\tvar y = new THREE.Vector3();\r\n\t\tvar z = new THREE.Vector3();\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.length() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.length() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\r\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\r\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tmultiplyList: function ( listOfMatrices ) {\r\n\r\n\t\tfor (var i = 0, il = listOfMatrices.length; i < il ; i++) {\r\n\t\t  this.multiplyMatrices( this, listOfMatrices[ i ] );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyMatricesList: function ( listOfMatrices ) {\r\n\r\n\t\tif( listOfMatrices.length > 0 ) {\r\n\t\t\r\n\t\t\tthis.copy( listOfMatrices[0] );\r\n\r\n\t\t\tthis.multiplyList( listOfMatrices.slice( 1 ) );\r\n\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\tthis.identity();\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tif ( ! ( a instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', a );\r\n\t\tif ( ! ( b instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', b );\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\r\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\r\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\r\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\r\n\r\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\r\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\r\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\r\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\r\n\r\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\r\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\r\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\r\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\r\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\r\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\r\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\treturn vector.applyProjection( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector4: function ( vector ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a ) {\r\n\r\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tv1.x = a[ i ];\r\n\t\t\t\tv1.y = a[ i + 1 ];\r\n\t\t\t\tv1.z = a[ i + 2 ];\r\n\r\n\t\t\t\tv1.applyProjection( this );\r\n\r\n\t\t\t\ta[ i ]     = v1.x;\r\n\t\t\t\ta[ i + 1 ] = v1.y;\r\n\t\t\t\ta[ i + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateAxis: function ( v ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\r\n\t\tv.transformDirection( this );\r\n\r\n\t},\r\n\r\n\tcrossVector: function ( vector ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\r\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\r\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\r\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+n14 * n23 * n32\r\n\t\t\t\t-n13 * n24 * n32\r\n\t\t\t\t-n14 * n22 * n33\r\n\t\t\t\t+n12 * n24 * n33\r\n\t\t\t\t+n13 * n22 * n34\r\n\t\t\t\t-n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+n11 * n23 * n34\r\n\t\t\t\t-n11 * n24 * n33\r\n\t\t\t\t+n14 * n21 * n33\r\n\t\t\t\t-n13 * n21 * n34\r\n\t\t\t\t+n13 * n24 * n31\r\n\t\t\t\t-n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+n11 * n24 * n32\r\n\t\t\t\t-n11 * n22 * n34\r\n\t\t\t\t-n14 * n21 * n32\r\n\t\t\t\t+n12 * n21 * n34\r\n\t\t\t\t+n14 * n22 * n31\r\n\t\t\t\t-n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t-n13 * n22 * n31\r\n\t\t\t\t-n11 * n23 * n32\r\n\t\t\t\t+n11 * n22 * n33\r\n\t\t\t\t+n13 * n21 * n32\r\n\t\t\t\t-n12 * n21 * n33\r\n\t\t\t\t+n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\r\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\r\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\r\n\r\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\r\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\r\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArray: function ( flat ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\r\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\r\n\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\r\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\r\n\r\n\t\treturn flat;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function( flat, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tflat[ offset ] = te[0];\r\n\t\tflat[ offset + 1 ] = te[1];\r\n\t\tflat[ offset + 2 ] = te[2];\r\n\t\tflat[ offset + 3 ] = te[3];\r\n\r\n\t\tflat[ offset + 4 ] = te[4];\r\n\t\tflat[ offset + 5 ] = te[5];\r\n\t\tflat[ offset + 6 ] = te[6];\r\n\t\tflat[ offset + 7 ] = te[7];\r\n\r\n\t\tflat[ offset + 8 ]  = te[8];\r\n\t\tflat[ offset + 9 ]  = te[9];\r\n\t\tflat[ offset + 10 ] = te[10];\r\n\t\tflat[ offset + 11 ] = te[11];\r\n\r\n\t\tflat[ offset + 12 ] = te[12];\r\n\t\tflat[ offset + 13 ] = te[13];\r\n\t\tflat[ offset + 14 ] = te[14];\r\n\t\tflat[ offset + 15 ] = te[15];\r\n\r\n\t\treturn flat;\r\n\r\n\t},\r\n\r\n\tgetPosition: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tTHREE.onwarning( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\treturn v1.set( te[12], te[13], te[14] );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[12] = v.x;\r\n\t\tte[13] = v.y;\r\n\t\tte[14] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, errorOnInvertible ) {\r\n\r\n\t\t//if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\r\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\r\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\r\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\r\n\r\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\r\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\r\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\r\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\r\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\r\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\r\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\r\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\r\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\r\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\r\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\r\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\r\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\r\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\r\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\r\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\r\n\r\n\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\r\n\t\tif ( det == 0 ) {\r\n\r\n\t\t\tif ( errorOnInvertible === true ) {\r\n\r\n\t\t\t\t return THREE.onerror( \"Matrix4.getInverse(): can't invert matrix, determinant is 0\", this );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( v ) {\r\n\r\n\t\tTHREE.onerror( 'DEPRECATED: Matrix4\\'s .translate() has been removed.');\r\n\r\n\t},\r\n\r\n\trotateX: function ( angle ) {\r\n\r\n\t\tTHREE.onerror( 'DEPRECATED: Matrix4\\'s .rotateX() has been removed.');\r\n\r\n\t},\r\n\r\n\trotateY: function ( angle ) {\r\n\r\n\t\tTHREE.onerror( 'DEPRECATED: Matrix4\\'s .rotateY() has been removed.');\r\n\r\n\t},\r\n\r\n\trotateZ: function ( angle ) {\r\n\r\n\t\tTHREE.onerror( 'DEPRECATED: Matrix4\\'s .rotateZ() has been removed.');\r\n\r\n\t},\r\n\r\n\trotateByAxis: function ( axis, angle ) {\r\n\r\n\t\tTHREE.onerror( 'DEPRECATED: Matrix4\\'s .rotateByAxis() has been removed.');\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\r\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\r\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\r\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\r\n\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\r\n\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, -s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t-s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, -s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\r\n\tmakeShear: function ( vector3Shear, reverseStyle ) {\r\n\r\n\t\tvar xy = vector3Shear.x;\r\n    \tvar xz = vector3Shear.y;\r\n    \tvar yz = vector3Shear.z;\r\n\r\n\t\tif ( reverseStyle ) {\r\n\r\n\t\t  this.set(\r\n\t\t    1,  0,  0,  0,\r\n\t\t    xy, 1,  0,  0,\r\n\t\t    xz, yz, 1,  0,\r\n\t\t    0,   0,  0,  1\r\n\t\t  );\r\n\r\n\t\t} else {\r\n\t\t  // Maya style\r\n\t\t  this.set(\r\n\t\t    1,  xy, xz, 0,\r\n\t\t    0,  1,  yz, 0,\r\n\t\t    0,  0,  1,  0,\r\n\t\t    0,  0,  0,  1\r\n\t\t  );\r\n\t\t}\r\n\r\n\t    return this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\tthis.scale( scale );\r\n\t\tthis.setPosition( position );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[0], te[1], te[2] ).length();\r\n\t\t\tvar sy = vector.set( te[4], te[5], te[6] ).length();\r\n\t\t\tvar sz = vector.set( te[8], te[9], te[10] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif( det < 0 ) {\r\n\t\t\t\tsx = -sx;\r\n\t\t\t}\r\n\r\n\t\t\tposition.x = te[12];\r\n\t\t\tposition.y = te[13];\r\n\t\t\tposition.z = te[14];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[0] *= invSX;\r\n\t\t\tmatrix.elements[1] *= invSX;\r\n\t\t\tmatrix.elements[2] *= invSX;\r\n\r\n\t\t\tmatrix.elements[4] *= invSY;\r\n\t\t\tmatrix.elements[5] *= invSY;\r\n\t\t\tmatrix.elements[6] *= invSY;\r\n\r\n\t\t\tmatrix.elements[8] *= invSZ;\r\n\t\t\tmatrix.elements[9] *= invSZ;\r\n\t\t\tmatrix.elements[10] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far, filmOffset, filmSize ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\r\n\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\r\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\r\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\r\n\r\n\t\tif( filmOffset && filmSize ) {\r\n\t\t\t// shift principle point, details: http://ksimek.github.io/2013/08/13/intrinsic/\r\n\t\t\tif( filmSize.x !== 0 ) {\r\n\t\t\t\tte[8] += 2 * filmOffset.x / filmSize.x;\r\n\t\t\t}\r\n\t\t\tif( filmSize.y !== 0 ) {\r\n\t\t\t\tte[9] += 2 * filmOffset.y / filmSize.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far, filmOffset, filmSize ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far, filmOffset, filmSize );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = right - left;\r\n\t\tvar h = top - bottom;\r\n\t\tvar p = far - near;\r\n\r\n\t\tvar x = ( right + left ) / w;\r\n\t\tvar y = ( top + bottom ) / h;\r\n\t\tvar z = ( far + near ) / p;\r\n\r\n\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\r\n\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\r\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\r\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn new THREE.Matrix4(\r\n\r\n\t\t\tte[0], te[4], te[8], te[12],\r\n\t\t\tte[1], te[5], te[9], te[13],\r\n\t\t\tte[2], te[6], te[10], te[14],\r\n\t\t\tte[3], te[7], te[11], te[15]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n\tconstructor: THREE.Ray,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn result.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceTo( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceTo( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t// It returns the min distance between the ray and the segment\r\n\t\t// defined by v0 and v1\r\n\t\t// It can also set two optional targets :\r\n\t\t// - The closest point on the ray\r\n\t\t// - The closest point on the segment\r\n\r\n\t\tvar segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );\r\n\t\tvar segDir = v1.clone().sub( v0 ).normalize();\r\n\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\tvar diff = this.origin.clone().sub( segCenter );\r\n\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\tvar b0 = diff.dot( this.direction );\r\n\t\tvar b1 = - diff.dot( segDir );\r\n\t\tvar c = diff.lengthSq();\r\n\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\tif ( det >= 0 ) {\r\n\r\n\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\textDet = segExtent * det;\r\n\r\n\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( s1 <= - extDet) {\r\n\r\n\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t}\r\n\r\n\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\toptionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\toptionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn sqrDist;\r\n\r\n\t},\r\n\r\n\tisIntersectionSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n\t},\r\n\r\n\tisIntersectionPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t :  null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function () {\r\n\t\t\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tintersectBox: function ( box , optionalTarget ) {\r\n\r\n\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\r\n\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\r\n\r\n\t\tvar invdirx = 1/this.direction.x,\r\n\t\t\tinvdiry = 1/this.direction.y,\r\n\t\t\tinvdirz = 1/this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif (invdirx >= 0) {\r\n\t\t\t\t\r\n\t\t\ttmin = (box.min.x - origin.x) * invdirx;\r\n\t\t\ttmax = (box.max.x - origin.x) * invdirx;\r\n\r\n\t\t} else { \r\n\r\n\t\t\ttmin = (box.max.x - origin.x) * invdirx;\r\n\t\t\ttmax = (box.min.x - origin.x) * invdirx;\r\n\t\t}\t\t\t\r\n\r\n\t\tif (invdiry >= 0) {\r\n\t\t\r\n\t\t\ttymin = (box.min.y - origin.y) * invdiry;\r\n\t\t\ttymax = (box.max.y - origin.y) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = (box.max.y - origin.y) * invdiry;\r\n\t\t\ttymax = (box.min.y - origin.y) * invdiry;\r\n\t\t}\r\n\r\n\t\tif ((tmin > tymax) || (tymin > tmax)) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\t\t\r\n\t\tif (tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif (tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif (invdirz >= 0) {\r\n\t\t\r\n\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\r\n\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\r\n\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\r\n\t\t}\r\n\r\n\t\tif ((tmin > tzmax) || (tzmin > tmax)) return null;\r\n\r\n\t\tif (tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif (tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n\t},\r\n\r\n\tintersectTriangle: function() {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new THREE.Vector3();\r\n\t\tvar edge1 = new THREE.Vector3();\r\n\t\tvar edge2 = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\t\r\n\t\t}\r\n\t\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\t\tthis.direction.normalize();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Ray().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n\tconstructor: THREE.Sphere,\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\treturn function ( points, optionalCenter )  {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0, cx = center.x, cy = center.y, cz = center.z;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar pt = points[ i ];\r\n\t\t\t\tvar dx = cx - pt.x;\r\n\t\t\t\tvar dy = cy - pt.y;\r\n\t\t\t\tvar dz = cz - pt.z;\r\n\r\n\t\t\t\tvar distanceSquared = dx * dx + dy * dy + dz * dz;\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, distanceSquared );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\t\t\t\r\n \t\t\r\n \t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Sphere().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n\tconstructor: THREE.Frustum,\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[0].copy( p0 );\r\n\t\tplanes[1].copy( p1 );\r\n\t\tplanes[2].copy( p2 );\r\n\t\tplanes[3].copy( p3 );\r\n\t\tplanes[4].copy( p4 );\r\n\t\tplanes[5].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[i].copy( frustum.planes[i] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\r\n\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\r\n\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\r\n\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = -sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox : function() {\r\n\r\n\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\tp2 = new THREE.Vector3();\r\n\r\n\t\treturn function( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\t\t\t\r\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\t\t\t\r\n\t\t\t\tvar plane = planes[i];\r\n\t\t\t\t\r\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\t\t\t\t\r\n\t\t\t\t// if both outside plane, no intersection\r\n\r\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn false;\r\n\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Frustum().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n\tconstructor: THREE.Plane,\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= -1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tisIntersectionLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectLine: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar m1 = new THREE.Matrix3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tif ( ! ( matrix instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', matrix );\r\n\r\n\t\t\t// compute new normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\t\t\t\r\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Plane().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\tPI2: Math.PI * 2,\r\n\tDegreeToRadiansFactor: Math.PI / 180,\r\n\tRadianToDegreesFactor: 180 / Math.PI,\r\n\r\n\tgenerateUUID: function () {\r\n\r\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\t\t\r\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\r\n\t\tvar uuid = new Array(36);\r\n\t\tvar rnd = 0, r;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\r\n\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\r\n\t\t\t\r\n\t\t\t\t\tuuid[ i ] = '-';\r\n\t\t\t\r\n\t\t\t\t} else if ( i == 14 ) {\r\n\t\t\t\r\n\t\t\t\t\tuuid[ i ] = '4';\r\n\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\r\n\t\t\t\t\tif (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\r\n\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn uuid.join('');\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// Clamp value to range <a, b>\r\n\r\n\tclamp: function ( x, a, b ) {\r\n\r\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n\t},\r\n\r\n\t// Clamp value to range <a, inf)\r\n\r\n\tclampBottom: function ( x, a ) {\r\n\r\n\t\treturn x < a ? a : x;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min )/( max - min );\r\n\r\n\t\treturn x*x*(3 - 2*x);\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min )/( max - min );\r\n\r\n\t\treturn x*x*x*(x*(x*6 - 15) + 10);\r\n\r\n\t},\r\n\r\n\t// Random float from <0, 1> with 16 bits of randomness\r\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n\trandom16: function () {\r\n\r\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tsign: function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;\r\n\r\n\t},\r\n\r\n\tdegToRad: function ( degrees ) {\r\n\r\n\t\treturn degrees * this.DegreeToRadiansFactor;\r\n\r\n\t},\r\n\r\n\tradToDeg: function ( radians ) {\r\n\r\n\t\treturn radians * this.RadianToDegreesFactor;\r\n\r\n\t},\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint != oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\tlinearDistance, realDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function() {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function ( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycoordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function() {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// colinear or singular triangle\r\n\t\tif( denom == 0 ) {\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( -2, -1, -1 );\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycoordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function() {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[i0] );\r\n\t\tthis.b.copy( points[i1] );\r\n\t\tthis.c.copy( points[i2] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function() {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Triangle().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Vertex = function ( v ) {\r\n\r\n\treturn THREE.onerror( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.' );\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.UV = function ( u, v ) {\r\n\r\n\tTHREE.onerror( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\r\n\treturn new THREE.Vector2( u, v );\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n\tconstructor: THREE.Clock,\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t? self.performance.now()\r\n\t\t\t\t\t: Date.now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t? self.performance.now()\r\n\t\t\t\t\t: Date.now();\r\n\r\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {}\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n\tconstructor: THREE.EventDispatcher,\r\n\r\n\tapply: function ( object ) {\r\n\r\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n\t},\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function () {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\treturn function ( event ) {\r\n\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\t\tevent.target = this;\r\n\r\n\t\t\t\tvar length = listenerArray.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t};\r\n\r\n\tvar sphere = new THREE.Sphere();\r\n\tvar localRay = new THREE.Ray();\r\n\tvar facePlane = new THREE.Plane();\r\n\tvar intersectPoint = new THREE.Vector3();\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\r\n\tvar descSort = function ( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t};\r\n\r\n\tvar vA = new THREE.Vector3();\r\n\tvar vB = new THREE.Vector3();\r\n\tvar vC = new THREE.Vector3();\r\n\r\n\tvar intersectObject = function ( object, raycaster, intersects ) {\r\n\r\n\t\tif ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\tmatrixPosition.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\r\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\r\n\t\t\tif ( distance > object.scale.x ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( {\r\n\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: object.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: object\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else if ( object instanceof THREE.LOD ) {\r\n\r\n\t\t\tmatrixPosition.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\t\tintersectObject( object.getObjectForDistance( distance ), raycaster, intersects );\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check boundingBox before continuing\r\n\t\t\t\r\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );  \r\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tif ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {\r\n\r\n\t\t\t\t\treturn intersects;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} \r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\tif ( material === undefined ) return intersects;\r\n\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {\r\n\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\ta = index + indices[ i ];\r\n\t\t\t\t\t\t\tb = index + indices[ i + 1 ]; \r\n\t\t\t\t\t\t\tc = index + indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\t\tvA.set(\r\n\t\t\t\t\t\t\t\tpositions[ a * 3 ],\r\n\t\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\r\n\t\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tvB.set(\r\n\t\t\t\t\t\t\t\tpositions[ b * 3 ],\r\n\t\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\r\n\t\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tvC.set(\r\n\t\t\t\t\t\t\t\tpositions[ c * 3 ],\r\n\t\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\r\n\t\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); \r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\t\tindices: [a, b, c],\r\n\t\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = attributes.position.array.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\tb = i + 1;\r\n\t\t\t\t\t\tc = i + 2;\r\n\r\n\t\t\t\t\t\tvA.set(\r\n\t\t\t\t\t\t\tpositions[ a * 3 ],\r\n\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\r\n\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tvB.set(\r\n\t\t\t\t\t\t\tpositions[ b * 3 ],\r\n\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\r\n\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tvC.set(\r\n\t\t\t\t\t\t\tpositions[ c * 3 ],\r\n\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\r\n\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); \r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\tindices: [a, b, c],\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\r\n\r\n\t\t\t\tvar a, b, c, d;\r\n\t\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tvar face = geometry.faces[ f ];\r\n\r\n\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\r\n\r\n\t\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\r\n\t\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\r\n\t\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\r\n\r\n\t\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\r\n\t\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\r\n\t\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\r\n\r\n\t\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\r\n\t\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\r\n\t\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvA.add( a );\r\n\t\t\t\t\t\tvB.add( b );\r\n\t\t\t\t\t\tvC.add( c );\r\n\r\n\t\t\t\t\t\ta = vA;\r\n\t\t\t\t\t\tb = vB;\r\n\t\t\t\t\t\tc = vC;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( c, b, a, true );\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\tface: face,\r\n\t\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\tvar precisionSq = precision * precision;\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\t\t\t\r\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );\r\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\t/* if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t} else */ if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\t\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\t\tvar step = object.type === THREE.LineStrip ? 1 : 2;\r\n\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i = i + step ) {\r\n\r\n\t\t\t\t\tvar distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tvar distance = localRay.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( object.matrixWorld ),\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar intersectDescendants = function ( object, raycaster, intersects ) {\r\n\r\n\t\tvar descendants = object.getDescendants();\r\n\r\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype.precision = 0.0001;\r\n\tTHREE.Raycaster.prototype.linePrecision = 1;\r\n\r\n\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t};\r\n\r\n\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\r\n\r\n\t\tvar intersects = [];\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tintersectDescendants( object, this, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tintersectObject( object, this, intersects );\r\n\r\n\t\tintersects.sort( descSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\r\n\r\n\t\tvar intersects = [];\r\n\r\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this, intersects );\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tintersects.sort( descSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tthis.id = THREE.Object3DIdCount ++;\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\tthis.className = \"Object3D\";\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.parent = undefined;\r\n\tthis.children = [];\r\n\r\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\tthis.position = new THREE.Vector3();\r\n\tthis._rotation = new THREE.Euler();\r\n\tthis._quaternion = new THREE.Quaternion();\r\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\t// keep rotation and quaternion in sync\r\n\r\n\tthis._rotation._quaternion = this.quaternion;\r\n\tthis._quaternion._euler = this.rotation;\r\n\r\n\tthis.renderDepth = null;\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\r\n\tthis.userData = {};\r\n\r\n};\r\n\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\t\r\n\tget rotation () { \r\n\t\treturn this._rotation; \r\n\t},\r\n\r\n\tset rotation ( value ) {\r\n\t\t\r\n\t\tthis._rotation = value;\r\n\t\tthis._rotation._quaternion = this._quaternion;\r\n\t\tthis._quaternion._euler = this._rotation;\r\n\t\tthis._rotation._updateQuaternion();\r\n\t\t\r\n\t},\r\n\r\n\tget quaternion () { \r\n\t\treturn this._quaternion; \r\n\t},\r\n\t\r\n\tset quaternion ( value ) {\r\n\t\t\r\n\t\tthis._quaternion = value;\r\n\t\tthis._quaternion._euler = this._rotation;\r\n\t\tthis._rotation._quaternion = this._quaternion;\r\n\t\tthis._quaternion._updateEuler();\r\n\t\t\r\n\t},\r\n\r\n\tget eulerOrder () {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\r\n\r\n\t\treturn this.rotation.order;\r\n\r\n\t},\r\n\r\n\tset eulerOrder ( value ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\r\n\r\n\t\tthis.rotation.order = value;\r\n\r\n\t},\r\n\r\n\tget useQuaternion () {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n\t},\r\n\r\n\tset useQuaternion ( value ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function() {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis );\r\n\r\n\t\t\tv1.applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( distance, axis ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Object3D\\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );\r\n\t\treturn this.translateOnAxis( axis, distance );\r\n\r\n\t},\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tTHREE.onwarning( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== undefined ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t\t// add to scene\r\n\r\n\t\t\tvar scene = this;\r\n\r\n\t\t\twhile ( scene.parent !== undefined ) {\r\n\r\n\t\t\t\tscene = scene.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\r\n\r\n\t\t\t\tscene.__addObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = undefined;\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t\t// remove from scene\r\n\r\n\t\t\tvar scene = this;\r\n\r\n\t\t\twhile ( scene.parent !== undefined ) {\r\n\r\n\t\t\t\tscene = scene.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\r\n\r\n\t\t\t\tscene.__removeObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id, recursive ) {\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\r\n\t\t\tif ( child.id === id ) {\r\n\r\n\t\t\t\treturn child;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tchild = child.getObjectById( id, recursive );\r\n\r\n\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\treturn child;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name, recursive ) {\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\r\n\t\t\tif ( child.name === name ) {\r\n\r\n\t\t\t\treturn child;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tchild = child.getObjectByName( name, recursive );\r\n\r\n\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\treturn child;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetChildByName: function ( name, recursive ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: Object3D\\'s .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\treturn this.getObjectByName( name, recursive );\r\n\r\n\t},\r\n\r\n\tgetDescendants: function ( array ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\r\n\t\tArray.prototype.push.apply( array, this.children );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].getDescendants( array );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === undefined ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( object, recursive ) {\r\n\r\n\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tobject.name = this.name;\r\n\r\n\t\tobject.up.copy( this.up );\r\n\r\n\t\tobject.position.copy( this.position );\r\n\t\tobject.quaternion.copy( this.quaternion );\r\n\t\tobject.scale.copy( this.scale );\r\n\r\n\t\tobject.renderDepth = this.renderDepth;\r\n\r\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\r\n\t\tobject.matrix.copy( this.matrix );\r\n\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\r\n\t\tobject.visible = this.visible;\r\n\r\n\t\tobject.castShadow = this.castShadow;\r\n\t\tobject.receiveShadow = this.receiveShadow;\r\n\r\n\t\tobject.frustumCulled = this.frustumCulled;\r\n\r\n\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tobject.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author julianwa / https://github.com/julianwa\r\n */\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\r\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\r\n\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\r\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\r\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\r\n\r\n\t_renderData = { objects: [], lights: [], elements: [] },\r\n\r\n\t_vA = new THREE.Vector3(),\r\n\t_vB = new THREE.Vector3(),\r\n\t_vC = new THREE.Vector3(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\t_vector4 = new THREE.Vector4(),\r\n\r\n\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\r\n\t_boundingBox = new THREE.Box3(),\r\n\t_points3 = new Array( 3 ),\r\n\t_points4 = new Array( 4 ),\r\n\r\n\t_viewMatrix = new THREE.Matrix4(),\r\n\t_viewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_modelMatrix,\r\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_normalMatrix = new THREE.Matrix3(),\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\r\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\r\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function () {\r\n\r\n\t\tvar projectionMatrixInverse = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector, camera ) {\r\n\r\n\t\t\tprojectionMatrixInverse.getInverse( camera.projectionMatrix );\r\n\t\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );\r\n\r\n\t\t\treturn vector.applyProjection( _viewProjectionMatrix );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\t// set two vectors with opposing z values\r\n\t\tvector.z = -1.0;\r\n\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\r\n\r\n\t\tthis.unprojectVector( vector, camera );\r\n\t\tthis.unprojectVector( end, camera );\r\n\r\n\t\t// find direction from vector to end\r\n\t\tend.sub( vector ).normalize();\r\n\r\n\t\treturn new THREE.Raycaster( vector, end );\r\n\r\n\t};\r\n\r\n\tvar projectObject = function ( object ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t_renderData.lights.push( object );\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {\r\n\r\n\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t_object.id = object.id;\r\n\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_renderData.objects.push( _object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( object.children[ i ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar projectGraph = function ( root, sortObjects ) {\r\n\r\n\t\t_objectCount = 0;\r\n\r\n\t\t_renderData.objects.length = 0;\r\n\t\t_renderData.lights.length = 0;\r\n\r\n\t\tprojectObject( root );\r\n\r\n\t\tif ( sortObjects === true ) {\r\n\r\n\t\t\t_renderData.objects.sort( painterSort );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar RenderList = function () {\r\n\r\n\t\tvar normals = [];\r\n\r\n\t\tvar object = null;\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\t\tvar setObject = function ( value ) {\r\n\r\n\t\t\tobject = value;\r\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\r\n\r\n\t\t\tnormals.length = 0;\r\n\r\n\t\t};\r\n\r\n\t\tvar projectVertex = function ( vertex ) {\r\n\r\n\t\t\tvar position = vertex.position;\r\n\t\t\tvar positionWorld = vertex.positionWorld;\r\n\t\t\tvar positionScreen = vertex.positionScreen;\r\n\r\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\r\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\tvar invW = 1 / positionScreen.w;\r\n\r\n\t\t\tpositionScreen.x *= invW;\r\n\t\t\tpositionScreen.y *= invW;\r\n\t\t\tpositionScreen.z *= invW;\r\n\r\n\t\t\tvertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&\r\n\t\t\t\t\t positionScreen.y >= -1 && positionScreen.y <= 1 &&\r\n\t\t\t\t\t positionScreen.z >= -1 && positionScreen.z <= 1;\r\n\r\n\t\t};\r\n\r\n\t\tvar pushVertex = function ( x, y, z ) {\r\n\r\n\t\t\t_vertex = getNextVertexInPool();\r\n\t\t\t_vertex.position.set( x, y, z );\r\n\r\n\t\t\tprojectVertex( _vertex );\r\n\r\n\t\t};\r\n\r\n\t\tvar pushNormal = function ( x, y, z ) {\r\n\r\n\t\t\tnormals.push( x, y, z );\r\n\r\n\t\t};\r\n\r\n\t\tvar checkTriangleVisibility = function ( v1, v2, v3 ) {\r\n\r\n\t\t\t_points3[ 0 ] = v1.positionScreen;\r\n\t\t\t_points3[ 1 ] = v2.positionScreen;\r\n\t\t\t_points3[ 2 ] = v3.positionScreen;\r\n\r\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\r\n\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\r\n\r\n\t\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\r\n\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\r\n\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t};\r\n\r\n\t\tvar pushLine = function ( a, b ) {\r\n\r\n\t\t\tvar v1 = _vertexPool[ a ];\r\n\t\t\tvar v2 = _vertexPool[ b ];\r\n\r\n\t\t\t_line = getNextLineInPool();\r\n\r\n\t\t\t_line.id = object.id;\r\n\t\t\t_line.v1.copy( v1 );\r\n\t\t\t_line.v2.copy( v2 );\r\n\t\t\t_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;\r\n\r\n\t\t\t_line.material = object.material;\r\n\r\n\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t};\r\n\r\n\t\tvar pushTriangle = function ( a, b, c ) {\r\n\r\n\t\t\tvar v1 = _vertexPool[ a ];\r\n\t\t\tvar v2 = _vertexPool[ b ];\r\n\t\t\tvar v3 = _vertexPool[ c ];\r\n\r\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === true ) {\r\n\r\n\t\t\t\t_face = getNextFaceInPool();\r\n\r\n\t\t\t\t_face.id = object.id;\r\n\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t_face.v3.copy( v3 );\r\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\r\n\r\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tvar offset = arguments[ i ] * 3;\r\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\r\n\r\n\t\t\t\t\tnormal.set( normals[ offset + 0 ], normals[ offset + 1 ], normals[ offset + 2 ] );\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_face.vertexNormalsLength = 3;\r\n\r\n\t\t\t\t_face.material = object.material;\r\n\r\n\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tsetObject: setObject,\r\n\t\t\tprojectVertex: projectVertex,\r\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\r\n\t\t\tpushVertex: pushVertex,\r\n\t\t\tpushNormal: pushNormal,\r\n\t\t\tpushLine: pushLine,\r\n\t\t\tpushTriangle: pushTriangle\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar renderList = new RenderList();\r\n\r\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\r\n\r\n\t\tvar object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\r\n\t\tisFaceMaterial, objectMaterials;\r\n\r\n\t\t_faceCount = 0;\r\n\t\t_lineCount = 0;\r\n\t\t_spriteCount = 0;\r\n\r\n\t\t_renderData.elements.length = 0;\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\r\n\r\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\r\n\r\n\t\tprojectGraph( scene, sortObjects );\r\n\r\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tobject = _renderData.objects[ o ].object;\r\n\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\trenderList.setObject( object );\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\t_vertexCount = 0;\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\t\tif ( attributes.position === undefined ) continue;\r\n\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar indices = attributes.index.array;\r\n\r\n\t\t\t\t\t\tif ( offsets.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var o = 0; o < offsets.length; o ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar offset = offsets[ o ];\r\n\t\t\t\t\t\t\t\tvar index = offset.index;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tvertices = geometry.vertices;\r\n\t\t\t\t\tfaces = geometry.faces;\r\n\t\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\r\n\r\n\t\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertex = vertices[ v ];\r\n\t\t\t\t\t\trenderList.pushVertex( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\tface = faces[ f ];\r\n\r\n\t\t\t\t\t\tvar material = isFaceMaterial === true\r\n\t\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\r\n\t\t\t\t\t\t\t: object.material;\r\n\r\n\t\t\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\t\t\tvar side = material.side;\r\n\r\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\r\n\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\t\tvar v1p = v1.position;\r\n\t\t\t\t\t\t\tvar v2p = v2.position;\r\n\t\t\t\t\t\t\tvar v3p = v3.position;\r\n\r\n\t\t\t\t\t\t\t_vA.set( 0, 0, 0 );\r\n\t\t\t\t\t\t\t_vB.set( 0, 0, 0 );\r\n\t\t\t\t\t\t\t_vC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\t\t\t_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;\r\n\t\t\t\t\t\t\t\t_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;\r\n\t\t\t\t\t\t\t\t_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;\r\n\r\n\t\t\t\t\t\t\t\t_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;\r\n\t\t\t\t\t\t\t\t_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;\r\n\t\t\t\t\t\t\t\t_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;\r\n\r\n\t\t\t\t\t\t\t\t_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;\r\n\t\t\t\t\t\t\t\t_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;\r\n\t\t\t\t\t\t\t\t_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tv1.position.add( _vA );\r\n\t\t\t\t\t\t\tv2.position.add( _vB );\r\n\t\t\t\t\t\t\tv3.position.add( _vC );\r\n\r\n\t\t\t\t\t\t\trenderList.projectVertex( v1 );\r\n\t\t\t\t\t\t\trenderList.projectVertex( v2 );\r\n\t\t\t\t\t\t\trenderList.projectVertex( v3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar visible = renderList.checkTriangleVisibility( v1, v2, v3 );\r\n\r\n\t\t\t\t\t\tif ( ( visible === false && side === THREE.FrontSide ) ||\r\n\t\t\t\t\t\t\t ( visible === true && side === THREE.BackSide ) ) continue;\r\n\r\n\t\t\t\t\t\t_face = getNextFaceInPool();\r\n\r\n\t\t\t\t\t\t_face.id = object.id;\r\n\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\r\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\r\n\r\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\t_face.normalModel.negate();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\r\n\r\n\t\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\r\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\r\n\r\n\t\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\tnormalModel.negate();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\r\n\r\n\t\t\t\t\t\tfor ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\r\n\r\n\t\t\t\t\t\t\tif ( uvs === undefined ) continue;\r\n\r\n\t\t\t\t\t\t\tfor ( var u = 0, ul = uvs.length; u < ul; u ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.color = face.color;\r\n\t\t\t\t\t\t_face.material = material;\r\n\r\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\r\n\r\n\t\t\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\t\t\tif ( attributes.position !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tvar indices = attributes.index.array;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\r\n\r\n\t\t\t\t\tvertices = object.geometry.vertices;\r\n\r\n\t\t\t\t\tif ( vertices.length === 0 ) continue;\r\n\r\n\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\t// Handle LineStrip and LinePieces\r\n\t\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\r\n\r\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\r\n\r\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\r\n\r\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\r\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\r\n\r\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\r\n\r\n\t\t\t\t\t\t\t// Perform the perspective divide\r\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\r\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\r\n\r\n\t\t\t\t\t\t\t_line = getNextLineInPool();\r\n\r\n\t\t\t\t\t\t\t_line.id = object.id;\r\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\r\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\r\n\r\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\r\n\r\n\t\t\t\t\t\t\t_line.material = object.material;\r\n\r\n\t\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\r\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\r\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\tvar invW = 1 / _vector4.w;\r\n\r\n\t\t\t\t_vector4.z *= invW;\r\n\r\n\t\t\t\tif ( _vector4.z >= -1 && _vector4.z <= 1 ) {\r\n\r\n\t\t\t\t\t_sprite = getNextSpriteInPool();\r\n\t\t\t\t\t_sprite.id = object.id;\r\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\r\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\r\n\t\t\t\t\t_sprite.z = _vector4.z;\r\n\t\t\t\t\t_sprite.object = object;\r\n\r\n\t\t\t\t\t_sprite.rotation = object.rotation;\r\n\r\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\r\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\r\n\r\n\t\t\t\t\t_sprite.material = object.material;\r\n\r\n\t\t\t\t\t_renderData.elements.push( _sprite );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\t// Pools\r\n\r\n\tfunction getNextObjectInPool() {\r\n\r\n\t\tif ( _objectCount === _objectPoolLength ) {\r\n\r\n\t\t\tvar object = new THREE.RenderableObject();\r\n\t\t\t_objectPool.push( object );\r\n\t\t\t_objectPoolLength ++;\r\n\t\t\t_objectCount ++;\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t\treturn _objectPool[ _objectCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextVertexInPool() {\r\n\r\n\t\tif ( _vertexCount === _vertexPoolLength ) {\r\n\r\n\t\t\tvar vertex = new THREE.RenderableVertex();\r\n\t\t\t_vertexPool.push( vertex );\r\n\t\t\t_vertexPoolLength ++;\r\n\t\t\t_vertexCount ++;\r\n\t\t\treturn vertex;\r\n\r\n\t\t}\r\n\r\n\t\treturn _vertexPool[ _vertexCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextFaceInPool() {\r\n\r\n\t\tif ( _faceCount === _facePoolLength ) {\r\n\r\n\t\t\tvar face = new THREE.RenderableFace();\r\n\t\t\t_facePool.push( face );\r\n\t\t\t_facePoolLength ++;\r\n\t\t\t_faceCount ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _facePool[ _faceCount ++ ];\r\n\r\n\r\n\t}\r\n\r\n\tfunction getNextLineInPool() {\r\n\r\n\t\tif ( _lineCount === _linePoolLength ) {\r\n\r\n\t\t\tvar line = new THREE.RenderableLine();\r\n\t\t\t_linePool.push( line );\r\n\t\t\t_linePoolLength ++;\r\n\t\t\t_lineCount ++\r\n\t\t\treturn line;\r\n\r\n\t\t}\r\n\r\n\t\treturn _linePool[ _lineCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextSpriteInPool() {\r\n\r\n\t\tif ( _spriteCount === _spritePoolLength ) {\r\n\r\n\t\t\tvar sprite = new THREE.RenderableSprite();\r\n\t\t\t_spritePool.push( sprite );\r\n\t\t\t_spritePoolLength ++;\r\n\t\t\t_spriteCount ++\r\n\t\t\treturn sprite;\r\n\r\n\t\t}\r\n\r\n\t\treturn _spritePool[ _spriteCount ++ ];\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction painterSort( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else if ( a.id !== b.id ) {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction clipLine( s1, s2 ) {\r\n\r\n\t\tvar alpha1 = 0, alpha2 = 1,\r\n\r\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\r\n\t\t// Z = -1 and Z = +1, respectively.\r\n\t\tbc1near =  s1.z + s1.w,\r\n\t\tbc2near =  s2.z + s2.w,\r\n\t\tbc1far =  - s1.z + s1.w,\r\n\t\tbc2far =  - s2.z + s2.w;\r\n\r\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\r\n\r\n\t\t\t// Both vertices lie entirely within all clip planes.\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\r\n\r\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// The line segment spans at least one clip plane.\r\n\r\n\t\t\tif ( bc1near < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the near plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t} else if ( bc2near < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the near plane, v1 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bc1far < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the far plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t} else if ( bc2far < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the far plane, v2 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( alpha2 < alpha1 ) {\r\n\r\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\r\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\r\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\r\n\t\t\t\ts1.lerp( s2, alpha1 );\r\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n\tthis.centroid = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\t\tface.centroid.copy( this.centroid );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tvar i, il;\r\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tTHREE.onwarning( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')\r\n\r\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tthis.id = THREE.GeometryIdCount ++;\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\tthis.className = \"BufferGeometry\";\r\n\tthis.name = '';\r\n\r\n\t// attributes\r\n\r\n\tthis.attributes = {};\r\n\r\n\t// offsets for chunks when using indexed elements\r\n\r\n\tthis.offsets = [];\r\n\r\n\t// boundings\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometry,\r\n\r\n\taddAttribute: function ( name, type, numItems, itemSize ) {\r\n\r\n\t\tthis.attributes[ name ] = {\r\n\r\n\t\t\tarray: new type( numItems * itemSize ),\r\n\t\t\titemSize: itemSize\r\n\r\n\t\t};\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.multiplyVector3Array( position.array );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.multiplyVector3Array( normal.array );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\r\n\t\tif ( positions ) {\r\n\r\n\t\t\tvar bb = this.boundingBox;\r\n\r\n\t\t\tif( positions.length >= 3 ) {\r\n\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\r\n\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\r\n\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tvar x = positions[ i ];\r\n\t\t\t\tvar y = positions[ i + 1 ];\r\n\t\t\t\tvar z = positions[ i + 2 ];\r\n\r\n\t\t\t\t// bounding box\r\n\r\n\t\t\t\tif ( x < bb.min.x ) {\r\n\r\n\t\t\t\t\tbb.min.x = x;\r\n\r\n\t\t\t\t} else if ( x > bb.max.x ) {\r\n\r\n\t\t\t\t\tbb.max.x = x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( y < bb.min.y ) {\r\n\r\n\t\t\t\t\tbb.min.y = y;\r\n\r\n\t\t\t\t} else if ( y > bb.max.y ) {\r\n\r\n\t\t\t\t\tbb.max.y = y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( z < bb.min.z ) {\r\n\r\n\t\t\t\t\tbb.min.z = z;\r\n\r\n\t\t\t\t} else if ( z > bb.max.z ) {\r\n\r\n\t\t\t\t\tbb.max.z = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\r\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tbox.makeEmpty();\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tbox.addPoint( vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbox.center( center );\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tif ( this.attributes[ \"position\" ] ) {\r\n\r\n\t\t\tvar i, il;\r\n\t\t\tvar j, jl;\r\n\r\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\r\n\r\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\r\n\r\n\t\t\t\tthis.attributes[ \"normal\" ] = {\r\n\r\n\t\t\t\t\titemSize: 3,\r\n\t\t\t\t\tarray: new Float32Array( nVertexElements )\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\r\n\t\t\tvar vA, vB, vC, x, y, z,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( this.attributes[ \"index\" ] ) {\r\n\r\n\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\r\n\r\n\t\t\t\tvar offsets = this.offsets;\r\n\r\n\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = index + indices[ i ];\r\n\t\t\t\t\t\tvB = index + indices[ i + 1 ];\r\n\t\t\t\t\t\tvC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\tx = positions[ vA * 3 ];\r\n\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\r\n\t\t\t\t\t\tpA.set( x, y, z );\r\n\r\n\t\t\t\t\t\tx = positions[ vB * 3 ];\r\n\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\r\n\t\t\t\t\t\tpB.set( x, y, z );\r\n\r\n\t\t\t\t\t\tx = positions[ vC * 3 ];\r\n\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\r\n\t\t\t\t\t\tpC.set( x, y, z );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA * 3     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB * 3     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC * 3     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tx = positions[ i ];\r\n\t\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\t\tz = positions[ i + 2 ];\r\n\t\t\t\t\tpA.set( x, y, z );\r\n\r\n\t\t\t\t\tx = positions[ i + 3 ];\r\n\t\t\t\t\ty = positions[ i + 4 ];\r\n\t\t\t\t\tz = positions[ i + 5 ];\r\n\t\t\t\t\tpB.set( x, y, z );\r\n\r\n\t\t\t\t\tx = positions[ i + 6 ];\r\n\t\t\t\t\ty = positions[ i + 7 ];\r\n\t\t\t\t\tz = positions[ i + 8 ];\r\n\t\t\t\t\tpC.set( x, y, z );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i     ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i     ] *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\r\n\t\t\t this.attributes[ \"position\" ] === undefined ||\r\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\r\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\r\n\r\n\t\t\tTHREE.onwarning( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = this.attributes[ \"index\" ].array;\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\r\n\r\n\t\tvar nVertices = positions.length / 3;\r\n\r\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\r\n\r\n\t\t\tvar nTangentElements = 4 * nVertices;\r\n\r\n\t\t\tthis.attributes[ \"tangent\" ] = {\r\n\r\n\t\t\t\titemSize: 4,\r\n\t\t\t\tarray: new Float32Array( nTangentElements )\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\r\n\r\n\t\tvar tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\r\n\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar xA, yA, zA,\r\n\t\t\txB, yB, zB,\r\n\t\t\txC, yC, zC,\r\n\r\n\t\t\tuA, vA,\r\n\t\t\tuB, vB,\r\n\t\t\tuC, vC,\r\n\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r;\r\n\r\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\txA = positions[ a * 3 ];\r\n\t\t\tyA = positions[ a * 3 + 1 ];\r\n\t\t\tzA = positions[ a * 3 + 2 ];\r\n\r\n\t\t\txB = positions[ b * 3 ];\r\n\t\t\tyB = positions[ b * 3 + 1 ];\r\n\t\t\tzB = positions[ b * 3 + 2 ];\r\n\r\n\t\t\txC = positions[ c * 3 ];\r\n\t\t\tyC = positions[ c * 3 + 1 ];\r\n\t\t\tzC = positions[ c * 3 + 2 ];\r\n\r\n\t\t\tuA = uvs[ a * 2 ];\r\n\t\t\tvA = uvs[ a * 2 + 1 ];\r\n\r\n\t\t\tuB = uvs[ b * 2 ];\r\n\t\t\tvB = uvs[ b * 2 + 1 ];\r\n\r\n\t\t\tuC = uvs[ c * 2 ];\r\n\t\t\tvC = uvs[ c * 2 + 1 ];\r\n\r\n\t\t\tx1 = xB - xA;\r\n\t\t\tx2 = xC - xA;\r\n\r\n\t\t\ty1 = yB - yA;\r\n\t\t\ty2 = yC - yA;\r\n\r\n\t\t\tz1 = zB - zA;\r\n\t\t\tz2 = zC - zA;\r\n\r\n\t\t\ts1 = uB - uA;\r\n\t\t\ts2 = uC - uA;\r\n\r\n\t\t\tt1 = vB - vA;\r\n\t\t\tt2 = vC - vA;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n\t\t\tsdir.set(\r\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttdir.set(\r\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il;\r\n\t\tvar j, jl;\r\n\t\tvar iA, iB, iC;\r\n\r\n\t\tvar offsets = this.offsets;\r\n\r\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = offsets[ j ].start;\r\n\t\t\tvar count = offsets[ j ].count;\r\n\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleTriangle( iA, iB, iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\tvar w, t, test;\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.x = normals[ v * 3 ];\r\n\t\t\tn.y = normals[ v * 3 + 1 ];\r\n\t\t\tn.z = normals[ v * 3 + 2 ];\r\n\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tt = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4     ] = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = offsets[ j ].start;\r\n\t\t\tvar count = offsets[ j ].count;\r\n\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleVertex( iA );\r\n\t\t\t\thandleVertex( iB );\r\n\t\t\t\thandleVertex( iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t/*\r\n\t\tcomputeOffsets\r\n\t\tCompute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.\r\n\t\tThis method will effectively rewrite the index buffer and remap all attributes to match the new indices.\r\n\t\tWARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.\r\n\t\tindexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.\r\n\t*/\r\n\tcomputeOffsets: function(indexBufferSize) {\r\n\r\n\t\tvar size = indexBufferSize;\r\n\t\tif(indexBufferSize === undefined)\r\n\t\t\tsize = 65535; //WebGL limits type of index buffer values to 16-bit.\r\n\r\n\t\tvar s = Date.now();\r\n\r\n\t\tvar indices = this.attributes['index'].array;\r\n\t\tvar vertices = this.attributes['position'].array;\r\n\r\n\t\tvar verticesCount = (vertices.length/3);\r\n\t\tvar facesCount = (indices.length/3);\r\n\r\n\t\t/*\r\n\t\tconsole.log(\"Computing buffers in offsets of \"+size+\" -> indices:\"+indices.length+\" vertices:\"+vertices.length);\r\n\t\tconsole.log(\"Faces to process: \"+(indices.length/3));\r\n\t\tconsole.log(\"Reordering \"+verticesCount+\" vertices.\");\r\n\t\t*/\r\n\r\n\t\tvar sortedIndices = new Uint16Array( indices.length ); //16-bit buffers\r\n\t\tvar indexPtr = 0;\r\n\t\tvar vertexPtr = 0;\r\n\r\n\t\tvar offsets = [ { start:0, count:0, index:0 } ];\r\n\t\tvar offset = offsets[0];\r\n\r\n\t\tvar duplicatedVertices = 0;\r\n\t\tvar newVerticeMaps = 0;\r\n\t\tvar faceVertices = new Int32Array(6);\r\n\t\tvar vertexMap = new Int32Array( vertices.length );\r\n\t\tvar revVertexMap = new Int32Array( vertices.length );\r\n\t\tfor(var j = 0; j < vertices.length; j++) { vertexMap[j] = -1; revVertexMap[j] = -1; }\r\n\r\n\t\t/*\r\n\t\t\tTraverse every face and reorder vertices in the proper offsets of 65k.\r\n\t\t\tWe can have more than 65k entries in the index buffer per offset, but only reference 65k values.\r\n\t\t*/\r\n\t\tfor(var findex = 0; findex < facesCount; findex++) {\r\n\t\t\tnewVerticeMaps = 0;\r\n\r\n\t\t\tfor(var vo = 0; vo < 3; vo++) {\r\n\t\t\t\tvar vid = indices[ findex*3 + vo ];\r\n\t\t\t\tif(vertexMap[vid] == -1) {\r\n\t\t\t\t\t//Unmapped vertice\r\n\t\t\t\t\tfaceVertices[vo*2] = vid;\r\n\t\t\t\t\tfaceVertices[vo*2+1] = -1;\r\n\t\t\t\t\tnewVerticeMaps++;\r\n\t\t\t\t} else if(vertexMap[vid] < offset.index) {\r\n\t\t\t\t\t//Reused vertices from previous block (duplicate)\r\n\t\t\t\t\tfaceVertices[vo*2] = vid;\r\n\t\t\t\t\tfaceVertices[vo*2+1] = -1;\r\n\t\t\t\t\tduplicatedVertices++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//Reused vertice in the current block\r\n\t\t\t\t\tfaceVertices[vo*2] = vid;\r\n\t\t\t\t\tfaceVertices[vo*2+1] = vertexMap[vid];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar faceMax = vertexPtr + newVerticeMaps;\r\n\t\t\tif(faceMax > (offset.index + size)) {\r\n\t\t\t\tvar new_offset = { start:indexPtr, count:0, index:vertexPtr };\r\n\t\t\t\toffsets.push(new_offset);\r\n\t\t\t\toffset = new_offset;\r\n\r\n\t\t\t\t//Re-evaluate reused vertices in light of new offset.\r\n\t\t\t\tfor(var v = 0; v < 6; v+=2) {\r\n\t\t\t\t\tvar new_vid = faceVertices[v+1];\r\n\t\t\t\t\tif(new_vid > -1 && new_vid < offset.index)\r\n\t\t\t\t\t\tfaceVertices[v+1] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Reindex the face.\r\n\t\t\tfor(var v = 0; v < 6; v+=2) {\r\n\t\t\t\tvar vid = faceVertices[v];\r\n\t\t\t\tvar new_vid = faceVertices[v+1];\r\n\r\n\t\t\t\tif(new_vid === -1)\r\n\t\t\t\t\tnew_vid = vertexPtr++;\r\n\r\n\t\t\t\tvertexMap[vid] = new_vid;\r\n\t\t\t\trevVertexMap[new_vid] = vid;\r\n\t\t\t\tsortedIndices[indexPtr++] = new_vid - offset.index; //XXX overflows at 16bit\r\n\t\t\t\toffset.count++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */\r\n\t\tthis.reorderBuffers(sortedIndices, revVertexMap, vertexPtr);\r\n\t\tthis.offsets = offsets;\r\n\r\n\t\t/*\r\n\t\tvar orderTime = Date.now();\r\n\t\tconsole.log(\"Reorder time: \"+(orderTime-s)+\"ms\");\r\n\t\tconsole.log(\"Duplicated \"+duplicatedVertices+\" vertices.\");\r\n\t\tconsole.log(\"Compute Buffers time: \"+(Date.now()-s)+\"ms\");\r\n\t\tconsole.log(\"Draw offsets: \"+offsets.length);\r\n\t\t*/\r\n\r\n\t\treturn offsets;\r\n\t},\r\n\r\n\t/*\r\n\t\treoderBuffers:\r\n\t\tReorder attributes based on a new indexBuffer and indexMap.\r\n\t\tindexBuffer - Uint16Array of the new ordered indices.\r\n\t\tindexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.\r\n\t\tvertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).\r\n\t*/\r\n\treorderBuffers: function(indexBuffer, indexMap, vertexCount) {\r\n\r\n\t\t/* Create a copy of all attributes for reordering. */\r\n\t\tvar sortedAttributes = {};\r\n\t\tvar types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\r\n\t\tfor( var attr in this.attributes ) {\r\n\t\t\tif(attr == 'index')\r\n\t\t\t\tcontinue;\r\n\t\t\tvar sourceArray = this.attributes[attr].array;\r\n\t\t\tfor ( var i = 0, il = types.length; i < il; i++ ) {\r\n\t\t\t\tvar type = types[i];\r\n\t\t\t\tif (sourceArray instanceof type) {\r\n\t\t\t\t\tsortedAttributes[attr] = new type( this.attributes[attr].itemSize * vertexCount );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Move attribute positions based on the new index map */\r\n\t\tfor(var new_vid = 0; new_vid < vertexCount; new_vid++) {\r\n\t\t\tvar vid = indexMap[new_vid];\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif(attr == 'index')\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar attrArray = this.attributes[attr].array;\r\n\t\t\t\tvar attrSize = this.attributes[attr].itemSize;\r\n\t\t\t\tvar sortedAttr = sortedAttributes[attr];\r\n\t\t\t\tfor(var k = 0; k < attrSize; k++)\r\n\t\t\t\t\tsortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Carry the new sorted buffers locally */\r\n\t\tthis.attributes['index'].array = indexBuffer;\r\n\t\tfor ( var attr in this.attributes ) {\r\n\t\t\tif(attr == 'index')\r\n\t\t\t\tcontinue;\r\n\t\t\tthis.attributes[attr].array = sortedAttributes[attr];\r\n\t\t\tthis.attributes[attr].numItems = this.attributes[attr].itemSize * vertexCount;\r\n\t\t}\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\r\n\r\n\t\tfor ( var attr in this.attributes ) {\r\n\r\n\t\t\tvar sourceAttr = this.attributes[ attr ];\r\n\t\t\tvar sourceArray = sourceAttr.array;\r\n\r\n\t\t\tvar attribute = {\r\n\r\n\t\t\t\titemSize: sourceAttr.itemSize,\r\n\t\t\t\tarray: null\r\n\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, il = types.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar type = types[ i ];\r\n\r\n\t\t\t\tif ( sourceArray instanceof type ) {\r\n\r\n\t\t\t\t\tattribute.array = new type( sourceArray );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.attributes[ attr ] = attribute;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar offset = this.offsets[ i ];\r\n\r\n\t\t\tgeometry.offsets.push( {\r\n\r\n\t\t\t\tstart: offset.start,\r\n\t\t\t\tindex: offset.index,\r\n\t\t\t\tcount: offset.count\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tthis.id = THREE.GeometryIdCount ++;\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\tthis.className = \"Geometry\";\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line\r\n\r\n\tthis.faces = [];\r\n\r\n\tthis.faceVertexUvs = [[]];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphColors = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = true;\r\n\r\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.tangentsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\r\n\tthis.buffersNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tface.centroid.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox instanceof THREE.Box3 ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere instanceof THREE.Sphere ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeCentroids: function () {\r\n\r\n\t\tvar f, fl, face;\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tface.centroid.set( 0, 0, 0 );\r\n\r\n\t\t\tface.centroid.add( this.vertices[ face.a ] );\r\n\t\t\tface.centroid.add( this.vertices[ face.b ] );\r\n\t\t\tface.centroid.add( this.vertices[ face.c ] );\r\n\t\t\tface.centroid.divideScalar( 3 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC, vD;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\r\n\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// tangents go to vertices\r\n\r\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\r\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\ttan1 = [], tan2 = [],\r\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\tn = new THREE.Vector3(), w;\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\r\n\t\t\tvA = context.vertices[ a ];\r\n\t\t\tvB = context.vertices[ b ];\r\n\t\t\tvC = context.vertices[ c ];\r\n\r\n\t\t\tuvA = uv[ ua ];\r\n\t\t\tuvB = uv[ ub ];\r\n\t\t\tuvC = uv[ uc ];\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\r\n\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\r\n\t\t}\r\n\r\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {\r\n\r\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\r\n\t\t\t\tt = tan1[ vertexIndex ];\r\n\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t\t// Calculate handedness\r\n\r\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\r\n\r\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function ( ) {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i,il, face;\r\n\t\tvar indices, k, j, jl, u;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\tvar dupIndex = -1;\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\t// Geometry splitting\r\n\r\n\tmakeGroups: ( function () {\r\n\r\n\t\tvar geometryGroupCounter = 0;\r\n\t\t\r\n\t\treturn function ( usesFaceMaterial ) {\r\n\r\n\t\t\tvar f, fl, face, materialIndex,\r\n\t\t\t\tgroupHash, hash_map = {};\r\n\r\n\t\t\tvar numMorphTargets = this.morphTargets.length;\r\n\t\t\tvar numMorphNormals = this.morphNormals.length;\r\n\r\n\t\t\tthis.geometryGroups = {};\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\r\n\t\t\t\tif ( ! ( materialIndex in hash_map ) ) {\r\n\r\n\t\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\t\tif ( ! ( groupHash in this.geometryGroups ) ) {\r\n\r\n\t\t\t\t\tthis.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( this.geometryGroups[ groupHash ].vertices + 3 > 65535 ) {\r\n\r\n\t\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\t\t\tif ( ! ( groupHash in this.geometryGroups ) ) {\r\n\r\n\t\t\t\t\t\tthis.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.geometryGroups[ groupHash ].faces3.push( f );\r\n\t\t\t\tthis.geometryGroups[ groupHash ].vertices += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.geometryGroupsList = [];\r\n\r\n\t\t\tfor ( var g in this.geometryGroups ) {\r\n\r\n\t\t\t\tthis.geometryGroups[ g ].id = geometryGroupCounter ++;\r\n\r\n\t\t\t\tthis.geometryGroupsList.push( this.geometryGroups[ g ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\t\t\r\n\t} )(),\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = this.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.morphTargets = this.morphTargets.slice( 0 );\r\n\t\tgeometry.morphColors = this.morphColors.slice( 0 );\r\n\t\tgeometry.morphNormals = this.morphNormals.slice( 0 );\r\n\t\tgeometry.skinWeights = this.skinWeights.slice( 0 );\r\n\t\tgeometry.skinIndices = this.skinIndices.slice( 0 );\r\n\t\tgeometry.lineDistances = this.lineDistances.slice( 0 );\r\n\r\n\t\tif( this.boundingBox )\tgeometry.boundingBox = this.boundingBox.clone();\r\n\t\tif( this.boundingSphere ) geometry.boundingSphere = this.boundingSphere.clone();\r\n\r\n\t\tgeometry.hasTangents = this.hasTangents;\r\n\r\n\t\tgeometry.dynamic = this.dynamic; // the intermediate typed arrays will be deleted when set to false\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Geometry2 = function ( size ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\tthis.className = \"Geometry2\";\r\n\r\n\tthis.vertices = this.addAttribute( 'position', Float32Array, size, 3 ).array;\r\n\tthis.normals = this.addAttribute( 'normal', Float32Array, size, 3 ).array;\r\n\tthis.uvs = this.addAttribute( 'uv', Float32Array, size, 2 ).array;\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n};\r\n\r\nTHREE.Geometry2.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\r\n\tthis.normalizedViewport = { x: 0, y: 0, width: 1.0, height: 1.0 };\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n\tvar m1 = new THREE.Matrix4();\r\n\r\n\treturn function ( vector ) {\r\n\r\n\t\tm1.lookAt( this.position, vector, this.up );\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function (camera) {\r\n\r\n\tif ( camera === undefined ) camera = new THREE.Camera();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, camera );\r\n\r\n\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\tcamera.normalizedViewport = {\r\n\t\tx: this.normalizedViewport.x,\r\n\t\ty: this.normalizedViewport.y,\r\n\t\twidth: this.normalizedViewport.width,\r\n\t\theight: this.normalizedViewport.height\r\n\t};\r\n\r\n\treturn camera;\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\r\n\r\n\r\n\r\n  \tvar viewportMatrix = new THREE.Matrix4();\r\n  \tviewportMatrix.elements[0] *= this.normalizedViewport.width;\r\n  \tviewportMatrix.elements[1] *= this.normalizedViewport.height;\r\n  \tviewportMatrix.elements[12] += this.normalizedViewport.x;\r\n  \tviewportMatrix.elements[13] += this.normalizedViewport.y;\r\n \tthis.projectionMatrix = viewportMatrix.multiply( this.projectionMatrix );\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.clone = function () {\r\n\r\n\tvar camera = new THREE.OrthographicCamera();\r\n\r\n\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\r\n\tcamera.left = this.left;\r\n\tcamera.right = this.right;\r\n\tcamera.top = this.top;\r\n\tcamera.bottom = this.bottom;\r\n\t\r\n\tcamera.near = this.near;\r\n\tcamera.far = this.far;\r\n\r\n\treturn camera;\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far, filmSize, filmOffset ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\tthis.filmSize = filmSize !== undefined ? filmSize : new THREE.Vector2( 1, 1 );\r\n\tthis.filmOffset = filmOffset !== undefined ? filmOffset : new THREE.Vector2( 0, 0 );\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (fullframe) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.fullWidth = fullWidth;\r\n\tthis.fullHeight = fullHeight;\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tif ( this.fullWidth ) {\r\n\r\n\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\r\n\t\tvar bottom = - top;\r\n\t\tvar left = aspect * bottom;\r\n\t\tvar right = aspect * top;\r\n\t\tvar width = Math.abs( right - left );\r\n\t\tvar height = Math.abs( top - bottom );\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\tthis.near,\r\n\t\t\tthis.far,\r\n\t\t\tthis.filmOffset,\r\n\t\t\tthis.filmSize\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far, this.filmOffset, this.filmSize );\r\n\r\n\t}\r\n\r\n  \tvar viewportMatrix = new THREE.Matrix4();\r\n  \tviewportMatrix.elements[0] *= this.normalizedViewport.width;\r\n  \tviewportMatrix.elements[1] *= this.normalizedViewport.height;\r\n  \tviewportMatrix.elements[12] += this.normalizedViewport.x;\r\n  \tviewportMatrix.elements[13] += this.normalizedViewport.y;\r\n \tthis.projectionMatrix = viewportMatrix.multiply( this.projectionMatrix );\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.clone = function () {\r\n\r\n\tvar camera = new THREE.PerspectiveCamera();\r\n\r\n\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\r\n\tcamera.fov = this.fov;\r\n\tcamera.aspect = this.aspect;\r\n\tcamera.near = this.near;\r\n\tcamera.far = this.far;\r\n\tcamera.filmSize = this.filmSize;\r\n\tcamera.filmOffset = this.filmOffset;\r\n\r\n\treturn camera;\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n \r\nTHREE.Light = function ( color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Light.prototype.clone = function ( light ) {\r\n\r\n\tif ( light === undefined ) light = new THREE.Light();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, light );\r\n\r\n\tlight.color.copy( this.color );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\nTHREE.AmbientLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.AmbientLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author bhouston / http://clara.io/\r\n * @author MPanknin / http://www.redplant.de/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.AreaLight = function ( color, intensity, distance, decayExponent, physicalFalloff ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decayExponent = ( decayExponent !== undefined ) ? decayExponent : 0;\t// for physically correct lights, should be 2.\r\n\tthis.physicalFalloff = ( physicalFalloff !== undefined ) ? physicalFalloff : false;\r\n\r\n\tthis.width = 1.0;\r\n\tthis.height = 1.0;\r\n\r\n\t// TODO: implement shadow maps.  -bhouston, Oct 15, 2014\r\n};\r\n\r\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\nTHREE.AreaLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.AreaLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\t\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.decayExponent = this.decayExponent;\r\n\tlight.physicalFalloff = this.physicalFalloff;\r\n\r\n\tlight.width = this.width;\r\n\tlight.height = this.height;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\r\n\tthis.shadowCameraLeft = -500;\r\n\tthis.shadowCameraRight = 500;\r\n\tthis.shadowCameraTop = 500;\r\n\tthis.shadowCameraBottom = -500;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowCascade = false;\r\n\r\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\r\n\tthis.shadowCascadeCount = 2;\r\n\r\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\r\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\r\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\r\n\r\n\tthis.shadowCascadeArray = [];\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\nTHREE.DirectionalLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.DirectionalLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\r\n\tlight.intensity = this.intensity;\r\n\r\n\tlight.castShadow = this.castShadow;\r\n\tlight.onlyShadow = this.onlyShadow;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColor );\r\n\r\n\tthis.position.set( 0, 100, 0 );\r\n\r\n\tthis.groundColor = new THREE.Color( groundColor );\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\nTHREE.HemisphereLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.HemisphereLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.groundColor.copy( this.groundColor );\r\n\tlight.intensity = this.intensity;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decayExponent, physicalFalloff ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decayExponent = ( decayExponent !== undefined ) ? decayExponent : 0;;\t// for physically correct lights, should be 2.\r\n\tthis.physicalFalloff = ( physicalFalloff !== undefined ) ? physicalFalloff : false;\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\nTHREE.PointLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.PointLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.decayExponent = this.decayExponent;\r\n\tlight.physicalFalloff = this.physicalFalloff;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decayExponent, physicalFalloff ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decayExponent = ( decayExponent !== undefined ) ? decayExponent : 0;;\t// for physically correct lights, should be 2.\r\n\tthis.physicalFalloff = ( physicalFalloff !== undefined ) ? physicalFalloff : false;\r\n\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\tthis.shadowCameraFov = 50;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\nTHREE.SpotLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.SpotLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.angle = this.angle;\r\n\tlight.exponent = this.exponent;\r\n\tlight.decayExponent = this.decayExponent;\r\n\tlight.physicalFalloff = this.physicalFalloff;\r\n\r\n\tlight.castShadow = this.castShadow;\r\n\tlight.onlyShadow = this.onlyShadow;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( \"div\" );\r\n\r\n\t\te.style.position = \"absolute\";\r\n\t\te.style.right = \"0px\";\r\n\t\te.style.top = \"0px\";\r\n\t\te.style.fontSize = \"0.8em\";\r\n\t\te.style.textAlign = \"left\";\r\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\r\n\t\te.style.color = \"#fff\";\r\n\t\te.style.width = \"120px\";\r\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = \"Loading ...\";\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = \"Loaded \";\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\r\n\t\tif ( parts.length === 1 ) return './';\r\n\r\n\t\tparts.pop();\r\n\r\n\t\treturn parts.join( '/' ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tfunction is_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.floor( l ) == l;\r\n\r\n\t\t}\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction load_image( where, url ) {\r\n\r\n\t\t\tvar image = new Image();\r\n\r\n\t\t\timage.onload = function () {\r\n\r\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\r\n\r\n\t\t\t\t\tvar width = nearest_pow2( this.width );\r\n\t\t\t\t\tvar height = nearest_pow2( this.height );\r\n\r\n\t\t\t\t\twhere.image.width = width;\r\n\t\t\t\t\twhere.image.height = height;\r\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\twhere.image = this;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhere.needsUpdate = true;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;\r\n\t\t\timage.src = url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\r\n\r\n\t\t\tvar fullPath = texturePath + sourceFile;\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\r\n\r\n\t\t\t\twhere[ name ] = texture;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar texture = document.createElement( 'canvas' );\r\n\r\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ].sourceFile = sourceFile;\r\n\r\n\t\t\tif( repeat ) {\r\n\r\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\r\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\tload_image( where[ name ], fullPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = \"MeshLambertMaterial\";\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\r\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\r\n\t\t\telse if ( shading === \"physical\" ) mtype = \"MeshPhysicalMaterial\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === \"face\" ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorAmbient ) {\r\n\r\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency ) {\r\n\r\n\t\t\tmpars.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\t// special case for normal mapped material\r\n\r\n\t\tif ( m.mapNormal ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\r\n\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for the moment don't handle displacement texture\r\n\r\n\t\t\tuniforms[ \"diffuse\" ].value.setHex( mpars.color );\r\n\t\t\tuniforms[ \"specular\" ].value.setHex( mpars.specular );\r\n\t\t\tuniforms[ \"ambient\" ].value.setHex( mpars.ambient );\r\n\r\n\t\t\tuniforms[ \"shininess\" ].value = mpars.shininess;\r\n\r\n\t\t\tif ( mpars.opacity !== undefined ) {\r\n\r\n\t\t\t\tuniforms[ \"opacity\" ].value = mpars.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t\tif ( mpars.transparent ) {\r\n\r\n\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n\tconstructor: THREE.XHRLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\t\tonLoad( event.target.responseText );\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onError !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tonError( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n\r\n\t\trequest.open( 'GET', url, true );\r\n\t\trequest.send( null );\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar image = document.createElement( 'img' );\r\n\r\n\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\tonLoad( this );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onError !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tonError( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\tvar scope = this;\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\r\n\t\t\t\t\tif ( json.metadata.type === 'scene' ) {\r\n\r\n\t\t\t\t\t\tTHREE.onerror( 'THREE.JSONLoader: \"' + url + '\" seems to be a Scene. Use THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tTHREE.onerror( 'THREE.JSONLoader: \"' + url + '\" seems to be unreachable or the file is empty.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.onerror( 'THREE.JSONLoader: Couldn\\'t load \"' + url + '\" (' + xhr.status + ')' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tif ( callbackProgress !== undefined ) {\r\n\r\n\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\r\n\tvar scope = this,\r\n\tgeometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeCentroids();\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeBoundingSphere();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, color, hex, normal,\r\n\r\n\t\tuvLayer, uv, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t// disregard empty arrays\r\n\r\n\t\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\r\n\r\n\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\toffset += 4;\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\tvar x = json.skinWeights[ i     ];\r\n\t\t\t\tvar y = json.skinWeights[ i + 1 ];\r\n\t\t\t\tvar z = 0;\r\n\t\t\t\tvar w = 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\tvar a = json.skinIndices[ i     ];\r\n\t\t\t\tvar b = json.skinIndices[ i + 1 ];\r\n\t\t\t\tvar c = 0;\r\n\t\t\t\tvar d = 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\r\n\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\t\tTHREE.onwarning( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// could change this to json.animations[0] or remove completely\r\n\t\t\r\n\t\tgeometry.animation = json.animation;\r\n\t\tgeometry.animations = json.animations;\r\n\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tif ( json.materials === undefined ) {\r\n\r\n\t\treturn { geometry: geometry };\r\n\r\n\t} else {\r\n\r\n\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\t\tif ( this.needsTangents( materials ) ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t}\r\n\r\n\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar loaded = 0, total = 0;\r\n\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\ttotal ++;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\tloaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, loaded, total );\r\n\r\n\t\t}\r\n\r\n\t\tif ( loaded === total && scope.onLoad !== undefined ) {\r\n\r\n\t\t\tscope.onLoad();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar attributes = json.attributes;\r\n\t\tvar offsets = json.offsets;\r\n\t\tvar boundingSphere = json.boundingSphere;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tgeometry.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\tarray: new self[ attribute.type ]( attribute.array )\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( offsets !== undefined ) {\r\n\r\n\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere(\r\n\t\t\t\tnew THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),\r\n\t\t\t\tboundingSphere.radius\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Geometry2Loader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.Geometry2Loader.prototype = {\r\n\r\n\tconstructor: THREE.Geometry2Loader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.Geometry2( json.vertices.length / 3 );\r\n\r\n\t\tvar attributes = [ 'vertices', 'normals', 'uvs' ];\r\n\t\tvar boundingSphere = json.boundingSphere;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tgeometry[ attribute ].set( json[ attribute ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere(\r\n\t\t\t\tnew THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),\r\n\t\t\t\tboundingSphere.radius\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.falloff !== undefined ) material.falloff = json.falloff;\r\n\t\tif ( json.falloffColor !== undefined ) material.falloffColor.setHex( json.falloffColor );\r\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\tif ( json.metallic !== undefined ) material.metallic = json.metallic;\r\n\t\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\r\n\t\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\r\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\r\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\r\n\t\tif ( json.translucency !== undefined ) material.translucency.setHex( json.translucency );\r\n\t\tif ( json.translucencyNormalAlpha !== undefined ) material.translucencyNormalAlpha = json.translucencyNormalAlpha;\r\n\t\tif ( json.translucencyNormalPower !== undefined ) material.translucencyNormalPower = json.translucencyNormalPower;\r\n\t\tif ( json.translucencyViewAlpha !== undefined ) material.translucencyViewAlpha = json.translucencyViewAlpha;\r\n\t\tif ( json.translucencyViewPower !== undefined ) material.translucencyViewPower = json.translucencyViewPower;\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n\tconstructor: THREE.ObjectLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\t\tvar materials = this.parseMaterials( json.materials );\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json ) {\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\tvar geometry2Loader = new THREE.Geometry2Loader();\r\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.PlaneGeometry(\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // DEPRECATED\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.BoxGeometry(\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q,\r\n\t\t\t\t\t\t\tdata.heightScale\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data.data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry2':\r\n\r\n\t\t\t\t\t\tgeometry = geometry2Loader.parse( data.data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar loader = new THREE.MaterialLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\t\t\t\tvar material = loader.parse( data );\r\n\r\n\t\t\t\tmaterial.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\r\n\r\n\t\t\t\tmaterials[ data.uuid ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseObject: function () {\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( data, geometries, materials ) {\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'Scene':\r\n\r\n\t\t\t\t\tobject = new THREE.Scene();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay, data.physicalFalloff );\r\n\t\t\t\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay, data.physicalFalloff );\r\n\t\t\t\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AreaLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AreaLight( data.color, data.intensity, data.distance, data.decayExponent, data.decay, data.physicalFalloff );\r\n\t\t\t\t\tobject.width = data.width || 1;\r\n\t\t\t\t\tobject.height = data.height || 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\t\tvar geometry = geometries[ data.geometry ];\r\n\t\t\t\t\tvar material = materials[ data.material ];\r\n\r\n\t\t\t\t\tif ( geometry === undefined ) {\r\n\r\n\t\t\t\t\t\tTHREE.onerror( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( material === undefined ) {\r\n\r\n\t\t\t\t\t\tTHREE.onerror( 'THREE.ObjectLoader: Undefined material ' + data.material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\t\tvar material = materials[ data.material ];\r\n\r\n\t\t\t\t\tif ( material === undefined ) {\r\n\r\n\t\t\t\t\t\tTHREE.onerror( 'THREE.ObjectLoader: Undefined material ' + data.material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject = new THREE.Sprite( material );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.uuid = data.uuid;\r\n\r\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n\t\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var child in data.children ) {\r\n\r\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t}()\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneLoader = function () {\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function() {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n\tthis.callbackSync = function () {};\r\n\tthis.callbackProgress = function () {};\r\n\r\n\tthis.geometryHandlers = {};\r\n\tthis.hierarchyHandlers = {};\r\n\r\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype = {\r\n\r\n\tconstructor: THREE.SceneLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tscope.parse( JSON.parse( text ), onLoad, url );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\taddGeometryHandler: function ( typeID, loaderClass ) {\r\n\r\n\t\tthis.geometryHandlers[ typeID ] = { \"loaderClass\": loaderClass };\r\n\r\n\t},\r\n\r\n\taddHierarchyHandler: function ( typeID, loaderClass ) {\r\n\r\n\t\tthis.hierarchyHandlers[ typeID ] = { \"loaderClass\": loaderClass };\r\n\r\n\t},\r\n\r\n\tparse: function ( json, callbackFinished, url ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n\t\tvar geometry, material, camera, fog,\r\n\t\t\ttexture, images, color,\r\n\t\t\tlight, hex, intensity,\r\n\t\t\tcounter_models, counter_textures,\r\n\t\t\ttotal_models, total_textures,\r\n\t\t\tresult;\r\n\r\n\t\tvar target_array = [];\r\n\r\n\t\tvar data = json;\r\n\r\n\t\t// async geometry loaders\r\n\r\n\t\tfor ( var typeID in this.geometryHandlers ) {\r\n\r\n\t\t\tvar loaderClass = this.geometryHandlers[ typeID ][ \"loaderClass\" ];\r\n\t\t\tthis.geometryHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\r\n\r\n\t\t}\r\n\r\n\t\t// async hierachy loaders\r\n\r\n\t\tfor ( var typeID in this.hierarchyHandlers ) {\r\n\r\n\t\t\tvar loaderClass = this.hierarchyHandlers[ typeID ][ \"loaderClass\" ];\r\n\t\t\tthis.hierarchyHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\r\n\r\n\t\t}\r\n\r\n\t\tcounter_models = 0;\r\n\t\tcounter_textures = 0;\r\n\r\n\t\tresult = {\r\n\r\n\t\t\tscene: new THREE.Scene(),\r\n\t\t\tgeometries: {},\r\n\t\t\tface_materials: {},\r\n\t\t\tmaterials: {},\r\n\t\t\ttextures: {},\r\n\t\t\tobjects: {},\r\n\t\t\tcameras: {},\r\n\t\t\tlights: {},\r\n\t\t\tfogs: {},\r\n\t\t\tempties: {},\r\n\t\t\tgroups: {}\r\n\r\n\t\t};\r\n\r\n\t\tif ( data.transform ) {\r\n\r\n\t\t\tvar position = data.transform.position,\r\n\t\t\t\trotation = data.transform.rotation,\r\n\t\t\t\tscale = data.transform.scale;\r\n\r\n\t\t\tif ( position ) {\r\n\r\n\t\t\t\tresult.scene.position.fromArray( position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( rotation ) {\r\n\r\n\t\t\t\tresult.scene.rotation.fromArray( rotation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scale ) {\r\n\r\n\t\t\t\tresult.scene.scale.fromArray( scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( position || rotation || scale ) {\r\n\r\n\t\t\t\tresult.scene.updateMatrix();\r\n\t\t\t\tresult.scene.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction get_url( source_url, url_type ) {\r\n\r\n\t\t\tif ( url_type == \"relativeToHTML\" ) {\r\n\r\n\t\t\t\treturn source_url;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn urlBase + source_url;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\t// toplevel loader function, delegates to handle_children\r\n\r\n\t\tfunction handle_objects() {\r\n\r\n\t\t\thandle_children( result.scene, data.objects );\r\n\r\n\t\t}\r\n\r\n\t\t// handle all the children from the loaded json and attach them to given parent\r\n\r\n\t\tfunction handle_children( parent, children ) {\r\n\r\n\t\t\tvar mat, dst, pos, rot, scl, quat;\r\n\r\n\t\t\tfor ( var objID in children ) {\r\n\r\n\t\t\t\t// check by id if child has already been handled,\r\n\t\t\t\t// if not, create new object\r\n\r\n\t\t\t\tvar object = result.objects[ objID ];\r\n\t\t\t\tvar objJSON = children[ objID ];\r\n\r\n\t\t\t\tif ( object === undefined ) {\r\n\r\n\t\t\t\t\t// meshes\r\n\r\n\t\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\r\n\r\n\t\t\t\t\t\tif ( objJSON.loading === undefined ) {\r\n\r\n\t\t\t\t\t\t\tvar reservedTypes = {\r\n\t\t\t\t\t\t\t\t\"type\": 1, \"url\": 1, \"material\": 1,\r\n\t\t\t\t\t\t\t\t\"position\": 1, \"rotation\": 1, \"scale\" : 1,\r\n\t\t\t\t\t\t\t\t\"visible\": 1, \"children\": 1, \"userData\": 1,\r\n\t\t\t\t\t\t\t\t\"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tvar loaderParameters = {};\r\n\r\n\t\t\t\t\t\t\tfor ( var parType in objJSON ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\r\n\r\n\t\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\r\n\r\n\t\t\t\t\t\t\tobjJSON.loading = true;\r\n\r\n\t\t\t\t\t\t\tvar loader = scope.hierarchyHandlers[ objJSON.type ][ \"loaderObject\" ];\r\n\r\n\t\t\t\t\t\t\t// ColladaLoader\r\n\r\n\t\t\t\t\t\t\tif ( loader.options ) {\r\n\r\n\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\r\n\r\n\t\t\t\t\t\t\t// UTF8Loader\r\n\t\t\t\t\t\t\t// OBJLoader\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\r\n\r\n\t\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\r\n\r\n\t\t\t\t\t\t// geometry already loaded\r\n\r\n\t\t\t\t\t\tif ( geometry ) {\r\n\r\n\t\t\t\t\t\t\tvar needsTangents = false;\r\n\r\n\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\r\n\t\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\r\n\r\n\t\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\t\t\tscl = objJSON.scale;\r\n\t\t\t\t\t\t\tmat = objJSON.matrix;\r\n\t\t\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\t\t\t// use materials from the model file\r\n\t\t\t\t\t\t\t// if there is no material specified in the object\r\n\r\n\t\t\t\t\t\t\tif ( ! objJSON.material ) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// use materials from the model file\r\n\t\t\t\t\t\t\t// if there is just empty face material\r\n\t\t\t\t\t\t\t// (must create new material as each model has its own face material)\r\n\r\n\t\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( needsTangents ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.computeTangents();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.skin ) {\r\n\r\n\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t\t\t\t} else if ( objJSON.morph ) {\r\n\r\n\t\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\r\n\r\n\t\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tobject.time = objJSON.time;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tobject.name = objID;\r\n\r\n\t\t\t\t\t\t\tif ( mat ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\r\n\t\t\t\t\t\t\t\tobject.matrix.set(\r\n\t\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\r\n\t\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\r\n\t\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\r\n\t\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tobject.position.fromArray( pos );\r\n\r\n\t\t\t\t\t\t\t\tif ( quat ) {\r\n\r\n\t\t\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tobject.scale.fromArray( scl );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tobject.visible = objJSON.visible;\r\n\t\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\r\n\t\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\r\n\r\n\t\t\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\t\t\tresult.objects[ objID ] = object;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// lights\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" || objJSON.type === \"PointLight\" ||\r\n\t\t\t\t\t\tobjJSON.type === \"DirectionalLight\" || objJSON.type === \"SpotLight\" ||\r\n\t\t\t\t\t\tobjJSON.type === \"HemisphereLight\" || objJSON.type === \"AreaLight\" ) {\r\n\r\n\t\t\t\t\t\tvar color = objJSON.color;\r\n\t\t\t\t\t\tvar intensity = objJSON.intensity;\r\n\t\t\t\t\t\tvar distance = objJSON.distance;\r\n\t\t\t\t\t\tvar position = objJSON.position;\r\n\t\t\t\t\t\tvar rotation = objJSON.rotation;\r\n\r\n\t\t\t\t\t\tswitch ( objJSON.type ) {\r\n\r\n\t\t\t\t\t\t\tcase 'AmbientLight':\r\n\t\t\t\t\t\t\t\tlight = new THREE.AmbientLight( color );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\t\t\t\tlight = new THREE.PointLight( color, intensity, distance );\r\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity );\r\n\t\t\t\t\t\t\t\tlight.position.fromArray( objJSON.direction );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\t\t\t\tlight = new THREE.SpotLight( color, intensity, distance, 1 );\r\n\t\t\t\t\t\t\t\tlight.angle = objJSON.angle;\r\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\r\n\t\t\t\t\t\t\t\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\r\n\t\t\t\t\t\t\t\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'HemisphereLight':\r\n\t\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity, distance );\r\n\t\t\t\t\t\t\t\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\r\n\t\t\t\t\t\t\t\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'AreaLight':\r\n\t\t\t\t\t\t\t\tlight = new THREE.AreaLight(color, intensity);\r\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\r\n\t\t\t\t\t\t\t\tlight.width = objJSON.size;\r\n\t\t\t\t\t\t\t\tlight.height = objJSON.size_y;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tparent.add( light );\r\n\r\n\t\t\t\t\t\tlight.name = objID;\r\n\t\t\t\t\t\tresult.lights[ objID ] = light;\r\n\t\t\t\t\t\tresult.objects[ objID ] = light;\r\n\r\n\t\t\t\t\t// cameras\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\r\n\r\n\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\r\n\r\n\t\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\r\n\r\n\t\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\r\n\r\n\t\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcamera.name = objID;\r\n\t\t\t\t\t\tcamera.position.fromArray( pos );\r\n\r\n\t\t\t\t\t\tif ( quat !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tcamera.quaternion.fromArray( quat );\r\n\r\n\t\t\t\t\t\t} else if ( rot !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tcamera.rotation.fromArray( rot );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tparent.add( camera );\r\n\r\n\t\t\t\t\t\tresult.cameras[ objID ] = camera;\r\n\t\t\t\t\t\tresult.objects[ objID ] = camera;\r\n\r\n\t\t\t\t\t// pure Object3D\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\t\tscl = objJSON.scale;\r\n\t\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\t\t\t\t\tobject.name = objID;\r\n\t\t\t\t\t\tobject.position.fromArray( pos );\r\n\r\n\t\t\t\t\t\tif ( quat ) {\r\n\r\n\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobject.scale.fromArray( scl );\r\n\t\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\r\n\r\n\t\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\t\tresult.objects[ objID ] = object;\r\n\t\t\t\t\t\tresult.empties[ objID ] = object;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( object ) {\r\n\r\n\t\t\t\t\t\tif ( objJSON.userData !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var key in objJSON.userData ) {\r\n\r\n\t\t\t\t\t\t\t\tvar value = objJSON.userData[ key ];\r\n\t\t\t\t\t\t\t\tobject.userData[ key ] = value;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( objJSON.groups !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\r\n\r\n\t\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( object !== undefined && objJSON.children !== undefined ) {\r\n\r\n\t\t\t\t\thandle_children( object, objJSON.children );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction handle_mesh( geo, mat, id ) {\r\n\r\n\t\t\tresult.geometries[ id ] = geo;\r\n\t\t\tresult.face_materials[ id ] = mat;\r\n\t\t\thandle_objects();\r\n\r\n\t\t};\r\n\r\n\t\tfunction handle_hierarchy( node, id, parent, material, obj ) {\r\n\r\n\t\t\tvar p = obj.position;\r\n\t\t\tvar r = obj.rotation;\r\n\t\t\tvar q = obj.quaternion;\r\n\t\t\tvar s = obj.scale;\r\n\r\n\t\t\tnode.position.fromArray( p );\r\n\r\n\t\t\tif ( q ) {\r\n\r\n\t\t\t\tnode.quaternion.fromArray( q );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode.rotation.fromArray( r );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnode.scale.fromArray( s );\r\n\r\n\t\t\t// override children materials\r\n\t\t\t// if object material was specified in JSON explicitly\r\n\r\n\t\t\tif ( material ) {\r\n\r\n\t\t\t\tnode.traverse( function ( child ) {\r\n\r\n\t\t\t\t\tchild.material = material;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// override children visibility\r\n\t\t\t// with root node visibility as specified in JSON\r\n\r\n\t\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\r\n\r\n\t\t\tnode.traverse( function ( child ) {\r\n\r\n\t\t\t\tchild.visible = visible;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tparent.add( node );\r\n\r\n\t\t\tnode.name = id;\r\n\r\n\t\t\tresult.objects[ id ] = node;\r\n\t\t\thandle_objects();\r\n\r\n\t\t};\r\n\r\n\t\tfunction create_callback_geometry( id ) {\r\n\r\n\t\t\treturn function ( geo, mat ) {\r\n\r\n\t\t\t\tgeo.name = id;\r\n\r\n\t\t\t\thandle_mesh( geo, mat, id );\r\n\r\n\t\t\t\tcounter_models -= 1;\r\n\r\n\t\t\t\tscope.onLoadComplete();\r\n\r\n\t\t\t\tasync_callback_gate();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction create_callback_hierachy( id, parent, material, obj ) {\r\n\r\n\t\t\treturn function ( event ) {\r\n\r\n\t\t\t\tvar result;\r\n\r\n\t\t\t\t// loaders which use EventDispatcher\r\n\r\n\t\t\t\tif ( event.content ) {\r\n\r\n\t\t\t\t\tresult = event.content;\r\n\r\n\t\t\t\t// ColladaLoader\r\n\r\n\t\t\t\t} else if ( event.dae ) {\r\n\r\n\t\t\t\t\tresult = event.scene;\r\n\r\n\r\n\t\t\t\t// UTF8Loader\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tresult = event;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\thandle_hierarchy( result, id, parent, material, obj );\r\n\r\n\t\t\t\tcounter_models -= 1;\r\n\r\n\t\t\t\tscope.onLoadComplete();\r\n\r\n\t\t\t\tasync_callback_gate();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction create_callback_embed( id ) {\r\n\r\n\t\t\treturn function ( geo, mat ) {\r\n\r\n\t\t\t\tgeo.name = id;\r\n\r\n\t\t\t\tresult.geometries[ id ] = geo;\r\n\t\t\t\tresult.face_materials[ id ] = mat;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction async_callback_gate() {\r\n\r\n\t\t\tvar progress = {\r\n\r\n\t\t\t\ttotalModels : total_models,\r\n\t\t\t\ttotalTextures : total_textures,\r\n\t\t\t\tloadedModels : total_models - counter_models,\r\n\t\t\t\tloadedTextures : total_textures - counter_textures\r\n\r\n\t\t\t};\r\n\r\n\t\t\tscope.callbackProgress( progress, result );\r\n\r\n\t\t\tscope.onLoadProgress();\r\n\r\n\t\t\tif ( counter_models === 0 && counter_textures === 0 ) {\r\n\r\n\t\t\t\tfinalize();\r\n\t\t\t\tcallbackFinished( result );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction finalize() {\r\n\r\n\t\t\t// take care of targets which could be asynchronously loaded objects\r\n\r\n\t\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\r\n\r\n\t\t\t\tvar ta = target_array[ i ];\r\n\r\n\t\t\t\tvar target = result.objects[ ta.targetName ];\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\tta.object.target = target;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\r\n\t\t\t\t\t// create instead dummy target\r\n\t\t\t\t\t// (target must be added to scene explicitly as parent is already added)\r\n\r\n\t\t\t\t\tta.object.target = new THREE.Object3D();\r\n\t\t\t\t\tresult.scene.add( ta.object.target );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tta.object.target.userData.targetInverse = ta.object;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar callbackTexture = function ( count ) {\r\n\r\n\t\t\tcounter_textures -= count;\r\n\t\t\tasync_callback_gate();\r\n\r\n\t\t\tscope.onLoadComplete();\r\n\r\n\t\t};\r\n\r\n\t\t// must use this instead of just directly calling callbackTexture\r\n\t\t// because of closure in the calling context loop\r\n\r\n\t\tvar generateTextureCallback = function ( count ) {\r\n\r\n\t\t\treturn function () {\r\n\r\n\t\t\t\tcallbackTexture( count );\r\n\r\n\t\t\t};\r\n\r\n\t\t};\r\n\r\n\t\tfunction traverse_json_hierarchy( objJSON, callback ) {\r\n\r\n\t\t\tcallback( objJSON );\r\n\r\n\t\t\tif ( objJSON.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var objChildID in objJSON.children ) {\r\n\r\n\t\t\t\t\ttraverse_json_hierarchy( objJSON.children[ objChildID ], callback );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\t// first go synchronous elements\r\n\r\n\t\t// fogs\r\n\r\n\t\tvar fogID, fogJSON;\r\n\r\n\t\tfor ( fogID in data.fogs ) {\r\n\r\n\t\t\tfogJSON = data.fogs[ fogID ];\r\n\r\n\t\t\tif ( fogJSON.type === \"linear\" ) {\r\n\r\n\t\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\r\n\r\n\t\t\t} else if ( fogJSON.type === \"exp2\" ) {\r\n\r\n\t\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolor = fogJSON.color;\r\n\t\t\tfog.color.setRGB( color[0], color[1], color[2] );\r\n\r\n\t\t\tresult.fogs[ fogID ] = fog;\r\n\r\n\t\t}\r\n\r\n\t\t// now come potentially asynchronous elements\r\n\r\n\t\t// geometries\r\n\r\n\t\t// count how many geometries will be loaded asynchronously\r\n\r\n\t\tvar geoID, geoJSON;\r\n\r\n\t\tfor ( geoID in data.geometries ) {\r\n\r\n\t\t\tgeoJSON = data.geometries[ geoID ];\r\n\r\n\t\t\tif ( geoJSON.type in this.geometryHandlers ) {\r\n\r\n\t\t\t\tcounter_models += 1;\r\n\r\n\t\t\t\tscope.onLoadStart();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// count how many hierarchies will be loaded asynchronously\r\n\r\n\t\tfor ( var objID in data.objects ) {\r\n\r\n\t\t\ttraverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {\r\n\r\n\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\r\n\r\n\t\t\t\t\tcounter_models += 1;\r\n\r\n\t\t\t\t\tscope.onLoadStart();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\ttotal_models = counter_models;\r\n\r\n\t\tfor ( geoID in data.geometries ) {\r\n\r\n\t\t\tgeoJSON = data.geometries[ geoID ];\r\n\r\n\t\t\tif ( geoJSON.type === \"cube\" ) {\r\n\r\n\t\t\t\tgeometry = new THREE.BoxGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\r\n\t\t\t\tgeometry.name = geoID;\r\n\t\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t\t} else if ( geoJSON.type === \"plane\" ) {\r\n\r\n\t\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\r\n\t\t\t\tgeometry.name = geoID;\r\n\t\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t\t} else if ( geoJSON.type === \"sphere\" ) {\r\n\r\n\t\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\r\n\t\t\t\tgeometry.name = geoID;\r\n\t\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t\t} else if ( geoJSON.type === \"cylinder\" ) {\r\n\r\n\t\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\r\n\t\t\t\tgeometry.name = geoID;\r\n\t\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t\t} else if ( geoJSON.type === \"torus\" ) {\r\n\r\n\t\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\r\n\t\t\t\tgeometry.name = geoID;\r\n\t\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\r\n\r\n\t\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\r\n\t\t\t\tgeometry.name = geoID;\r\n\t\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t\t} else if ( geoJSON.type in this.geometryHandlers ) {\r\n\r\n\t\t\t\tvar loaderParameters = {};\r\n\r\n\t\t\t\tfor ( var parType in geoJSON ) {\r\n\r\n\t\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\r\n\r\n\t\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar loader = this.geometryHandlers[ geoJSON.type ][ \"loaderObject\" ];\r\n\t\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\r\n\r\n\t\t\t} else if ( geoJSON.type === \"embedded\" ) {\r\n\r\n\t\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\r\n\t\t\t\t\ttexture_path = \"\";\r\n\r\n\t\t\t\t// pass metadata along to jsonLoader so it knows the format version\r\n\r\n\t\t\t\tmodelJson.metadata = data.metadata;\r\n\r\n\t\t\t\tif ( modelJson ) {\r\n\r\n\t\t\t\t\tvar jsonLoader = this.geometryHandlers[ \"ascii\" ][ \"loaderObject\" ];\r\n\t\t\t\t\tvar model = jsonLoader.parse( modelJson, texture_path );\r\n\t\t\t\t\tcreate_callback_embed( geoID )( model.geometry, model.materials );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\t// count how many textures will be loaded asynchronously\r\n\r\n\t\tvar textureID, textureJSON;\r\n\r\n\t\tfor ( textureID in data.textures ) {\r\n\r\n\t\t\ttextureJSON = data.textures[ textureID ];\r\n\r\n\t\t\tif ( textureJSON.url instanceof Array ) {\r\n\r\n\t\t\t\tcounter_textures += textureJSON.url.length;\r\n\r\n\t\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\r\n\r\n\t\t\t\t\tscope.onLoadStart();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcounter_textures += 1;\r\n\r\n\t\t\t\tscope.onLoadStart();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ttotal_textures = counter_textures;\r\n\r\n\t\tfor ( textureID in data.textures ) {\r\n\r\n\t\t\ttextureJSON = data.textures[ textureID ];\r\n\r\n\t\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {\r\n\r\n\t\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( textureJSON.url instanceof Array ) {\r\n\r\n\t\t\t\tvar count = textureJSON.url.length;\r\n\t\t\t\tvar url_array = [];\r\n\r\n\t\t\t\tfor( var i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\r\n\r\n\t\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\r\n\t\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\r\n\t\t\t\tvar textureCallback = generateTextureCallback( 1 );\r\n\r\n\t\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\r\n\t\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\r\n\r\n\t\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\r\n\t\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\r\n\r\n\t\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\r\n\r\n\t\t\t\tif ( textureJSON.repeat ) {\r\n\r\n\t\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\r\n\r\n\t\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( textureJSON.offset ) {\r\n\r\n\t\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// handle wrap after repeat so that default repeat can be overriden\r\n\r\n\t\t\t\tif ( textureJSON.wrap ) {\r\n\r\n\t\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\r\n\t\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\r\n\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult.textures[ textureID ] = texture;\r\n\r\n\t\t}\r\n\r\n\t\t// materials\r\n\r\n\t\tvar matID, matJSON;\r\n\t\tvar parID;\r\n\r\n\t\tfor ( matID in data.materials ) {\r\n\r\n\t\t\tmatJSON = data.materials[ matID ];\r\n\r\n\t\t\tfor ( parID in matJSON.parameters ) {\r\n\r\n\t\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\r\n\r\n\t\t\t\t} else if ( parID === \"shading\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\r\n\r\n\t\t\t\t} else if ( parID === \"side\" ) {\r\n\r\n\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\r\n\r\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\r\n\r\n\t\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\r\n\r\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( parID === \"blending\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\r\n\r\n\t\t\t\t} else if ( parID === \"combine\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\r\n\r\n\t\t\t\t} else if ( parID === \"vertexColors\" ) {\r\n\r\n\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\r\n\r\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\r\n\r\n\t\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\r\n\r\n\t\t\t\t\t} else if ( matJSON.parameters[ parID ] ) {\r\n\r\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( parID === \"wrapRGB\" ) {\r\n\r\n\t\t\t\t\tvar v3 = matJSON.parameters[ parID ];\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\r\n\r\n\t\t\t\tmatJSON.parameters.transparent = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.normalMap ) {\r\n\r\n\t\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\t\tvar diffuse = matJSON.parameters.color;\r\n\t\t\t\tvar specular = matJSON.parameters.specular;\r\n\t\t\t\tvar ambient = matJSON.parameters.ambient;\r\n\t\t\t\tvar shininess = matJSON.parameters.shininess;\r\n\r\n\t\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\r\n\r\n\t\t\t\tif ( matJSON.parameters.normalScale ) {\r\n\r\n\t\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( matJSON.parameters.map ) {\r\n\r\n\t\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\r\n\t\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( matJSON.parameters.envMap ) {\r\n\r\n\t\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\r\n\t\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\r\n\t\t\t\t\tuniforms[ \"reflectivity\" ].value = matJSON.parameters.reflectivity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( matJSON.parameters.lightMap ) {\r\n\r\n\t\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\r\n\t\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( matJSON.parameters.specularMap ) {\r\n\r\n\t\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\r\n\t\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( matJSON.parameters.displacementMap ) {\r\n\r\n\t\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\r\n\t\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\r\n\r\n\t\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\r\n\t\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuniforms[ \"diffuse\" ].value.setHex( diffuse );\r\n\t\t\t\tuniforms[ \"specular\" ].value.setHex( specular );\r\n\t\t\t\tuniforms[ \"ambient\" ].value.setHex( ambient );\r\n\r\n\t\t\t\tuniforms[ \"shininess\" ].value = shininess;\r\n\r\n\t\t\t\tif ( matJSON.parameters.opacity ) {\r\n\r\n\t\t\t\t\tuniforms[ \"opacity\" ].value = matJSON.parameters.opacity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\r\n\t\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.name = matID;\r\n\r\n\t\t\tresult.materials[ matID ] = material;\r\n\r\n\t\t}\r\n\r\n\t\t// second pass through all materials to initialize MeshFaceMaterials\r\n\t\t// that could be referring to other materials out of order\r\n\r\n\t\tfor ( matID in data.materials ) {\r\n\r\n\t\t\tmatJSON = data.materials[ matID ];\r\n\r\n\t\t\tif ( matJSON.parameters.materials ) {\r\n\r\n\t\t\t\tvar materialArray = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar label = matJSON.parameters.materials[ i ];\r\n\t\t\t\t\tmaterialArray.push( result.materials[ label ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult.materials[ matID ].materials = materialArray;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// objects ( synchronous init of procedural primitives )\r\n\r\n\t\thandle_objects();\r\n\r\n\t\t// defaults\r\n\r\n\t\tif ( result.cameras && data.defaults.camera ) {\r\n\r\n\t\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( result.fogs && data.defaults.fog ) {\r\n\r\n\t\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\r\n\r\n\t\t}\r\n\r\n\t\t// synchronous callback\r\n\r\n\t\tscope.callbackSync( result );\r\n\r\n\t\t// just in case there are no async elements\r\n\r\n\t\tasync_callback_gate();\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.ImageLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tthis.id = THREE.MaterialIdCount ++;\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n\tconstructor: THREE.Material,\r\n\r\n\tsetValues: function ( values ) {\r\n\r\n\t\tif ( values === undefined ) return;\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tTHREE.onwarning( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( key in this ) {\r\n\r\n\t\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t\t} else if ( key == 'overdraw') {\r\n\r\n\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\r\n\t\t\t\t\tthis[ key ] = Number(newValue);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( material ) {\r\n\r\n\t\tif ( material === undefined ) material = new THREE.Material();\r\n\r\n\t\tmaterial.name = this.name;\r\n\r\n\t\tmaterial.side = this.side;\r\n\r\n\t\tmaterial.opacity = this.opacity;\r\n\t\tmaterial.transparent = this.transparent;\r\n\r\n\t\tmaterial.blending = this.blending;\r\n\r\n\t\tmaterial.blendSrc = this.blendSrc;\r\n\t\tmaterial.blendDst = this.blendDst;\r\n\t\tmaterial.blendEquation = this.blendEquation;\r\n\r\n\t\tmaterial.depthTest = this.depthTest;\r\n\t\tmaterial.depthWrite = this.depthWrite;\r\n\r\n\t\tmaterial.polygonOffset = this.polygonOffset;\r\n\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\r\n\t\tmaterial.alphaTest = this.alphaTest;\r\n\r\n\t\tmaterial.overdraw = this.overdraw;\r\n\r\n\t\tmaterial.visible = this.visible;\r\n\r\n\t\treturn material;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\tmaterial.linecap = this.linecap;\r\n\tmaterial.linejoin = this.linejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineDashedMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\r\n\tmaterial.scale = this.scale;\r\n\tmaterial.dashSize = this.dashSize;\r\n\tmaterial.gapSize = this.gapSize;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.ambient = new THREE.Color( 0xffffff );\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshLambertMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.ambient = new THREE.Color( 0x000000 );\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.specular = new THREE.Color( 0xffffff );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\tthis.opacityMap = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshPhongMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\tmaterial.specular.copy( this.specular );\r\n\tmaterial.shininess = this.shininess;\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\tmaterial.opacityMap = this.opacityMap;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\tmaterial.emissiveMap = this.emissiveMap;\r\n\r\n\tmaterial.bumpMap = this.bumpMap;\r\n\tmaterial.bumpScale = this.bumpScale;\r\n\r\n\tmaterial.normalMap = this.normalMap;\r\n\tmaterial.normalScale.copy( this.normalScale );\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n *\r\n * @author bhouston / http://clara.io/\r\n *\r\n */\r\n\r\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.map = null;\r\n\tthis.opacityMap = null;\r\n\tthis.fog = true;\r\n\r\n\tthis.falloff = false;\r\n\tthis.falloffColor = new THREE.Color( 0xffffff );\r\n\tthis.falloffMap = null;\r\n\tthis.falloffBlendParams = new THREE.Vector4( 1.0, 0.0, 0.0, 1.0 );\r\n\r\n\tthis.specular = new THREE.Color( 0xffffff );\r\n\tthis.specularMap = null;\r\n\r\n\tthis.roughness = 0.5;\r\n\tthis.roughnessMap = null;\r\n\r\n\tthis.metallic = 0.0;\r\n\tthis.metallicMap = null;\r\n\r\n\tthis.clearCoat = 0.0;\t// 0 means no clear coat, 1 means complete clear coat.\r\n\tthis.clearCoatRoughness = 0.2;\r\n\r\n\tthis.anisotropy = 0.0;\t// valid range is [-1,1].-1 is max vertical elongation, 0 is normal, +1 is max horizontal elongation\r\n\tthis.anisotropyMap = null;\t// only R is read and considered to be anisotropy.  To get negative values, use texture brightness, gain\r\n\tthis.anisotropyRotation = 0.0; // converted to radias via multiplication by 2*PI.  Thus the range [ 0 - 1 ] maps to radian [0, PI].\r\n\tthis.anisotropyRotationMap = null;  // only R is read and considered to be anisotropyRotation.\r\n\r\n\tthis.translucency = new THREE.Color( 0x000000 );\r\n\tthis.translucencyMap = null;\r\n\tthis.translucencyNormalAlpha = 0.75;\r\n\tthis.translucencyNormalPower = 1.0;\r\n\tthis.translucencyViewPower = 2.0;\r\n\tthis.translucencyViewAlpha = 0.75;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveMap = null; \t// given off arbitrarily by the object in all directions.  Basically GI.\r\n\r\n\tthis.ambient = new THREE.Color( 0x000000 );\r\n\tthis.lightMap = null; // incoming light\r\n\r\n\tthis.envMap = null;  // Incoming environmental light.\r\n\tthis.diffuseEnvMap = null;  // irradiance light.\r\n\r\n\tthis.combine = THREE.AddOperation;\r\n\r\n\tthis.shading = THREE.SmoothShading\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.blending = THREE.CustomBlending;\r\n\tthis.blendSrc = THREE.OneFactor;\t// output of shader must be premultiplied\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n};\r\n\r\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshPhysicalMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshPhysicalMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.map = this.map;\r\n\tmaterial.opacityMap = this.opacityMap;\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.falloff = this.falloff;\r\n\tmaterial.falloffColor.copy( this.falloffColor );\r\n\tmaterial.falloffMap = this.falloffMap;\r\n\tmaterial.falloffBlendParams.copy( this.falloffBlendParams );\r\n\r\n\tmaterial.specular.copy( this.specular );\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.roughness = this.roughness;\r\n\tmaterial.roughnessMap = this.roughnessMap;\r\n\tmaterial.metallic = this.metallic;\r\n\tmaterial.metallicMap = this.metallicMap;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.translucency.copy( this.translucency );\r\n\tmaterial.translucencyMap = this.translucencyMap;\r\n\tmaterial.translucencyNormalAlpha = this.translucencyNormalAlpha;\r\n\tmaterial.translucencyNormalPower = this.translucencyNormalPower;\r\n\tmaterial.translucencyViewPower = this.translucencyViewPower;\r\n\tmaterial.translucencyViewAlpha = this.translucencyViewAlpha;\r\n\r\n\tmaterial.bumpMap = this.bumpMap;\r\n\tmaterial.bumpScale = this.bumpScale;\r\n\r\n\tmaterial.normalMap = this.normalMap;\r\n\tmaterial.normalScale.copy( this.normalScale );\r\n\r\n\tmaterial.emissive.copy( this.emissive );\r\n\tmaterial.emissiveMap = this.emissiveMap;\r\n\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.diffuseEnvMap = this.diffuseEnvMap;\r\n\r\n\tmaterial.combine = this.combine;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshDepthMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.shading = THREE.FlatShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshNormalMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MeshFaceMaterial = function ( materials ) {\r\n\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n};\r\n\r\nTHREE.MeshFaceMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshFaceMaterial();\r\n\r\n\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\r\n\t}\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ParticleSystemMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ParticleSystemMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.size = this.size;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  defines: { \"label\" : \"value\" },\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.shaderID = null;\r\n\tthis.fragmentShader = \"void main() {}\";\r\n\tthis.vertexShader = \"void main() {}\";\r\n\tthis.uniforms = {};\r\n\tthis.defines = {};\r\n\tthis.attributes = null;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t\"color\" : [ 1, 1, 1],\r\n\t\t\"uv\" : [ 0, 0 ],\r\n\t\t\"uv2\" : [ 0, 0 ]\r\n\t};\r\n\r\n\t// By default, bind position to attribute index 0. In WebGL, attribute 0\r\n\t// should always be used to avoid potentially expensive emulation.\r\n\tthis.index0AttributeName = \"position\";\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ShaderMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.fragmentShader = this.fragmentShader;\r\n\tmaterial.vertexShader = this.vertexShader;\r\n\r\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\r\n\tmaterial.attributes = this.attributes;\r\n\tmaterial.defines = this.defines;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.lights = this.lights;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\t// defaults\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.fog = false;\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.SpriteMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.SpriteMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.rotation = this.rotation;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  program: <function>,\r\n *  opacity: <float>,\r\n *  blending: THREE.NormalBlending\r\n * }\r\n */\r\n\r\nTHREE.SpriteCanvasMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.program = function ( context, color ) {};\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.SpriteCanvasMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.SpriteCanvasMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.program = this.program;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n * @author bhouston / https://clara.io/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tthis.id = THREE.TextureIdCount ++;\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.image = image;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\t// formula used\r\n\t// x' = ( x - gainPivot ) * gain + brightness + gainPivot\r\n\t// for standard contrast adjust, set gain to contrast, and gainPivot to 0.5\r\n\tthis.invert = false;\r\n\tthis.gainPivot = 0.0;\r\n\tthis.gain = 1.0;\r\n\tthis.brightness = 0.0;\r\n\tthis.encoding = THREE.sRGB;\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\tthis._needsUpdate = false;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tclone: function ( texture ) {\r\n\r\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\r\n\t\ttexture.image = this.image;\r\n\t\ttexture.mipmaps = this.mipmaps.slice(0);\r\n\r\n\t\ttexture.mapping = this.mapping;\r\n\r\n\t\ttexture.wrapS = this.wrapS;\r\n\t\ttexture.wrapT = this.wrapT;\r\n\r\n\t\ttexture.magFilter = this.magFilter;\r\n\t\ttexture.minFilter = this.minFilter;\r\n\r\n\t\ttexture.anisotropy = this.anisotropy;\r\n\r\n\t\ttexture.format = this.format;\r\n\t\ttexture.type = this.type;\r\n\r\n\t\ttexture.offset.copy( this.offset );\r\n\t\ttexture.repeat.copy( this.repeat );\r\n\r\n\t\ttexture.invert = this.invert;\r\n\t\ttexture.gainPivot = this.gainPivot;\r\n\t\ttexture.gain = this.gain;\r\n\t\ttexture.brightness = this.brightness;\r\n\t\ttexture.encoding = this.encoding;\r\n\r\n\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\ttexture.flipY = this.flipY;\r\n\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\r\nTHREE.CompressedTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.CompressedTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\r\nTHREE.DataTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.DataTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.sortParticles = false;\r\n\tthis.frustumCulled = false;\r\n\r\n};\r\n\r\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\r\n\r\n\tobject.sortParticles = this.sortParticles;\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, type ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\r\n\r\n};\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Line.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = -1;\r\n\t\tthis.morphTargetForcedOrder = [];\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tTHREE.onwarning( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Bone = function( belongsToSkin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.skin = belongsToSkin;\r\n\tthis.skinMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\r\n\r\n\t// update local\r\n\r\n\tif ( this.matrixAutoUpdate ) {\r\n\r\n\t\tforceUpdate |= this.updateMatrix();\r\n\r\n\t}\r\n\r\n\t// update skin matrix\r\n\r\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\r\n\r\n\t\tif( parentSkinMatrix ) {\r\n\r\n\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.skinMatrix.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\tforceUpdate = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tvar child, i, l = this.children.length;\r\n\r\n\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\t//\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\t// init bones\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\tthis.bones = [];\r\n\tthis.boneMatrices = [];\r\n\r\n\tvar b, bone, gbone, p, q, s;\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tp = gbone.pos;\r\n\t\t\tq = gbone.rotq;\r\n\t\t\ts = gbone.scl;\r\n\r\n\t\t\tbone = this.addBone();\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.set( p[0], p[1], p[2] );\r\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\r\n\t\t\r\n\t\t\tif ( s !== undefined ) {\r\n\r\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\t\tbone = this.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent === -1 ) {\r\n\r\n\t\t\t\tthis.add( bone );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar nBones = this.bones.length;\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\r\n\t\t\tvar size;\r\n\r\n\t\t\tif ( nBones > 256 )\r\n\t\t\t\tsize = 64;\r\n\t\t\telse if ( nBones > 64 )\r\n\t\t\t\tsize = 32;\r\n\t\t\telse if ( nBones > 16 )\r\n\t\t\t\tsize = 16;\r\n\t\t\telse\r\n\t\t\t\tsize = 8;\r\n\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\t\tthis.boneTexture.flipY = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\r\n\r\n\t\t}\r\n\r\n\t\tthis.pose();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\r\n\r\n\tif ( bone === undefined ) {\r\n\r\n\t\tbone = new THREE.Bone( this );\r\n\r\n\t}\r\n\r\n\tthis.bones.push( bone );\r\n\r\n\treturn bone;\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function () {\r\n\r\n\tvar offsetMatrix = new THREE.Matrix4();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t\t// update matrixWorld\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent ) {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\r\n\t\t\tif ( child instanceof THREE.Bone ) {\r\n\r\n\t\t\t\tchild.update( this.identityMatrix, false );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tchild.updateMatrixWorld( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// make a snapshot of the bones' rest position\r\n\r\n\t\tif ( this.boneInverses == undefined ) {\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\r\n\r\n\t\t\t\tthis.boneInverses.push( inverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// flatten bone matrices to array\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t// compute the offset between the current and the original transform;\r\n\r\n\t\t\t// TODO: we could get rid of this multiplication step if the skinMatrix\r\n\t\t\t// was already representing the offset; however, this requires some\r\n\t\t\t// major changes to the animation system\r\n\r\n\t\t\toffsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\r\n\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) {\r\n\r\n\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\r\n\t}\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\t// API\r\n\r\n\tthis.duration = 1000; // milliseconds\r\n\tthis.mirroredLoop = false;\r\n\tthis.time = 0;\r\n\r\n\t// internals\r\n\r\n\tthis.lastKeyframe = 0;\r\n\tthis.currentKeyframe = 0;\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n\tthis.startKeyframe = start;\r\n\tthis.endKeyframe = end;\r\n\r\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n\tthis.direction = -1;\r\n\tthis.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tif ( ! geometry.animations ) geometry.animations = {};\r\n\r\n\tvar firstAnimation, animations = geometry.animations;\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar parts = morph.name.match( pattern );\r\n\r\n\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\tvar label = parts[ 1 ];\r\n\t\t\tvar num = parts[ 2 ];\r\n\r\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar animation = animations[ label ];\r\n\r\n\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\tif ( i > animation.end ) animation.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n\tvar animation = this.geometry.animations[ label ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\tthis.time = 0;\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.onwarning( \"animation[\" + label + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n\tvar frameTime = this.duration / this.length;\r\n\r\n\tthis.time += this.direction * delta;\r\n\r\n\tif ( this.mirroredLoop ) {\r\n\r\n\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\r\n\t\t\tthis.direction *= -1;\r\n\r\n\t\t\tif ( this.time > this.duration ) {\r\n\r\n\t\t\t\tthis.time = this.duration;\r\n\t\t\t\tthis.directionBackwards = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.time < 0 ) {\r\n\r\n\t\t\t\tthis.time = 0;\r\n\t\t\t\tthis.directionBackwards = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tthis.time = this.time % this.duration;\r\n\r\n\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\r\n\t}\r\n\r\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n\tif ( keyframe !== this.currentKeyframe ) {\r\n\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\r\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\tthis.currentKeyframe = keyframe;\r\n\r\n\t}\r\n\r\n\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\r\n\tif ( this.directionBackwards ) {\r\n\r\n\t\tmix = 1 - mix;\r\n\r\n\t}\r\n\r\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\r\n\tobject.duration = this.duration;\r\n\tobject.mirroredLoop = this.mirroredLoop;\r\n\tobject.time = this.time;\r\n\r\n\tobject.lastKeyframe = this.lastKeyframe;\r\n\tobject.currentKeyframe = this.currentKeyframe;\r\n\r\n\tobject.direction = this.direction;\r\n\tobject.directionBackwards = this.directionBackwards;\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.objects = [];\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n\tif ( distance === undefined ) distance = 0;\r\n\r\n\tdistance = Math.abs( distance );\r\n\r\n\tfor ( var l = 0; l < this.objects.length; l ++ ) {\r\n\r\n\t\tif ( distance < this.objects[ l ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.objects.splice( l, 0, { distance: distance, object: object } );\r\n\tthis.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\tif ( distance < this.objects[ i ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.objects[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( camera ) {\r\n\r\n\t\tif ( this.objects.length > 1 ) {\r\n\r\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\tthis.objects[ 0 ].object.visible = true;\r\n\r\n\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\r\n\r\n\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\r\n\t\t\t\t\tthis.objects[ i     ].object.visible = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor( ; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.objects[ i ].object.visible = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.LOD();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\t\tvar x = this.objects[i].object.clone();\r\n\t\tx.visible = i === 0;\r\n\t\tobject.addLevel( x, this.objects[i].distance );\r\n\t}\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n\tvar geometry = new THREE.Geometry2( 3 );\r\n\tgeometry.vertices.set( [ - 0.5, - 0.5, 0, 0.5, - 0.5, 0, 0.5, 0.5, 0 ] );\r\n\r\n\treturn function ( material ) {\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n/*\r\n * Custom update matrix\r\n */\r\n\r\nTHREE.Sprite.prototype.updateMatrix = function () {\r\n\r\n\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.__lights = [];\r\n\r\n\tthis.__objectsAdded = [];\r\n\tthis.__objectsRemoved = [];\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Scene.prototype.__addObject = function ( object ) {\r\n\r\n\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\r\n\r\n\t\t\tthis.__lights.push( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.target && object.target.parent === undefined ) {\r\n\r\n\t\t\tthis.add( object.target );\r\n\r\n\t\t}\r\n\r\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\r\n\r\n\t\tthis.__objectsAdded.push( object );\r\n\r\n\t\t// check if previously removed\r\n\r\n\t\tvar i = this.__objectsRemoved.indexOf( object );\r\n\r\n\t\tif ( i !== -1 ) {\r\n\r\n\t\t\tthis.__objectsRemoved.splice( i, 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.dispatchEvent( { type: 'objectAdded', object: object } );\r\n\tobject.dispatchEvent( { type: 'addedToScene', scene: this } );\r\n\r\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\r\n\r\n\t\tthis.__addObject( object.children[ c ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Scene.prototype.__removeObject = function ( object ) {\r\n\r\n\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\tvar i = this.__lights.indexOf( object );\r\n\r\n\t\tif ( i !== -1 ) {\r\n\r\n\t\t\tthis.__lights.splice( i, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.shadowCascadeArray ) {\r\n\r\n\t\t\tfor ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {\r\n\r\n\t\t\t\tthis.__removeObject( object.shadowCascadeArray[ x ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else if ( !( object instanceof THREE.Camera ) ) {\r\n\r\n\t\tthis.__objectsRemoved.push( object );\r\n\r\n\t\t// check if previously added\r\n\r\n\t\tvar i = this.__objectsAdded.indexOf( object );\r\n\r\n\t\tif ( i !== -1 ) {\r\n\r\n\t\t\tthis.__objectsAdded.splice( i, 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.dispatchEvent( { type: 'objectRemoved', object: object } );\r\n\tobject.dispatchEvent( { type: 'removedFromScene', scene: this } );\r\n\r\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\r\n\r\n\t\tthis.__removeObject( object.children[ c ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Scene.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Scene();\r\n\r\n\tTHREE.Object3D.prototype.clone.call(this, object);\r\n\r\n\tif ( this.fog !== null ) object.fog = this.fog.clone();\r\n\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\r\n\r\n\tobject.autoUpdate = this.autoUpdate;\r\n\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\r\n\r\n\tvar smoothstep = THREE.Math.smoothstep;\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _this = this,\r\n\t_renderData, _elements, _lights,\r\n\t_projector = new THREE.Projector(),\r\n\r\n\t_canvas = parameters.canvas !== undefined\r\n\t\t\t? parameters.canvas\r\n\t\t\t: document.createElement( 'canvas' ),\r\n\r\n\t_canvasWidth = _canvas.width,\r\n\t_canvasHeight = _canvas.height,\r\n\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),\r\n\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),\r\n\t\r\n\t_context = _canvas.getContext( '2d', {\r\n\t\talpha: parameters.alpha === true\r\n\t} ),\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0,\r\n\r\n\t_contextGlobalAlpha = 1,\r\n\t_contextGlobalCompositeOperation = 0,\r\n\t_contextStrokeStyle = null,\r\n\t_contextFillStyle = null,\r\n\t_contextLineWidth = null,\r\n\t_contextLineCap = null,\r\n\t_contextLineJoin = null,\r\n\t_contextDashSize = null,\r\n\t_contextGapSize = 0,\r\n\r\n\t_camera,\r\n\r\n\t_v1, _v2, _v3, _v4,\r\n\t_v5 = new THREE.RenderableVertex(),\r\n\t_v6 = new THREE.RenderableVertex(),\r\n\r\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\r\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\r\n\r\n\t_color = new THREE.Color(),\r\n\t_color1 = new THREE.Color(),\r\n\t_color2 = new THREE.Color(),\r\n\t_color3 = new THREE.Color(),\r\n\t_color4 = new THREE.Color(),\r\n\r\n\t_diffuseColor = new THREE.Color(),\r\n\t_emissiveColor = new THREE.Color(),\r\n\r\n\t_lightColor = new THREE.Color(),\r\n\r\n\t_patterns = {},\r\n\r\n\t_near, _far,\r\n\r\n\t_image, _uvs,\r\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\r\n\r\n\t_clipBox = new THREE.Box2(),\r\n\t_clearBox = new THREE.Box2(),\r\n\t_elemBox = new THREE.Box2(),\r\n\r\n\t_ambientLight = new THREE.Color(),\r\n\t_directionalLights = new THREE.Color(),\r\n\t_pointLights = new THREE.Color(),\r\n\r\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\r\n\t_normal = new THREE.Vector3(),\r\n\t_normalViewMatrix = new THREE.Matrix3(),\r\n\r\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\r\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\r\n\r\n\t_pixelMap = document.createElement( 'canvas' );\r\n\t_pixelMap.width = _pixelMap.height = 2;\r\n\r\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\r\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\r\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\r\n\r\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\r\n\t_pixelMapData = _pixelMapImage.data;\r\n\r\n\t_gradientMap = document.createElement( 'canvas' );\r\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\r\n\r\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\r\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\r\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\r\n\r\n\t_gradientMapQuality --; // Fix UVs\r\n\r\n\t// dash+gap fallbacks for Firefox and everything else\r\n\r\n\tif ( _context.setLineDash === undefined ) {\r\n\r\n\t\tif ( _context.mozDash !== undefined ) {\r\n\r\n\t\t\t_context.setLineDash = function ( values ) {\r\n\r\n\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_context.setLineDash = function () {}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.domElement = _canvas;\r\n\r\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\r\n\t\t\t\t? parameters.devicePixelRatio\r\n\t\t\t\t: self.devicePixelRatio !== undefined\r\n\t\t\t\t\t? self.devicePixelRatio\r\n\t\t\t\t\t: 1;\r\n\r\n\tthis.autoClear = true;\r\n\tthis.sortObjects = true;\r\n\tthis.sortElements = true;\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: {\r\n\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// WebGLRenderer compatibility\r\n\r\n\tthis.supportsVertexTextures = function () {};\r\n\tthis.setFaceCulling = function () {};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_canvasWidth = width * this.devicePixelRatio;\r\n\t\t_canvasHeight = height * this.devicePixelRatio;\r\n\r\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\r\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\r\n\r\n\t\t_canvas.width = _canvasWidth;\r\n\t\t_canvas.height = _canvasHeight;\r\n\r\n\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\t_clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t_clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\r\n\r\n\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\r\n\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\r\n\r\n\t\t_contextGlobalAlpha = 1;\r\n\t\t_contextGlobalCompositeOperation = 0;\r\n\t\t_contextStrokeStyle = null;\r\n\t\t_contextFillStyle = null;\r\n\t\t_contextLineWidth = null;\r\n\t\t_contextLineCap = null;\r\n\t\t_contextLineJoin = null;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\r\n\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\r\n\r\n\t};\r\n\r\n\tthis.setClearColorHex = function ( hex, alpha ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\r\n\t\tthis.setClearColor( hex, alpha );\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = function () {\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\tif ( _clearBox.empty() === false ) {\r\n\r\n\t\t\t_clearBox.intersect( _clipBox );\r\n\t\t\t_clearBox.expandByScalar( 2 );\r\n\r\n\t\t\tif ( _clearAlpha < 1 ) {\r\n\r\n\t\t\t\t_context.clearRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.min.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _clearAlpha > 0 ) {\r\n\r\n\t\t\t\tsetBlending( THREE.NormalBlending );\r\n\t\t\t\tsetOpacity( 1 );\r\n\r\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\r\n\r\n\t\t\t\t_context.fillRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.min.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_clearBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// compatibility\r\n\r\n\tthis.clearColor = function () {};\r\n\tthis.clearDepth = function () {};\r\n\tthis.clearStencil = function () {};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tTHREE.onerror( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClear === true ) this.clear();\r\n\r\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\r\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\r\n\t\t_elements = _renderData.elements;\r\n\t\t_lights = _renderData.lights;\r\n\t\t_camera = camera;\r\n\r\n\t\t_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );\r\n\r\n\t\t/* DEBUG\r\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\r\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\r\n\t\t*/\r\n\r\n\t\tcalculateLights();\r\n\r\n\t\tfor ( var e = 0, el = _elements.length; e < el; e ++ ) {\r\n\r\n\t\t\tvar element = _elements[ e ];\r\n\r\n\t\t\tvar material = element.material;\r\n\r\n\t\t\tif ( material === undefined || material.visible === false ) continue;\r\n\r\n\t\t\t_elemBox.makeEmpty();\r\n\r\n\t\t\tif ( element instanceof THREE.RenderableSprite ) {\r\n\r\n\t\t\t\t_v1 = element;\r\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\trenderSprite( _v1, element, material );\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [\r\n\t\t\t\t\t_v1.positionScreen,\r\n\t\t\t\t\t_v2.positionScreen\r\n\t\t\t\t] );\r\n\r\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableFace ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\tif ( material.overdraw > 0 ) {\r\n\r\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\r\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\r\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [\r\n\t\t\t\t\t_v1.positionScreen,\r\n\t\t\t\t\t_v2.positionScreen,\r\n\t\t\t\t\t_v3.positionScreen\r\n\t\t\t\t] );\r\n\r\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* DEBUG\r\n\t\t\tsetLineWidth( 1 );\r\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\r\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\r\n\t\t\t*/\r\n\r\n\t\t\t_clearBox.union( _elemBox );\r\n\r\n\t\t}\r\n\r\n\t\t/* DEBUG\r\n\t\tsetLineWidth( 1 );\r\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\r\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\r\n\t\t*/\r\n\r\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction calculateLights() {\r\n\r\n\t\t_ambientLight.setRGB( 0, 0, 0 );\r\n\t\t_directionalLights.setRGB( 0, 0, 0 );\r\n\t\t_pointLights.setRGB( 0, 0, 0 );\r\n\r\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = _lights[ l ];\r\n\t\t\tvar lightColor = light.color;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\t_ambientLight.add( lightColor );\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t// for sprites\r\n\r\n\t\t\t\t_directionalLights.add( lightColor );\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\t// for sprites\r\n\r\n\t\t\t\t_pointLights.add( lightColor );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction calculateLight( position, normal, color ) {\r\n\r\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = _lights[ l ];\r\n\r\n\t\t\t_lightColor.copy( light.color );\r\n\r\n\t\t\tif ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\r\n\r\n\t\t\t\tvar amount = normal.dot( lightPosition );\r\n\r\n\t\t\t\tif ( amount <= 0 ) continue;\r\n\r\n\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\r\n\r\n\t\t\t\tif ( amount <= 0 ) continue;\r\n\r\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\r\n\r\n\t\t\t\tif ( amount == 0 ) continue;\r\n\r\n\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderSprite( v1, element, material ) {\r\n\r\n\t\tsetOpacity( material.opacity );\r\n\t\tsetBlending( material.blending );\r\n\r\n\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\r\n\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\r\n\r\n\t\tvar dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite\r\n\t\t_elemBox.min.set( v1.x - dist, v1.y - dist );\r\n\t\t_elemBox.max.set( v1.x + dist, v1.y + dist );\r\n\r\n\t\tif ( material instanceof THREE.SpriteMaterial ||\r\n\t\t\t material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility\r\n\r\n\t\t\tvar texture = material.map;\r\n\r\n\t\t\tif ( texture !== null ) {\r\n\r\n\t\t\t\tif ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {\r\n\r\n\t\t\t\t\tif ( texture.image !== undefined && texture.image.width > 0 ) {\r\n\r\n\t\t\t\t\t\ttextureToPattern( texture );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'update', onTextureUpdate );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pattern = _patterns[ texture.id ];\r\n\r\n\t\t\t\tif ( pattern !== undefined ) {\r\n\r\n\t\t\t\t\tsetFillStyle( pattern );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetFillStyle( 'rgba( 0, 0, 0, 1 )' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tvar bitmap = texture.image;\r\n\r\n\t\t\t\tvar ox = bitmap.width * texture.offset.x;\r\n\t\t\t\tvar oy = bitmap.height * texture.offset.y;\r\n\r\n\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\r\n\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\r\n\r\n\t\t\t\tvar cx = scaleX / sx;\r\n\t\t\t\tvar cy = scaleY / sy;\r\n\r\n\t\t\t\t_context.save();\r\n\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\r\n\t\t\t\t_context.translate( - scaleX / 2, - scaleY / 2 );\r\n\t\t\t\t_context.scale( cx, cy );\r\n\t\t\t\t_context.translate( - ox, - oy );\r\n\t\t\t\t_context.fillRect( ox, oy, sx, sy );\r\n\t\t\t\t_context.restore();\r\n\r\n\t\t\t} else { // no texture\r\n\r\n\t\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t\t_context.save();\r\n\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\r\n\t\t\t\t_context.scale( scaleX, - scaleY );\r\n\t\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\r\n\t\t\t\t_context.restore();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material instanceof THREE.SpriteCanvasMaterial ) {\r\n\r\n\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\r\n\t\t\t_context.scale( scaleX, scaleY );\r\n\r\n\t\t\tmaterial.program( _context );\r\n\r\n\t\t\t_context.restore();\r\n\r\n\t\t}\r\n\r\n\t\t/* DEBUG\r\n\t\tsetStrokeStyle( 'rgb(255,255,0)' );\r\n\t\t_context.beginPath();\r\n\t\t_context.moveTo( v1.x - 10, v1.y );\r\n\t\t_context.lineTo( v1.x + 10, v1.y );\r\n\t\t_context.moveTo( v1.x, v1.y - 10 );\r\n\t\t_context.lineTo( v1.x, v1.y + 10 );\r\n\t\t_context.stroke();\r\n\t\t*/\r\n\r\n\t}\r\n\r\n\tfunction renderLine( v1, v2, element, material ) {\r\n\r\n\t\tsetOpacity( material.opacity );\r\n\t\tsetBlending( material.blending );\r\n\r\n\t\t_context.beginPath();\r\n\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\r\n\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\r\n\r\n\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\tsetLineCap( material.linecap );\r\n\t\t\tsetLineJoin( material.linejoin );\r\n\r\n\t\t\tif ( material.vertexColors !== THREE.VertexColors ) {\r\n\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar colorStyle1 = element.vertexColors[0].getStyle();\r\n\t\t\t\tvar colorStyle2 = element.vertexColors[1].getStyle();\r\n\r\n\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\r\n\r\n\t\t\t\t\tsetStrokeStyle( colorStyle1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\tvar grad = _context.createLinearGradient(\r\n\t\t\t\t\t\t\tv1.positionScreen.x,\r\n\t\t\t\t\t\t\tv1.positionScreen.y,\r\n\t\t\t\t\t\t\tv2.positionScreen.x,\r\n\t\t\t\t\t\t\tv2.positionScreen.y\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\r\n\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\r\n\r\n\t\t\t\t\t} catch ( exception ) {\r\n\r\n\t\t\t\t\t\tgrad = colorStyle1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsetStrokeStyle( grad );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_context.stroke();\r\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\tsetLineCap( material.linecap );\r\n\t\t\tsetLineJoin( material.linejoin );\r\n\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\r\n\r\n\t\t\t_context.stroke();\r\n\r\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t\tsetDashAndGap( null, null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\r\n\r\n\t\t_this.info.render.vertices += 3;\r\n\t\t_this.info.render.faces ++;\r\n\r\n\t\tsetOpacity( material.opacity );\r\n\t\tsetBlending( material.blending );\r\n\r\n\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\r\n\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\r\n\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\r\n\r\n\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\r\n\r\n\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshPhysicalMaterial ) && material.map === null ) {\r\n\r\n\t\t\t_diffuseColor.copy( material.color );\r\n\t\t\t_emissiveColor.copy( material.emissive );\r\n\r\n\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {\r\n\r\n\t\t\t\t_color1.copy( _ambientLight );\r\n\t\t\t\t_color2.copy( _ambientLight );\r\n\t\t\t\t_color3.copy( _ambientLight );\r\n\r\n\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\r\n\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\r\n\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\r\n\r\n\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\r\n\r\n\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\r\n\r\n\t\t\t\t\t_uvs = element.uvs[ 0 ];\r\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t} else if ( material.envMap !== null ) {\r\n\r\n\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\r\n\r\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t\t_uv1x = 0.5 * _normal.x + 0.5;\r\n\t\t\t\t\t_uv1y = 0.5 * _normal.y + 0.5;\r\n\r\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t\t_uv2x = 0.5 * _normal.x + 0.5;\r\n\t\t\t\t\t_uv2y = 0.5 * _normal.y + 0.5;\r\n\r\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t\t_uv3x = 0.5 * _normal.x + 0.5;\r\n\t\t\t\t\t_uv3y = 0.5 * _normal.y + 0.5;\r\n\r\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\r\n\r\n\t\t\t\t}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {\r\n\r\n\r\n\r\n\t\t\t\t}*/\r\n\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_color.copy( material.color );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t_near = _camera.near;\r\n\t\t\t_far = _camera.far;\r\n\r\n\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\r\n\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\r\n\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\r\n\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\tif ( material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\t_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t\t_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t} else if ( material.shading === THREE.SmoothShading ) {\r\n\r\n\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t_color1.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t_color2.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t_color3.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\r\n\r\n\t\t_context.beginPath();\r\n\t\t_context.moveTo( x0, y0 );\r\n\t\t_context.lineTo( x1, y1 );\r\n\t\t_context.lineTo( x2, y2 );\r\n\t\t_context.closePath();\r\n\r\n\t}\r\n\r\n\tfunction strokePath( color, linewidth, linecap, linejoin ) {\r\n\r\n\t\tsetLineWidth( linewidth );\r\n\t\tsetLineCap( linecap );\r\n\t\tsetLineJoin( linejoin );\r\n\t\tsetStrokeStyle( color.getStyle() );\r\n\r\n\t\t_context.stroke();\r\n\r\n\t\t_elemBox.expandByScalar( linewidth * 2 );\r\n\r\n\t}\r\n\r\n\tfunction fillPath( color ) {\r\n\r\n\t\tsetFillStyle( color.getStyle() );\r\n\t\t_context.fill();\r\n\r\n\t}\r\n\r\n\tfunction onTextureUpdate ( event ) {\r\n\r\n\t\ttextureToPattern( event.target );\r\n\r\n\t}\r\n\r\n\tfunction textureToPattern( texture ) {\r\n\r\n\t\tvar repeatX = texture.wrapS === THREE.RepeatWrapping;\r\n\t\tvar repeatY = texture.wrapT === THREE.RepeatWrapping;\r\n\r\n\t\tvar image = texture.image;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = image.width;\r\n\t\tcanvas.height = image.height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.setTransform( 1, 0, 0, - 1, 0, image.height );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\t_patterns[ texture.id ] = _context.createPattern(\r\n\t\t\tcanvas, repeatX === true && repeatY === true\r\n\t\t\t\t? 'repeat'\r\n\t\t\t\t: repeatX === true && repeatY === false\r\n\t\t\t\t\t? 'repeat-x'\r\n\t\t\t\t\t: repeatX === false && repeatY === true\r\n\t\t\t\t\t\t? 'repeat-y'\r\n\t\t\t\t\t\t: 'no-repeat'\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\r\n\r\n\t\tif ( texture instanceof THREE.DataTexture ) return;\r\n\r\n\t\tif ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {\r\n\r\n\t\t\tif ( texture.image !== undefined && texture.image.width > 0 ) {\r\n\r\n\t\t\t\ttextureToPattern( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.addEventListener( 'update', onTextureUpdate );\r\n\r\n\t\t}\r\n\r\n\t\tvar pattern = _patterns[ texture.id ];\r\n\r\n\t\tif ( pattern !== undefined ) {\r\n\r\n\t\t\tsetFillStyle( pattern );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsetFillStyle( 'rgba(0,0,0,1)' );\r\n\t\t\t_context.fill();\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\t\r\n\r\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\toffsetX = texture.offset.x / texture.repeat.x,\r\n\t\toffsetY = texture.offset.y / texture.repeat.y,\r\n\t\twidth = texture.image.width * texture.repeat.x,\r\n\t\theight = texture.image.height * texture.repeat.y;\r\n\r\n\t\tu0 = ( u0 + offsetX ) * width;\r\n\t\tv0 = ( v0 + offsetY ) * height;\r\n\r\n\t\tu1 = ( u1 + offsetX ) * width;\r\n\t\tv1 = ( v1 + offsetY ) * height;\r\n\r\n\t\tu2 = ( u2 + offsetX ) * width;\r\n\t\tv2 = ( v2 + offsetY ) * height;\r\n\r\n\t\tx1 -= x0; y1 -= y0;\r\n\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\tu1 -= u0; v1 -= v0;\r\n\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\tif ( det === 0 ) return;\r\n\r\n\t\tidet = 1 / det;\r\n\r\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\te = x0 - a * u0 - c * v0;\r\n\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t_context.save();\r\n\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t_context.fill();\r\n\t\t_context.restore();\r\n\r\n\t}\r\n\r\n\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\r\n\r\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\twidth = image.width - 1,\r\n\t\theight = image.height - 1;\r\n\r\n\t\tu0 *= width; v0 *= height;\r\n\t\tu1 *= width; v1 *= height;\r\n\t\tu2 *= width; v2 *= height;\r\n\r\n\t\tx1 -= x0; y1 -= y0;\r\n\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\tu1 -= u0; v1 -= v0;\r\n\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\tidet = 1 / det;\r\n\r\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\te = x0 - a * u0 - c * v0;\r\n\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t_context.save();\r\n\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t_context.clip();\r\n\t\t_context.drawImage( image, 0, 0 );\r\n\t\t_context.restore();\r\n\r\n\t}\r\n\r\n\tfunction getGradientTexture( color1, color2, color3, color4 ) {\r\n\r\n\t\t// http://mrdoob.com/blog/post/710\r\n\r\n\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\r\n\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\r\n\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\r\n\r\n\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\r\n\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\r\n\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\r\n\r\n\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\r\n\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\r\n\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\r\n\r\n\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\r\n\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\r\n\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\r\n\r\n\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\r\n\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\r\n\r\n\t\treturn _gradientMap;\r\n\r\n\t}\r\n\r\n\t// Hide anti-alias gaps\r\n\r\n\tfunction expand( v1, v2, pixels ) {\r\n\r\n\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\r\n\t\tdet = x * x + y * y, idet;\r\n\r\n\t\tif ( det === 0 ) return;\r\n\r\n\t\tidet = pixels / Math.sqrt( det );\r\n\r\n\t\tx *= idet; y *= idet;\r\n\r\n\t\tv2.x += x; v2.y += y;\r\n\t\tv1.x -= x; v1.y -= y;\r\n\r\n\t}\r\n\r\n\t// Context cached methods.\r\n\r\n\tfunction setOpacity( value ) {\r\n\r\n\t\tif ( _contextGlobalAlpha !== value ) {\r\n\r\n\t\t\t_context.globalAlpha = value;\r\n\t\t\t_contextGlobalAlpha = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setBlending( value ) {\r\n\r\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\r\n\r\n\t\t\tif ( value === THREE.NormalBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\r\n\r\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\r\n\r\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'darker';\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_contextGlobalCompositeOperation = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineWidth( value ) {\r\n\r\n\t\tif ( _contextLineWidth !== value ) {\r\n\r\n\t\t\t_context.lineWidth = value;\r\n\t\t\t_contextLineWidth = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineCap( value ) {\r\n\r\n\t\t// \"butt\", \"round\", \"square\"\r\n\r\n\t\tif ( _contextLineCap !== value ) {\r\n\r\n\t\t\t_context.lineCap = value;\r\n\t\t\t_contextLineCap = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineJoin( value ) {\r\n\r\n\t\t// \"round\", \"bevel\", \"miter\"\r\n\r\n\t\tif ( _contextLineJoin !== value ) {\r\n\r\n\t\t\t_context.lineJoin = value;\r\n\t\t\t_contextLineJoin = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setStrokeStyle( value ) {\r\n\r\n\t\tif ( _contextStrokeStyle !== value ) {\r\n\r\n\t\t\t_context.strokeStyle = value;\r\n\t\t\t_contextStrokeStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setFillStyle( value ) {\r\n\r\n\t\tif ( _contextFillStyle !== value ) {\r\n\r\n\t\t\t_context.fillStyle = value;\r\n\t\t\t_contextFillStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\r\n\r\n\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\r\n\r\n\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\r\n\t\t\t_contextDashSize = dashSizeValue;\r\n\t\t\t_contextGapSize = gapSizeValue;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * Shader chunks for WebLG Shader library\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author bhouston / http://clara.io/\r\n */\r\n\r\nTHREE.ShaderChunk = {\r\n\r\n\t// FOG\r\n\r\n\tcommon: [\r\n\r\n\t\t\"#define PI 3.14159\",\r\n\t\t\"#define PI2 6.28318\",\r\n\t\t\"#define LOG2 1.442695\",\r\n\t\t\"#define ENCODING_Linear 3000\",\r\n\t\t\"#define ENCODING_sRGB 3001\",\r\n\t\t\"#define ENCODING_RGBE 3002\",\r\n\t\t\"#define ENCODING_RGBM7 3004\",\r\n\t\t\"#define ENCODING_RGBM16 3005\",\r\n\t\t\"#define SPECULAR_COEFF 0.18\",\r\n\t\t\"float square( float a ) { return a*a; }\",\r\n\t\t\"vec2  square( vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\",\r\n\t\t\"vec3  square( vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\",\r\n\t\t\"vec4  square( vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\",\r\n\t\t\"float saturate( float a ) { return clamp( a, 0.0, 1.0 ); }\",\r\n\t\t\"vec2  saturate( vec2 a )  { return clamp( a, 0.0, 1.0 ); }\",\r\n\t\t\"vec3  saturate( vec3 a )  { return clamp( a, 0.0, 1.0 ); }\",\r\n\t\t\"vec4  saturate( vec4 a )  { return clamp( a, 0.0, 1.0 ); }\",\r\n\t\t\"float average( float a ) { return a; }\",\r\n\t\t\"float average( vec2 a )  { return ( a.x + a.y) * 0.5; }\",\r\n\t\t\"float average( vec3 a )  { return ( a.x + a.y + a.z) * 0.3333333333; }\",\r\n\t\t\"float average( vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\",\r\n\t\t\"float whiteCompliment( float a ) { return saturate( 1.0 - a ); }\",\r\n\t\t\"vec2  whiteCompliment( vec2 a )  { return saturate( vec2(1.0) - a ); }\",\r\n\t\t\"vec3  whiteCompliment( vec3 a )  { return saturate( vec3(1.0) - a ); }\",\r\n\t\t\"vec4  whiteCompliment( vec4 a )  { return saturate( vec4(1.0) - a ); }\",\r\n\t\t\"vec3 projectOnPlane( vec3 point, vec3 pointOnPlane, vec3 planeNormal) {\",\r\n    \t\t\"float distance = dot( planeNormal, point-pointOnPlane );\",\r\n    \t\t\"return point - distance * planeNormal;\",\r\n\t\t\"}\",\r\n\t\t\"float sideOfPlane( vec3 point, vec3 pointOnPlane, vec3 planeNormal ) {\",\r\n   \t\t\t\"return sign( dot( point - pointOnPlane, planeNormal ) );\",\r\n\t\t\"}\",\r\n\t\t\"vec2 applyUVOffsetRepeat( vec2 uv, vec4 offsetRepeat ) {\",\r\n    \t\t\"return uv * offsetRepeat.zw + offsetRepeat.xy;\",\r\n\t\t\"}\",\r\n\t\t\"vec3 linePlaneIntersect( vec3 pointOnLine, vec3 lineDirection, vec3 pointOnPlane, vec3 planeNormal ) {\",\r\n   \t\t\t\"return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\",\r\n\t\t\"}\",\r\n\t\t\"vec4 applyGainBrightness( vec4 texel, vec4 gainBrightnessCoeff ) {\",\r\n\t\t\t\"if( gainBrightnessCoeff.w < 0.0 ) {\",\r\n\t\t\t\t\"texel.xyz = whiteCompliment( texel.xyz );\",\r\n\t\t\t\"}\",\r\n\t\t\t\"texel.xyz = ( texel.xyz - vec3( gainBrightnessCoeff.x ) ) * gainBrightnessCoeff.y + vec3( gainBrightnessCoeff.z + gainBrightnessCoeff.x );\",\r\n\t\t\t\"return texel;\",\r\n\t\t\"}\",\r\n\t\t\"vec4 texelDecode( vec4 texel, int encoding ) {\",\r\n\r\n\t\t\t\"if( encoding == 3001 ) {\",\t// sRGB\r\n\t\t\t\t\"texel = vec4( pow( max( texel.xyz, vec3( 0.0 ) ), vec3( 2.2 ) ), texel.w );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"else if( encoding == 3002 ) {\",\t// RGBE / Radiance\r\n\t\t\t\t\"texel = vec4( texel.xyz * pow( 2.0, texel.w*256.0 - 128.0 ), 1.0 );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t// TODO LogLUV decoding.\r\n\r\n\t\t\t\"else if( encoding == 3004 ) {\", // RGBM 7.0 / Marmoset\r\n\t\t\t\t\"texel = vec4( texel.xyz * texel.w * 7.0, 1.0 );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"else if( encoding == 3005 ) {\", // RGBM 16\r\n\t\t\t\t\"texel = vec4( texel.xyz * texel.w * 16.0, 1.0 );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"return texel;\",\r\n\t\t\"}\",\r\n\t].join(\"\\n\"),\r\n\r\n\t// FOG\r\n\r\n\tfog_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_FOG\",\r\n\r\n\t\t\t\"uniform vec3 fogColor;\",\r\n\r\n\t\t\t\"#ifdef FOG_EXP2\",\r\n\r\n\t\t\t\t\"uniform float fogDensity;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"uniform float fogNear;\",\r\n\t\t\t\t\"uniform float fogFar;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfog_fragment: [\r\n\r\n\t\t\"#ifdef USE_FOG\",\r\n\r\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"#ifdef FOG_EXP2\",\r\n\r\n\t\t\t\t\"float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\",\r\n\t\t\t\t\"fogFactor = 1.0 - saturate( fogFactor );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// DIFFUSE ENVIRONMENT MAP\r\n\r\n\tdiffuseenvmap_pars_fragment: [\r\n\r\n\t\t\"#if defined( USE_DIFFUSEENVMAP )\",\r\n\r\n\t\t\t\"uniform samplerCube diffuseEnvMap;\",\r\n\t\t\t\"uniform int diffuseEnvEncoding;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ENVIRONMENT MAP\r\n\r\n\tenvmap_pars_fragment: [\r\n\r\n\t\t\"#if defined( USE_DIFFUSEENVMAP ) || defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\"uniform float flipEnvMap;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\"uniform float reflectivity;\",\r\n\t\t\t\"uniform samplerCube envMap;\",\r\n\t\t\t\"uniform int combine;\",\r\n\t\t\t\"uniform int envEncoding;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_fragment: [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( PHYSICAL )\",\r\n\r\n\t\t\t\"vec3 worldNormal = vec3( normalize( ( vec4( normal, 0.0 ) * viewMatrix ).xyz ) );\",\r\n\t\t\t\"vec3 worldView = -vec3( normalize( ( vec4( viewDirection, 0.0 ) * viewMatrix ).xyz ) );\",\r\n\r\n\t\t\t\"vec3 reflectVec = reflect( worldView, worldNormal );\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"cubeColor = texelDecode( cubeColor, envEncoding );\",\r\n\r\n\t\t\t\"float fresnelReflectivity = saturate( reflectivity );\",\r\n\r\n\t\t\t\"if ( combine == 1 ) {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, fresnelReflectivity );\",\r\n\r\n\t\t\t\"} else if ( combine == 2 ) {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * fresnelReflectivity;\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, fresnelReflectivity );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tworldpos_vertex : [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\r\n\r\n\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// COLOR MAP (particles)\r\n\r\n\tmap_particle_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tmap_particle_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texelDecode( texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) ), ENCODING_sRGB );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// COLOR MAP (triangles)\r\n\r\n\tmap_pars_vertex: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_pars_fragment: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\t\t\t\"uniform vec4 offsetRepeat;\",\r\n\t\t\t\"uniform vec4 gainBrightness;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_vertex: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_fragment: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_FALLOFFMAP )\",\r\n\r\n\t\t\t\"vec2 vUvLocal = applyUVOffsetRepeat( vUv, offsetRepeat );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"vec4 texelColor = clamp( applyGainBrightness( texelDecode( texture2D( map, vUvLocal ), ENCODING_sRGB ), gainBrightness ), vec4(0.0), vec4(1.0) );\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\r\n\r\n\t\t\t\"#if defined( PHYSICAL ) || defined( PHONG )\",\r\n\r\n\t\t\t\t\"diffuseColor *= texelColor.xyz;\",\r\n\r\n\t\t\t\"#endif\", // PHYSICAL\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// FALLOFF MAP\r\n\r\n\tfalloffmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_FALLOFFMAP\",\r\n\r\n\t\t\t\"uniform sampler2D falloffMap;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// OPACITY MAP\r\n\r\n\topacitymap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_OPACITYMAP\",\r\n\r\n\t\t\t\"uniform sampler2D opacityMap;\",\r\n\t\t\t\"uniform vec4 opacityOffsetRepeat;\",\r\n\t\t\t\"uniform vec4 opacityGainBrightness;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\topacitymap_fragment: [\r\n\r\n\t\t\"#ifdef USE_OPACITYMAP\",\r\n\r\n\t\t\t\"vec2 vOpacityUv = applyUVOffsetRepeat( vUv, opacityOffsetRepeat );\",\r\n\t\t\t\"vec4 texelOpacity = applyGainBrightness( texture2D( opacityMap, vOpacityUv ), opacityGainBrightness );\",\r\n\r\n\t\t\t\"gl_FragColor.w = clamp( gl_FragColor.w * texelOpacity.r, 0.0, 1.0 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// TRANSLUCENCY MAP\r\n\r\n\ttranslucencymap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_TRANSLUCENCYMAP\",\r\n\r\n\t\t\t\"uniform sampler2D translucencyMap;\",\r\n\t\t\t\"uniform vec4 translucencyOffsetRepeat;\",\r\n\t\t\t\"uniform vec4 translucencyGainBrightness;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\ttranslucencymap_fragment: [\r\n\r\n\t\t\"#ifdef USE_TRANSLUCENCYMAP\",\r\n\r\n\t\t\t\"vec2 vTranslucencyUv = applyUVOffsetRepeat( vUv, translucencyOffsetRepeat );\",\r\n\t\t\t\"vec4 texelTranslucency = applyGainBrightness( texture2D( translucencyMap, vTranslucencyUv ), translucencyGainBrightness );\",\r\n\r\n\t\t\t\"translucencyColor.xyz = clamp( translucencyColor.xyz * texelTranslucency.xyz, vec3( 0.0 ), vec3( 1.0 ) );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHT MAP\r\n\r\n\tlightmap_pars_fragment: [\r\n\r\n\t\t\"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv2;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if defined( USE_LIGHTMAP )\",\r\n\r\n\t\t\t\"uniform sampler2D lightMap;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if defined( USE_EMISSIVEMAP )\",\r\n\r\n\t\t\t\"uniform sampler2D emissiveMap;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_pars_vertex: [\r\n\r\n\t\t\"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv2;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t//\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_vertex: [\r\n\r\n\t\t\"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )\",\r\n\r\n\t\t\t\"vUv2 = uv2;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\t// BUMP MAP\r\n\r\n\tbumpmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_BUMPMAP\",\r\n\r\n\t\t\t\"uniform sampler2D bumpMap;\",\r\n\t\t\t\"uniform vec4 bumpOffsetRepeat;\",\r\n\t\t\t\"uniform float bumpScale;\",\r\n\r\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\r\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\r\n\r\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\r\n\r\n\t\t\t\"vec2 dHdxy_fwd() {\",\r\n\r\n\t\t\t\t\"#ifdef GL_OES_standard_derivatives\",\r\n\r\n\t\t\t\t\t\"vec2 vBumpUv = applyUVOffsetRepeat( vUv, bumpOffsetRepeat );\",\r\n\r\n\t\t\t\t\t\"vec2 dSTdx = dFdx( vBumpUv );\",\r\n\t\t\t\t\t\"vec2 dSTdy = dFdy( vBumpUv );\",\r\n\r\n\t\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vBumpUv ).x;\",\r\n\t\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vBumpUv + dSTdx ).x - Hll;\",\r\n\t\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vBumpUv + dSTdy ).x - Hll;\",\r\n\r\n\t\t\t\t\t\"return vec2( dBx, dBy );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"return vec2( 0.0, 0.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\r\n\r\n\t\t\t\t\"#ifdef GL_OES_standard_derivatives\",\r\n\r\n\t\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\r\n\t\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\r\n\t\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\r\n\r\n\t\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\r\n\t\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\r\n\r\n\t\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\r\n\r\n\t\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\r\n\t\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"return surf_norm;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHT ATTENUATION function\r\n\r\n\tlightattenuation_func_fragment: [\r\n\r\n\t\t\"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\",\r\n\t\t\t\"if ( decayExponent > 0.0 && cutoffDistance > 0.0 ) {\",\r\n\t\t\t  \"return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\",\r\n\t\t\t\"}\",\r\n\t\t\t\"else if ( decayExponent < 0.0 ) {\",\r\n\t\t\t\t// this is based upon UE4 light fall as described on page 11 of:\r\n\t\t\t\t//  https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\r\n\t\t\t\t\"float numerator = 1.0;\",\r\n\t\t\t\t\"if( cutoffDistance > 0.0 ) {\",\r\n\t\t\t\t\t\"numerator = ( saturate( 1.0 - pow( lightDistance / cutoffDistance, 4.0 ) ) );\",\r\n\t\t\t\t\t\"numerator *= numerator;\",\r\n\t\t\t\t\"} \",\r\n\t\t\t\t\"return numerator / ( ( lightDistance * lightDistance ) + 1.0 );\",\r\n\t\t\t\"}\",\r\n\t\t\t\"else {\",\r\n\t\t\t\t\"return 1.0;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t/*\"float distanceAttenuation = 1.0 / pow( max( lightDistance, 0.0 ), decayExponent );\",\r\n\t\t\t\"if ( cutoffDistance > 0.0 ) {\",\r\n\t\t\t\t\"distanceAttenuation *= 1.0 - min( lightDistance / cutoffDistance, 1.0 );\",\r\n\t\t\t\"}\",\r\n\t\t\t\"return distanceAttenuation;\",*/\r\n\t\t\"}\",\r\n\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// NORMAL MAP\r\n\r\n\tnormalmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"uniform sampler2D normalMap;\",\r\n\t\t\t\"uniform vec4 normalOffsetRepeat;\",\r\n\t\t\t\"uniform vec2 normalScale;\",\r\n\r\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\r\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\r\n\r\n\t\t\t\t\"#ifdef GL_OES_standard_derivatives\",\r\n\r\n\t\t\t\t\t\"vec2 vNormalUv = applyUVOffsetRepeat( vUv, normalOffsetRepeat );\",\r\n\r\n\t\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\r\n\t\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\r\n\t\t\t\t\t\"vec2 st0 = dFdx( vNormalUv.st );\",\r\n\t\t\t\t\t\"vec2 st1 = dFdy( vNormalUv.st );\",\r\n\r\n\t\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\r\n\t\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\r\n\t\t\t\t\t\"vec3 N = normalize( surf_norm );\",\r\n\r\n\t\t\t\t\t\"vec3 mapN = texture2D( normalMap, vNormalUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\r\n\t\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\r\n\t\t\t\t\t\"return normalize( tsn * mapN );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"return surf_norm;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ANISOTROPY MAP\r\n\r\n\tanisotropymap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_ANISOTROPYMAP\",\r\n\r\n\t\t\t\"uniform sampler2D anisotropyMap;\",\r\n\t\t\t\"uniform vec4 anisotropyGainBrightness;\",\r\n\t\t\t\"uniform vec4 anisotropyOffsetRepeat;\",\r\n\r\n\t\t\"#endif\"\r\n\t].join(\"\\n\"),\r\n\r\n\tanisotropymap_fragment: [\r\n\r\n\t\t\"#ifdef USE_ANISOTROPYMAP\",\r\n\r\n\t\t\t\"vec2 vAnisotropyUv = applyUVOffsetRepeat( vUv, anisotropyOffsetRepeat );\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"#ifdef ANISOTROPY\",\r\n\r\n\t\t\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )\",\r\n\r\n\t\t\t\t\t\"vec2 vAnisotropyUv = vUv;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vec2 vAnisotropyUv = vec2( 0, 0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"float anisotropyStrength = anisotropy;\",\r\n\r\n\t\t\"#ifdef USE_ANISOTROPYMAP\",\r\n\r\n\t\t\t\"vec4 texelAnisotropy = applyGainBrightness( texture2D( anisotropyMap, vAnisotropyUv ), anisotropyGainBrightness );\",\r\n\t\t\t\"anisotropyStrength = clamp( anisotropyStrength + texelAnisotropy.r, -1.0, 1.0 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ANISOTROPY ROTATION MAP\r\n\r\n\tanisotropyrotationmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_ANISOTROPYROTATIONMAP\",\r\n\r\n\t\t\t\"uniform sampler2D anisotropyRotationMap;\",\r\n\t\t\t\"uniform vec4 anisotropyRotationGainBrightness;\",\r\n\t\t\t\"uniform vec4 anisotropyRotationOffsetRepeat;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tanisotropyrotationmap_fragment: [\r\n\r\n\t\t\"float anisotropyRotationStrength = anisotropyRotation;\",\r\n\r\n\t\t\"#ifdef USE_ANISOTROPYROTATIONMAP\",\r\n\r\n\t\t\t\"vec2 vAnisotropyRotationUv = applyUVOffsetRepeat( vUv, anisotropyRotationOffsetRepeat );\",\r\n\t\t\t\"vec4 texelAnisotropyRotation = applyGainBrightness( texture2D( anisotropyRotationMap, vAnisotropyRotationUv ), anisotropyRotationGainBrightness );\",\r\n\t\t\t\"anisotropyRotationStrength += texelAnisotropyRotation.r;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// METALLIC MAP\r\n\r\n\tmetallicmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_METALLICMAP\",\r\n\r\n\t\t\t\"uniform sampler2D metallicMap;\",\r\n\t\t\t\"uniform vec4 metallicGainBrightness;\",\r\n\t\t\t\"uniform vec4 metallicOffsetRepeat;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmetallicmap_fragment: [\r\n\r\n\t\t\"float metallicStrength = metallic;\",\r\n\r\n\t\t\"#ifdef USE_METALLICMAP\",\r\n\r\n\t\t\t\"vec2 vMetallicUv = applyUVOffsetRepeat( vUv, metallicOffsetRepeat );\",\r\n\t\t\t\"vec4 texelMetallic = applyGainBrightness( texture2D( metallicMap, vMetallicUv ), metallicGainBrightness );\",\r\n\t\t\t\"metallicStrength = clamp( metallicStrength * texelMetallic.r, 0.0, 1.0 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ROUGHNESS MAP\r\n\r\n\troughnessmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_ROUGHNESSMAP\",\r\n\r\n\t\t\t\"uniform sampler2D roughnessMap;\",\r\n\t\t\t\"uniform vec4 roughnessOffsetRepeat;\",\r\n\t\t\t\"uniform vec4 roughnessGainBrightness;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\troughnessmap_fragment: [\r\n\r\n\t\t\"float roughnessStrength = roughness;\",\r\n\r\n\t\t\"#ifdef USE_ROUGHNESSMAP\",\r\n\r\n\t\t\t\"vec2 vRoughnessUv = applyUVOffsetRepeat( vUv, roughnessOffsetRepeat );\",\r\n\t\t\t\"vec4 texelRoughness = applyGainBrightness( texture2D( roughnessMap, vRoughnessUv ), roughnessGainBrightness );\",\r\n\t\t\t\"roughnessStrength = clamp( roughnessStrength * texelRoughness.r, 0.0, 1.0 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SPECULAR MAP\r\n\r\n\tspecularmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_SPECULARMAP\",\r\n\r\n\t\t\t\"uniform sampler2D specularMap;\",\r\n\t\t\t\"uniform vec4 specularGainBrightness;\",\r\n\t\t\t\"uniform vec4 specularOffsetRepeat;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tspecularmap_fragment: [\r\n\r\n\t\t\"#ifdef PHYSICAL\",\r\n\t\t\t\"vec3 specularColor = specular;\",\r\n\t\t\"#else\",\r\n\t\t\t\"float specularStrength = 1.0;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_SPECULARMAP\",\r\n\r\n\t\t\t\"vec2 vSpecularUv = applyUVOffsetRepeat( vUv, specularOffsetRepeat );\",\r\n\t\t\t\"vec4 texelSpecular = applyGainBrightness( texelDecode( texture2D( specularMap, vSpecularUv ), ENCODING_sRGB ), specularGainBrightness );\",\r\n\r\n\t\t\t\"#ifdef PHYSICAL\",\r\n\t\t\t\t\"specularColor.rgb = clamp( specularColor.rgb * texelSpecular.rgb, vec3( 0.0 ), vec3( 1.0 ) );\",\r\n\t\t\t\"#else\",\r\n\t\t\t\t\"specularStrength = clamp( specularStrength * texelSpecular.r, 0.0, 1.0 );\",\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS LAMBERT\r\n\r\n\tlights_lambert_pars_vertex: [\r\n\r\n\t\t\"uniform vec3 ambient;\",\r\n\t\t\"uniform vec3 diffuse;\",\r\n\t\t\"uniform vec3 emissive;\",\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_AREA_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_lambert_vertex: [\r\n\r\n\t\t\"vLightFront = vec3( 0.0 );\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"vLightBack = vec3( 0.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"transformedNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\r\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\r\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * distanceAttenuation;\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * distanceAttenuation;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * distanceAttenuation * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * distanceAttenuation * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\r\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vLightFront = ( vLightFront + ambientLightColor + ambient) * diffuse + emissive;\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"vLightBack = ( vLightFront + ambientLightColor + ambient) * diffuse + emissive;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS PHYSICAL\r\n\r\n\tlights_physical_pars_vertex: [\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tlights_physical_vertex: [\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\r\n\r\n\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\r\n\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\r\n\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_physical_pars_fragment: [\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_AREA_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\"varying vec3 vTangent;\",\r\n\t\t\"varying vec3 vBinormal;\",\r\n\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t// classic Fresnel Schlick\r\n\t\t/*\"float Fresnel_Schlick( float hDotV ) {\",\r\n\t\t\t\"float F0 = 0.04;\",\r\n\t\t\t\"return F0 + ( 1.0 - F0 ) * pow( 1.0 - hDotV, 5.0 );\",\r\n\t\t\"}\",*/\r\n\r\n\t\t// Calcuate the Fresnel term using the Schlick approximation (using Unreal's blend to white method)  VALIDATED\r\n\t\t\"vec3 Fresnel_Schlick_SpecularBlendToWhite(vec3 specularColor, float hDotV) {\",\r\n\t\t\t\"float Fc = pow(max( 1.0 - hDotV, 0.0 ), 5.0);\",\r\n    \t\t\"return saturate( 50.0 * average( specularColor ) ) * Fc + (1.0 - Fc) * specularColor;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec3 Fresnel_Schlick_SpecularBlendToWhiteRoughness(vec3 specularColor, float hDotV, float roughness) {\",\r\n\t\t\t\"float Fc = pow(max( 1.0 - hDotV, 0.0 ), 5.0) / ( 1.0 + 3.0 * roughness );\",\r\n\r\n    \t\t\"return mix( specularColor, vec3( saturate( 50.0 * average( specularColor ) ) ), Fc );\",\r\n\t\t\"}\",\r\n\r\n\t    // Calculate the distribution term  VALIDATED\r\n\t\t\"float Distribution_GGX( float roughness2, float nDotH ) {\",\r\n\t\t\t\"float denom = nDotH * nDotH * (roughness2 - 1.0) + 1.0;\",\r\n    \t\t\"return roughness2 / ( PI * square( denom ) + 0.0000001 );\",\r\n\t\t\"}\",\r\n\r\n\t\t// Calculated the anisotropic GGZ distrubtion term     VALIDATED\r\n\t\t\"float Distribution_GGXAniso( vec2 anisotropicM, vec2 xyDotH, float nDotH ) {\",\r\n    \t\t\"float anisoTerm = ( xyDotH.x * xyDotH.x / ( anisotropicM.x * anisotropicM.x ) + xyDotH.y * xyDotH.y / ( anisotropicM.y * anisotropicM.y ) + nDotH * nDotH );\",\r\n    \t\t\"return 1.0 / ( PI * anisotropicM.x * anisotropicM.y * anisoTerm * anisoTerm + 0.0000001 );\",\r\n\t\t\"}\",\r\n\r\n\t\t// useful for clear coat surfaces, use with Distribution_GGX.\r\n\t\t\"float Visibility_Kelemen( float vDotH ) {\",\r\n\t\t\t\"return 1.0 / ( 4.0 * vDotH * vDotH + 0.0000001 );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float Visibility_Schlick( float roughness2, float nDotL, float nDotV) {\",\r\n    \t\t\"float termL = (nDotL + sqrt(roughness2 + (1.0 - roughness2) * nDotL * nDotL));\",\r\n    \t\t\"float termV = (nDotV + sqrt(roughness2 + (1.0 - roughness2) * nDotV * nDotV));\",\r\n    \t\t\"return 1.0 / ( abs( termL * termV ) + 0.0000001 );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float Diffuse_Lambert() {\",\r\n    \t\t\"return 1.0 / PI;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float Diffuse_OrenNayer( float m2, float nDotV, float nDotL, float vDotH ) {\",\r\n\t\t\t\"float termA = 1.0 - 0.5 * m2 / (m2 + 0.33);\",\r\n\t\t\t\"float Cosri = 2.0 * vDotH - 1.0 - nDotV * nDotL;\",\r\n\t\t\t\"float termB = 0.45 * m2 / (m2 + 0.09) * Cosri * ( Cosri >= 0.0 ? min( 1.0, nDotL / nDotV ) : nDotL );\",\r\n\t\t\t\"return 1.0 / PI * ( nDotL * termA + termB );\",\r\n\t\t\"}\",\r\n\r\n\t\t// Helper for anisotropy rotation\r\n\t\t\"mat2 createRotationMat2( float rads) {\",\r\n\t\t\t\"float cos_rads = cos( rads );\",\r\n\t\t\t\"float sin_rads = sin( rads );\",\r\n    \t\t\"return mat2( vec2( cos_rads, sin_rads ), vec2( -sin_rads, cos_rads ) );\",\r\n\t\t\"}\",\r\n\r\n\t\t// Helper for anisotropy rotation\r\n\t\t\"vec2 calcAnisotropyUV( float anisotropyLocal) {\",\r\n\t\t\t\"float oneMinusAbsAnisotropy = 1.0 - min( abs( anisotropyLocal ) * 0.9, 0.9 );\",\r\n\t\t\t\"vec2 anisotropyUV = vec2 ( 1.0 / oneMinusAbsAnisotropy, oneMinusAbsAnisotropy );\",\r\n\t\t\t\"if( anisotropy < 0.0 ) {\",\r\n\t\t\t\t\"anisotropyUV.xy = anisotropyUV.yx;\", // swizzel\r\n\t\t\t\"}\",\r\n    \t\t\"return anisotropyUV;\",\r\n\t\t\"}\"\r\n\r\n\t\t//\"float horizonOcclusion( vec3 reflectionVector, vec3 originalNormal ) {\",\r\n\t\t//\t\"return quare( saturate( 1.0 + uHorizonOcclude*dot( dir, vertexNormal ) ) );\",\r\n\t\t//\"}\"\r\n\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_physical_fragment: [\r\n\r\n\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normal );\",\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"normal = perturbNormal2Arb( -vViewPosition, normal );\",\r\n\r\n\t\t\t/*\"vec3 normalTex = texture2D( normalMap, vNormalUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\"normalTex.xy *= normalScale;\",\r\n\t\t\t\"normalTex = perturbNormal2Arb( -viewDirection, normal );\",\r\n\r\n\t\t\t\"normal = tsb * normalTex;\",*/\r\n\r\n\t\t//\"vec3 originalNormal = normal;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef FALLOFF\",\r\n\r\n\t\t\t\"vec3 modulatedFalloffColor = falloffColor;\",\r\n\r\n\t\t\t\"#ifdef USE_FALLOFFMAP\",\r\n\r\n\t\t\t\t\"vec4 falloffTexelColor = texelDecode( texture2D( falloffMap, vUvLocal ), ENCODING_sRGB );\",\r\n\r\n\t\t\t\t\"modulatedFalloffColor = modulatedFalloffColor * falloffTexelColor.xyz;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"float fm = abs( dot( normal, viewDirection ) );\",\r\n\r\n\t\t\t// this is a hack, it needs to be fixed.\r\n\t\t\t\"fm = /*falloffBlendParams.x * fm + falloffBlendParams.y * */ ( fm * fm * ( 3.0 - 2.0 * fm ) );\",\r\n\r\n\t\t\t\"diffuseColor = mix( modulatedFalloffColor, diffuseColor, fm );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"float nDotV = saturate( dot( normal, viewDirection ) );\",\r\n\t\t\"float m2 = pow( clamp( roughnessStrength, 0.02, 1.0 ), 4.0 );\",\r\n\t\t// specular is scaled by 0.08 per Disney PBR recommendations.\r\n\t\t\"float m2ClearCoat = pow( clamp( clearCoatRoughness, 0.02, 1.0 ), 4.0 );\",\r\n\r\n\t\t\"specularColor = mix( specularColor * SPECULAR_COEFF, diffuseColor, metallicStrength );\",\r\n\t\t\"diffuseColor *= ( 1.0 - metallicStrength );\",\r\n\r\n\t\t\"#ifdef ANISOTROPY\",\r\n\r\n\t\t\t\"vec2 anisotropicM = calcAnisotropyUV( anisotropyStrength ) * sqrt( m2 );\",\r\n\r\n\t\t\t\"#ifdef ANISOTROPYROTATION\",\r\n\t\t\t\t\"mat2 anisotropicRotationMatrix = createRotationMat2( anisotropyRotationStrength * 2.0 * PI );\",\r\n    \t\t\"#endif\",\r\n\r\n\t\t\t\"vec3 anisotropicS = tsb[1];\",\t// binormal in eye space.\r\n\t\t\t\"vec3 anisotropicT = tsb[0];\",\t// tangent in eye space.\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 totalLighting  = vec3( 0.0 );\",\r\n\r\n\t\t\"#if ( defined( USE_ENVMAP ) || defined( USE_DIFFUSEENVMAP ) ) && defined( PHYSICAL )\",\r\n\r\n\t\t\t\"{\",\r\n\r\n\t\t\t\t\"vec3 worldNormal = vec3( normalize( ( vec4( normal, 0.0 ) * viewMatrix ).xyz ) );\",\r\n\t\t\t\t\"vec3 worldView = -vec3( normalize( ( vec4( viewDirection, 0.0 ) * viewMatrix ).xyz ) );\",\r\n\r\n\t\t\t\t\"vec3 reflectVec = reflect( worldView, worldNormal );\",\r\n\r\n\t\t\t\t\"vec3 hVector = normal;//normalize( viewDirection.xyz + lVector.xyz );\",\r\n\t\t\t\t\"float nDotH = saturate( dot( normal, normal ) );\",\r\n\t\t\t\t\"float hDotV = saturate( dot( normal, viewDirection ) );\",\r\n\t\t\t\t\"float nDotL = hDotV;//saturate( dot( normal, lVector ) );\",\r\n\r\n\r\n\t\t\t\t\"vec3 queryVector = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"queryVector *= ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vec3 worldEnvNormal = vec3( normalize( ( vec4( normal, 0.0 ) * viewMatrix ).xyz ) );\",\r\n\t\t\t\t\"worldEnvNormal = vec3( flipEnvMap * worldEnvNormal.x, worldEnvNormal.yz );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"worldEnvNormal *= ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// calculate diffuse map contribution\r\n\r\n\t\t\t\t\"vec4 diffuseEnvColor = vec4( 0.0, 0.0, 0.0, 1.0 );\",\r\n\r\n\t\t\t\t\"#if defined( USE_DIFFUSEENVMAP )\",\r\n\r\n\t\t\t\t\t\"diffuseEnvColor = texelDecode( textureCube( diffuseEnvMap, worldEnvNormal ), diffuseEnvEncoding );\",\r\n\r\n\t\t\t\t\"#elif defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\t\t\"#if defined( TEXTURE_CUBE_LOD_EXT )\",\r\n\r\n\t\t\t\t\t\t\"diffuseEnvColor = texelDecode( textureCubeLodEXT( envMap, worldEnvNormal, 9.5 ), envEncoding );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"diffuseEnvColor = texelDecode( textureCube( envMap, worldEnvNormal, 10.0 ), envEncoding );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// calculate specular map contribution\r\n\r\n\t\t\t\t\"vec4 specularEnvColor = vec4( 0.0, 0.0, 0.0, 1.0 );\",\r\n\r\n\t\t\t\t\"#if defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\t\t\"#if defined( TEXTURE_CUBE_LOD_EXT )\",\r\n\r\n\t\t\t\t\t\t\"float specularMIPLevel = 9.7925 - 0.5 * log2( 2.0 / ( roughness * roughness + 0.00001 ) - 1.0 );\",\r\n\t\t\t\t\t\t\"specularEnvColor = texelDecode( textureCubeLodEXT( envMap, queryVector, specularMIPLevel ), envEncoding );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"specularEnvColor = mix( texelDecode( textureCube( envMap, queryVector ), envEncoding ), texelDecode( textureCube( envMap, queryVector, 10.0 ), envEncoding ), roughnessStrength );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vec3 specClearCoat = vec3(0, 0, 0);\",\r\n\r\n\t\t\t\t\"#if defined( CLEARCOAT ) && defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\t\t\"#if defined( TEXTURE_CUBE_LOD_EXT )\",\r\n\r\n\t\t\t\t\t\t\"float clearCoatMIPLevel = 9.7925 - 0.5 * log2( 2.0 / ( clearCoatRoughness * clearCoatRoughness + 0.00001 ) - 1.0 );\",\r\n\t\t\t\t\t\t\"vec4 specularClearCoatEnvColor = texelDecode( textureCubeLodEXT( envMap, queryVector, clearCoatMIPLevel ), envEncoding );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"vec4 specularClearCoatEnvColor = mix( texelDecode( textureCube( envMap, queryVector ), envEncoding ), texelDecode( textureCube( envMap, queryVector, 10.0 ), envEncoding ), clearCoatRoughness );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhiteRoughness( vec3( SPECULAR_COEFF ), nDotL, m2ClearCoat );\",\r\n\t\t\t\t\t\"specClearCoat = specularClearCoatEnvColor.rgb * fresnelClearCoat;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t    \"vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhiteRoughness( specularColor, nDotL, m2 );\",\r\n\r\n\t\t\t    // Put it all together\r\n\t\t\t    \"vec3 spec = fresnelColor * specularEnvColor.rgb;\",\r\n\t\t\t    \"vec3 diff = diffuseColor * diffuseEnvColor.rgb;\",  // no Diffuse_Lambert() term, it is baked into irradiance.\r\n\r\n\t\t\t    \"vec3 shadingResult = spec + diff;\",\r\n\r\n\t\t\t    \"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"shadingResult = mix( shadingResult, specClearCoat, clearCoat );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\t\t\t\t\t\t\t    // diffuse\r\n\t\t\t\t\"totalLighting  += shadingResult;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );\",\r\n\r\n\t\t\t\t\"vec3 incidentLight = pointLightColor[ i ] * distanceAttenuation;\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"vec3 hVector = normalize( viewDirection.xyz + lVector.xyz );\",\r\n\t\t\t\t\"float nDotH = saturate( dot( normal, hVector ) );\",\r\n\t\t\t\t\"float nDotL = saturate( dot( normal, lVector ) );\",\r\n\t\t\t\t\"float hDotV = saturate( dot( hVector, viewDirection ) );\",\r\n\r\n\t\t\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );\",\r\n\t\t\t\t\t\"float visClearCoat = Visibility_Kelemen( hDotV );\",\r\n\t\t\t\t\t\"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( SPECULAR_COEFF ), hDotV );\",\r\n\t\t\t\t\t\"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef ANISOTROPY\",\r\n\r\n\t\t\t\t\t\"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef ANISOTROPYROTATION\",\r\n\t    \t\t\t\t\"xyDotH = anisotropicRotationMatrix * xyDotH;\",\r\n\t\t    \t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t    \"float d = Distribution_GGX( m2, nDotH );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"float vis = Visibility_Schlick(m2, nDotL, nDotV);\",\r\n\t\t\t    \"vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );\",\r\n\r\n\t\t\t    // Put it all together\r\n\t\t\t    \"vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;\",\r\n\t\t\t    \"vec3 diff = nDotL * Diffuse_Lambert() * diffuseColor;\",\r\n\r\n\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t    \"diff *= whiteCompliment( translucencyColor.xyz );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t    \"vec3 shadingResult = spec + diff;\",\r\n\r\n\t\t\t    \"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"shadingResult = mix( shadingResult, specClearCoat, clearCoat );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\t\t\t\t\t\t\t    // diffuse\r\n\t\t\t\t\"totalLighting  += incidentLight * shadingResult;\",\r\n\r\n\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t\t\"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );\",\r\n\r\n\t\t\t\t\t\"float viewNormalTL = mix( 1.0, pow( abs( dot( viewDirection.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );\",\r\n\r\n\t\t\t\t\t\"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );\",\r\n\r\n\t\t\t\t\"vec3 incidentLight = spotLightColor[ i ] * distanceAttenuation;\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] );\",\r\n\r\n\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\"incidentLight *= spotEffect;\",\r\n\r\n\t\t\t\t\t\"vec3 hVector = normalize( viewDirection.xyz + lVector.xyz );\",\r\n\t\t\t\t\t\"float nDotH = saturate( dot( normal, hVector ) );\",\r\n\t\t\t\t\t\"float nDotL = saturate( dot( normal, lVector ) );\",\r\n\t\t\t\t\t\"float hDotV = saturate( dot( hVector, viewDirection ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\t\"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );\",\r\n\t\t\t\t\t\t\"float visClearCoat = Visibility_Kelemen( hDotV );\",\r\n\t\t\t\t\t\t\"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( SPECULAR_COEFF ), hDotV );\",\r\n\t\t\t\t\t\t\"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#ifdef ANISOTROPY\",\r\n\r\n\t\t\t\t\t\t\"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef ANISOTROPYROTATION\",\r\n\t\t    \t\t\t\t\"xyDotH = anisotropicRotationMatrix * xyDotH;\",\r\n\t\t\t    \t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t    \"float d = Distribution_GGX( m2, nDotH );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"float vis = Visibility_Schlick(m2, nDotL, nDotV);\",\r\n\t\t\t\t    \"vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );\",\r\n\r\n\t\t   \t\t\t// Put it all together\r\n\t\t\t\t    \"vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;\",\r\n\t\t\t\t    \"vec3 diff = nDotL * Diffuse_Lambert() * diffuseColor;\",\r\n\r\n\t\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t\t    \"diff *= whiteCompliment( translucencyColor.xyz );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t    \"vec3 shadingResult = spec + diff;\",\r\n\r\n\t\t\t\t    \"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\t\"shadingResult = mix( shadingResult, specClearCoat, clearCoat );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\t\t\t\t\t\t\t\t    // diffuse\r\n\t\t\t\t\t\"totalLighting  += incidentLight * shadingResult;\",\r\n\r\n\t\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t\t\t\"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );\",\r\n\r\n\t\t\t\t\t\t\"float viewNormalTL = mix( 1.0, pow( abs( dot( viewDirection.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );\",\r\n\r\n\t\t\t\t\t\t\"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\"vec3 incidentLight = directionalLightColor[ i ];\",\r\n\r\n\t\t\t\t\"vec3 hVector = normalize( viewDirection.xyz + lVector.xyz );\",\r\n\t\t\t\t\"float nDotH = saturate( dot( normal, hVector ) );\",\r\n\t\t\t\t\"float nDotL = saturate( dot( normal, lVector ) );\",\r\n\t\t\t\t\"float hDotV = saturate( dot( hVector, viewDirection ) );\",\r\n\r\n\t\t\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );\",\r\n\t\t\t\t\t\"float visClearCoat = Visibility_Kelemen( hDotV );\",\r\n\t\t\t\t\t\"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( SPECULAR_COEFF ), hDotV );\",\r\n\t\t\t\t\t\"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef ANISOTROPY\",\r\n\r\n\t\t\t\t\t\"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef ANISOTROPYROTATION\",\r\n\t    \t\t\t\t\"xyDotH = anisotropicRotationMatrix * xyDotH;\",\r\n\t\t    \t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t    \"float d = Distribution_GGX( m2, nDotH );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"float vis = Visibility_Schlick(m2, nDotL, nDotV);\",\r\n\t\t\t    \"vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );\",\r\n\r\n\t   \t\t\t// Put it all together\r\n\t\t\t    \"vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;\",\r\n\t\t\t    \"vec3 diff = nDotL * Diffuse_Lambert() * diffuseColor;\",\r\n\r\n\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t    \"diff *= whiteCompliment( translucencyColor.xyz );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t    \"vec3 shadingResult = spec + diff;\",\r\n\r\n\t\t\t    \"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"shadingResult = mix( shadingResult, specClearCoat, clearCoat );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\t\t\t\t\t\t\t    // diffuse\r\n\t\t\t\t\"totalLighting  += incidentLight * shadingResult;\",\r\n\r\n\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t\t\"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );\",\r\n\r\n\t\t\t\t\t\"float viewNormalTL = mix( 1.0, pow( abs( dot( viewDirection.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );\",\r\n\r\n\t\t\t\t\t\"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float nDotL = dot( normal, lVector );\",\r\n\r\n\t\t\t\t// based on page 325 of Real-Time Rendering., equation (8.43)\r\n\t\t\t\t\"vec3 hemiColor = ( PI / 2.0 ) * ( ( 1.0 + nDotL ) * hemisphereLightSkyColor[ i ] + ( 1.0 - nDotL ) * hemisphereLightGroundColor[ i ] );\",\r\n\r\n\t\t\t\t\"totalLighting += diffuseColor * hemiColor;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_AREA_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec3 lPosition = ( viewMatrix * vec4( areaLightPosition[ i ], 1.0 ) ).xyz;\",\r\n\t\t\t\t//\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\"vec3 width = areaLightWidth[ i ];\",\r\n\t\t\t\t\"vec3 height = areaLightHeight[ i ];\",\r\n\t\t\t\t\"vec3 up = normalize( ( viewMatrix * vec4( height, 0.0 ) ).xyz );\",\r\n\t\t\t\t\"vec3 right = normalize( ( viewMatrix * vec4( width, 0.0 ) ).xyz );\",\r\n\t\t\t\t\"vec3 pnormal = normalize( cross( right, up ) );\",\r\n\r\n\t\t\t\t\"float widthScalar = length( width );\",\r\n\t\t\t\t\"float heightScalar = length( height );\",\r\n\r\n\t\t\t\t//project onto plane and calculate direction from center to the projection.\r\n\t\t\t\t\"vec3 projection = projectOnPlane( -vViewPosition.xyz, lPosition, pnormal );\",  // projection in plane\r\n\t\t\t\t\"vec3 dir = projection - lPosition;\",\r\n\r\n\t\t\t\t//calculate distance from area:\r\n\t\t\t\t\"vec2 diagonal = vec2( dot( dir, right ), dot( dir, up ) );\",\r\n\t\t\t\t\"vec2 nearest2D = vec2( clamp( diagonal.x, -widthScalar, widthScalar ), clamp( diagonal.y, -heightScalar, heightScalar ) );\",\r\n\t\t\t\t\"vec3 nearestPointInside = lPosition + ( right *nearest2D.x + up * nearest2D.y );\",\r\n\r\n\t\t\t\t\"vec3 lVector = ( nearestPointInside + vViewPosition.xyz );\",\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), areaLightDistance[ i ], areaLightDecayExponent[i] );\",\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"vec3 incidentLight = areaLightColor[ i ] * distanceAttenuation * 0.01;\", // the 0.01 is the area light intensity scaling.\r\n\r\n\t\t\t\t\"float nDotLDiffuse = saturate( dot( normal, lVector ) );\",\r\n\r\n\t\t   \t\t\"vec3 diff = Diffuse_Lambert() * diffuseColor * widthScalar * heightScalar;\",\r\n\r\n\t\t\t\t\"vec3 viewReflection = reflect( viewDirection.xyz, normal );\",\r\n\t\t\t\t\"vec3 reflectionLightPlaneIntersection = linePlaneIntersect( -vViewPosition.xyz, viewReflection, lPosition, pnormal );\",\r\n\r\n\t\t\t\t\"float specAngle = dot( viewReflection, pnormal );\",\r\n\r\n\t\t\t\t// && dot( -vViewPosition.xyz - areaLightPosition[ i ], -pnormal ) >= 0.0 \r\n\t\t\t\t\"if ( specAngle < 0.0 ) {\",\r\n\r\n\t\t\t\t\t\"vec3 dirSpec = reflectionLightPlaneIntersection - lPosition;\",\r\n\t\t\t\t\t\"vec2 dirSpec2D = vec2( dot( dirSpec, right ), dot( dirSpec, up ) );\",\r\n\t\t\t\t\t\"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -widthScalar, widthScalar ), clamp( dirSpec2D.y, -heightScalar, heightScalar ) );\",\r\n\t\t\t\t\t\"lVector = normalize( lPosition + ( right *nearestSpec2D.x + up * nearestSpec2D.y ) + vViewPosition.xyz );\",\r\n\r\n\t\t\t\t\"} else { \",\r\n\r\n\t\t\t\t\t\"lVector = vec3( 0 );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"vec3 hVector = normalize( viewDirection.xyz + lVector.xyz );\",\r\n\t\t\t\t\"float nDotH = saturate( dot( normal, hVector ) );\",\r\n\t\t\t\t\"float nDotL = saturate( dot( normal, lVector ) );\",\r\n\t\t\t\t\"float hDotV = saturate( dot( hVector, viewDirection ) );\",\r\n\r\n\t\t\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );\",\r\n\t\t\t\t\t\"float visClearCoat = Visibility_Kelemen( hDotV );\",\r\n\t\t\t\t\t\"vec3 fresnelClearCoat = Fresnel_Schlick_SpecularBlendToWhite( vec3( SPECULAR_COEFF ), hDotV );\",\r\n\t\t\t\t\t\"vec3 specClearCoat = clamp( nDotL * dClearCoat * visClearCoat, 0.0, 10.0 ) * fresnelClearCoat;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t    \"diff *= whiteCompliment( translucencyColor.xyz );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\t\"diff = mix( diff, specClearCoat, clearCoat );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\r\n\t\t\t\t\"#ifdef ANISOTROPY\",\r\n\r\n\t\t\t\t\t\"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef ANISOTROPYROTATION\",\r\n\t    \t\t\t\t\"xyDotH = anisotropicRotationMatrix * xyDotH;\",\r\n\t\t    \t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t    \"float d = Distribution_GGX( m2, nDotH );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"float vis = Visibility_Schlick(m2, nDotL, nDotV);\",\r\n\t\t\t    \"vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor, hDotV );\",\r\n\r\n\t   \t\t\t// Put it all together\r\n\t\t\t    \"vec3 spec = clamp( nDotL * d * vis, 0.0, 10.0 ) * fresnelColor;\",\r\n\r\n\t\t\t\t\"totalLighting  += incidentLight * spec;\",\r\n\t\t\t\t\"totalLighting  += incidentLight * nDotLDiffuse * diff;\",\r\n\r\n\t\t\t\t\"#ifdef TRANSLUCENCY\",\r\n\r\n\t\t\t\t\t\"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );\",\r\n\r\n\t\t\t\t\t\"float viewNormalTL = mix( 1.0, pow( abs( dot( viewDirection.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );\",\r\n\r\n\t\t\t\t\t\"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\"totalLighting += diffuseColor * ( ambientLightColor * ( 1.0 - clearCoat ) );\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"totalLighting += diffuseColor * ambientLightColor;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_FragColor.xyz += totalLighting;\",\r\n\r\n\t\t\"vec3 emissiveLocal = emissive;\",\r\n\r\n\t\t\"#ifdef USE_EMISSIVEMAP\",\r\n\r\n\t\t\t\"vec3 emissiveColor = texture2D( emissiveMap, vUv2 ).xyz;\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"emissiveColor *= emissiveColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"emissiveLocal *= emissiveColor;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_FragColor.xyz += emissiveLocal;\",\r\n\r\n\t\t\"vec3 ambientLocal = ambient;\",\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"vec3 ambientColor = texture2D( lightMap, vUv2 ).xyz;\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"ambientColor *= ambientColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"ambientLocal *= ambientColor;\",\r\n\r\n\t\t\t\"#ifdef CLEARCOAT\",\r\n\r\n\t\t\t\t\"ambientLocal *= ( 1.0 - clearCoat );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_FragColor.xyz += diffuseColor * ambientLocal;\",\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS PHONG\r\n\r\n\tlights_phong_pars_vertex: [\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tlights_phong_vertex: [\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\",\r\n\r\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_phong_pars_fragment: [\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_AREA_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];\",\r\n\t\t\t\"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\"varying vec3 vNormal;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_phong_fragment: [\r\n\r\n\t\t\"vec3 normal = normalize( vNormal );\",\r\n\t\t\"vec3 viewDirection = normalize( vViewPosition );\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"normal = perturbNormal2Arb( -vViewPosition, normal );\",\r\n\r\n\t\t\"#elif defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\r\n\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"pointDiffuse  += pointLightColor[ i ] * pointDiffuseWeight * distanceAttenuation;\",\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewDirection );\",\r\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float pointSpecularWeight = specularStrength * pow( max( pointDotNormalHalf, 0.0 ), shininess );\",\r\n\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\",\r\n\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * distanceAttenuation * specularNormalization;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] );\",\r\n\r\n\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"spotDiffuse += spotLightColor[ i ] * spotDiffuseWeight * distanceAttenuation * spotEffect;\",\r\n\r\n\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewDirection );\",\r\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * pow( max( spotDotNormalHalf, 0.0 ), shininess );\",\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\",\r\n\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * distanceAttenuation * specularNormalization * spotEffect;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"dirDiffuse  += directionalLightColor[ i ] * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewDirection );\",\r\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float dirSpecularWeight = specularStrength * pow( max( dirDotNormalHalf, 0.0 ), shininess );\",\r\n\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\r\n\r\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\",\r\n\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\r\n\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\"hemiDiffuse += hemiColor;\",\r\n\r\n\t\t\t\t// specular (sky light)\r\n\r\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewDirection );\",\r\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * pow( max( hemiDotNormalHalfSky, 0.0 ), shininess );\",\r\n\r\n\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewDirection );\",\r\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * pow( max( hemiDotNormalHalfGround, 0.0 ), shininess );\",\r\n\r\n\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\r\n\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\",\r\n\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\",\r\n\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_AREA_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 areaDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 areaSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec3 lPosition = ( viewMatrix * vec4( areaLightPosition[ i ], 1.0 ) ).xyz;\",\r\n\t\t\t\t//\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\"vec3 width = areaLightWidth[ i ];\",\r\n\t\t\t\t\"vec3 height = areaLightHeight[ i ];\",\r\n\t\t\t\t\"vec3 up = normalize( ( viewMatrix * vec4( height, 0.0 ) ).xyz );\",\r\n\t\t\t\t\"vec3 right = normalize( ( viewMatrix * vec4( width, 0.0 ) ).xyz );\",\r\n\t\t\t\t\"vec3 pnormal = normalize( cross( right, up ) );\",\r\n\r\n\t\t\t\t\"float widthScalar = length( width );\",\r\n\t\t\t\t\"float heightScalar = length( height );\",\r\n\r\n\t\t\t\t//project onto plane and calculate direction from center to the projection.\r\n\t\t\t\t\"vec3 projection = projectOnPlane( -vViewPosition.xyz, lPosition, pnormal );\",  // projection in plane\r\n\t\t\t\t\"vec3 dir = projection - lPosition;\",\r\n\r\n\t\t\t\t//calculate distance from area:\r\n\t\t\t\t\"vec2 diagonal = vec2( dot( dir, right ), dot( dir, up ) );\",\r\n\t\t\t\t\"vec2 nearest2D = vec2( clamp( diagonal.x, -widthScalar, widthScalar ), clamp( diagonal.y, -heightScalar, heightScalar ) );\",\r\n\t\t\t\t\"vec3 nearestPointInside = lPosition + ( right *nearest2D.x + up * nearest2D.y );\",\r\n\r\n\t\t\t\t\"vec3 lVector = ( nearestPointInside + vViewPosition.xyz );\",\r\n\t\t\t\t\"float distanceAttenuation = calcLightAttenuation( length( lVector ), areaLightDistance[ i ], areaLightDecayExponent[i] );\",\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"float nDotLDiffuse = saturate( dot( normal, lVector ) );\",\r\n\r\n\t\t\t\t\"vec3 viewReflection = reflect( viewDirection.xyz, normal );\",\r\n\t\t\t\t\"vec3 reflectionLightPlaneIntersection = linePlaneIntersect( -vViewPosition.xyz, viewReflection, lPosition, pnormal );\",\r\n\r\n\t\t\t\t\"float specAngle = dot( viewReflection, pnormal );\",\r\n\r\n\t\t\t\t\"if ( specAngle < 0.0 ) {\",\r\n\r\n\t\t\t\t\t\"vec3 dirSpec = reflectionLightPlaneIntersection - lPosition;\",\r\n\t\t\t\t\t\"vec2 dirSpec2D = vec2( dot( dirSpec, right ), dot( dirSpec, up ) );\",\r\n\t\t\t\t\t\"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -widthScalar, widthScalar ), clamp( dirSpec2D.y, -heightScalar, heightScalar ) );\",\r\n\t\t\t\t\t\"lVector = normalize( lPosition + ( right *nearestSpec2D.x + up * nearestSpec2D.y ) + vViewPosition.xyz );\",\r\n\r\n\t\t\t\t\"} else { \",\r\n\r\n\t\t\t\t\t\"lVector = vec3( 0 );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = nDotLDiffuse;\",\r\n\r\n\t\t\t\t\"float areaDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"areaDiffuse  += areaLightColor[ i ] * areaDiffuseWeight * distanceAttenuation * widthScalar * heightScalar * 0.01;\",  // the 0.01 is the area light intensity scaling.\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 areaHalfVector = normalize( lVector + viewDirection );\",\r\n\t\t\t\t\"float areaDotNormalHalf = max( dot( normal, areaHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float areaSpecularWeight = specularStrength * pow( max( areaDotNormalHalf, 0.0 ), shininess );\",\r\n\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, areaHalfVector ), 0.0 ), 5.0 );\",\r\n\t\t\t\t\"areaSpecular += schlick * areaLightColor[ i ] * areaSpecularWeight * areaDiffuseWeight * distanceAttenuation * specularNormalization * 0.01;\",  // the 0.01 is the area light intensity scaling.\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\r\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += dirDiffuse;\",\r\n\t\t\t\"totalSpecular += dirSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\r\n\t\t\t\"totalSpecular += hemiSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += pointDiffuse;\",\r\n\t\t\t\"totalSpecular += pointSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += spotDiffuse;\",\r\n\t\t\t\"totalSpecular += spotSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_AREA_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += areaDiffuse;\",\r\n\t\t\t\"totalSpecular += areaSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\t\t\"vec3 ambientLocal = ambient;\",\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"vec3 ambientColor = texture2D( lightMap, vUv2 ).xyz;\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"ambientColor *= ambientColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"ambientLocal *= ambientColor;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_FragColor.xyz = diffuseColor * ( totalDiffuse + ambientLightColor + ambientLocal ) + totalSpecular;\",\r\n\r\n\t\t\"vec3 emissiveLocal = emissive;\",\r\n\r\n\t\t\"#ifdef USE_EMISSIVEMAP\",\r\n\r\n\t\t\t\"vec3 emissiveColor = texture2D( emissiveMap, vUv2 ).xyz;\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"emissiveColor *= emissiveColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"emissiveLocal *= emissiveColor;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_FragColor.xyz += emissiveLocal.xyz;\",\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// VERTEX COLORS\r\n\r\n\tcolor_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tcolor_fragment: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tcolor_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tcolor_vertex: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"vColor = color * color;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"vColor = color;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SKINNING\r\n\r\n\tskinning_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"#ifdef BONE_TEXTURE\",\r\n\r\n\t\t\t\t\"uniform sampler2D boneTexture;\",\r\n\t\t\t\t\"uniform int boneTextureWidth;\",\r\n\t\t\t\t\"uniform int boneTextureHeight;\",\r\n\r\n\t\t\t\t\"mat4 getBoneMatrix( const float i ) {\",\r\n\r\n\t\t\t\t\t\"float j = i * 4.0;\",\r\n\t\t\t\t\t\"float x = mod( j, float( boneTextureWidth ) );\",\r\n\t\t\t\t\t\"float y = floor( j / float( boneTextureWidth ) );\",\r\n\r\n\t\t\t\t\t\"float dx = 1.0 / float( boneTextureWidth );\",\r\n\t\t\t\t\t\"float dy = 1.0 / float( boneTextureHeight );\",\r\n\r\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\r\n\r\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\r\n\r\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\r\n\r\n\t\t\t\t\t\"return bone;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\r\n\r\n\t\t\t\t\"mat4 getBoneMatrix( const float i ) {\",\r\n\r\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\r\n\t\t\t\t\t\"return bone;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinbase_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\r\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\r\n\t\t\t\"mat4 boneMatZ = getBoneMatrix( skinIndex.z );\",\r\n\t\t\t\"mat4 boneMatW = getBoneMatrix( skinIndex.w );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinning_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\"skinned      += boneMatY * skinVertex * skinWeight.y;\",\r\n\t\t\t\"skinned      += boneMatZ * skinVertex * skinWeight.z;\",\r\n\t\t\t\"skinned      += boneMatW * skinVertex * skinWeight.w;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// MORPHING\r\n\r\n\tmorphtarget_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmorphtarget_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\r\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\r\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\r\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\r\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\r\n\r\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\r\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\r\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\r\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"morphed += position;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tdefault_vertex : [\r\n\r\n\t\t\"vec4 mvPosition;\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_Position = projectionMatrix * mvPosition;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmorphnormal_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\r\n\r\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\r\n\r\n\t\t\t\"morphedNormal += normal;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinnormal_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\r\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tdefaultnormal_vertex: [\r\n\r\n\t\t\"vec3 objectNormal;\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\r\n\r\n\t\t\t\"objectNormal = morphedNormal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\r\n\r\n\t\t\t\"objectNormal = normal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef FLIP_SIDED\",\r\n\r\n\t\t\t\"objectNormal = -objectNormal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SHADOW MAP\r\n\r\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\r\n\t//  http://spidergl.org/example.php?id=6\r\n\t// \thttp://fabiensanglard.net/shadowmapping\r\n\r\n\tshadowmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"float unpackDepth( const vec4 rgba_depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\r\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\r\n\t\t\t\t\"return depth;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\r\n\r\n\t\t\t\t\"vec3 frustumColors[3];\",\r\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\r\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\r\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\"int inFrustumCount = 0;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"float fDepth;\",\r\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\r\n\r\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\r\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\r\n\r\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\r\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\r\n\r\n\t\t\t\t// don't shadow pixels outside of light frustum\r\n\t\t\t\t// use just first frustum (for cascades)\r\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\r\n\r\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\r\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\r\n\r\n\t\t\t\t\"if ( frustumTest ) {\",\r\n\r\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\r\n\r\n\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\r\n\r\n\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\"float shadow = 0.0;\",\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\r\n\t\t\t\t\t\t// must enroll loop manually\r\n\r\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\r\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\r\n\r\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\r\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\r\n\r\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\r\n\r\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\r\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"shadow /= 9.0;\",\r\n\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\r\n\r\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\r\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\r\n\r\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\r\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\r\n\r\n\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\r\n\r\n\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\"float shadow = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\r\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\r\n\r\n\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\r\n\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\r\n\r\n\t\t\t\t\t\t\"mat3 shadowKernel;\",\r\n\t\t\t\t\t\t\"mat3 depthKernel;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\r\n\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\r\n\r\n\t\t\t\t\t\t\"vec3 shadowZ = vec3( shadowCoord.z );\",\r\n\t\t\t\t\t\t\"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\",\r\n\t\t\t\t\t\t\"shadowKernel[0] *= vec3(0.25);\",\r\n\r\n\t\t\t\t\t\t\"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\",\r\n\t\t\t\t\t\t\"shadowKernel[1] *= vec3(0.25);\",\r\n\r\n\t\t\t\t\t\t\"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\",\r\n\t\t\t\t\t\t\"shadowKernel[2] *= vec3(0.25);\",\r\n\r\n\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\r\n\r\n\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\r\n\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\r\n\r\n\t\t\t\t\t\t\"vec4 shadowValues;\",\r\n\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\r\n\r\n\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\r\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\r\n\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\r\n\r\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\r\n\r\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\r\n\r\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\r\n\r\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\r\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\r\n\r\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t\t\t\"shadowColor *= shadowColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_vertex: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ALPHATEST\r\n\r\n\talphatest_fragment: [\r\n\r\n\t\t\"#ifdef ALPHATEST\",\r\n\r\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LINEAR SPACE\r\n\r\n\tlinear_to_gamma_fragment: [\r\n\r\n\t\t\"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n\r\n};\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar u, p, tmp, merged = {};\r\n\r\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\ttmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\r\n\r\n\t\tfor ( u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\"gainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\"emissiveMap\" : { type: \"t\", value: null },\r\n\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\"envEncoding\" : { type: \"i\", value: 0 },\r\n\t\t\"diffuseEnvMap\" : { type: \"t\", value: null },\r\n\t\t\"diffuseEnvEncoding\" : { type: \"i\", value: 0 },\r\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\r\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\r\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\t\t\"combine\" : { type: \"i\", value: 0 },\r\n\r\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\r\n\t},\r\n\r\n\tspecularmap: {\r\n\r\n\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\t\t\"specularOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\"specularGainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t},\r\n\r\n\tbumpmap: {\r\n\r\n\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }, // used instead of 'bumpGainBrightness'\r\n\t\t\"bumpOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\r\n\t},\r\n\r\n\topacitymap: {\r\n\r\n\t\t\"opacityMap\" : { type: \"t\", value: null },\r\n\t\t\"opacityOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\"opacityGainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }, // used instead of 'normalGainBrightness'\r\n\t\t\"normalOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\r\n\t},\r\n\r\n\tfog : {\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"pointLightDecayExponent\" : { type: \"fv1\", value: [] },\r\n\r\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightDecayExponent\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] },\r\n\r\n\t\t\"areaLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"areaLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"areaLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"areaLightDecayExponent\" : { type: \"fv1\", value: [] },\r\n\t\t\"areaLightWidth\" : { type: \"fv\", value: [] },\r\n\t\t\"areaLightHeight\" : { type: \"fv\", value: [] }\r\n\r\n\t},\r\n\r\n\tparticle: {\r\n\r\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tshadowmap: {\r\n\r\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author bhouston / http://clara.io/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\r\n\t'physical': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bumpmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\t//THREE.UniformsLib[ \"roughnessmap\" ],  TODO: Implement me!\r\n\t\t\t//THREE.UniformsLib[ \"metallicmap\" ],  TODO: Implement me!\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"opacitymap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"specularmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0xFFFFFF ) },\r\n\t\t\t\t\"falloffColor\" : { type: \"c\", value: new THREE.Color( 0xFFFFFF ) },\r\n\t\t\t\t\"falloffMap\" : { type: \"t\", value: null },\r\n\t\t\t\t\"falloffBlendParams\" : { type: \"v4\", value: new THREE.Vector4( 1, 0, 0, 1 ) },\r\n\r\n\t\t\t\t\"clearCoat\": { type: \"f\", value: 0.0 },\r\n\t\t\t\t\"clearCoatRoughness\": { type: \"f\", value: 0.25 },\r\n\r\n\t\t\t\t\"roughness\": { type: \"f\", value: 0.5 },\r\n\t\t\t\t\"roughnessMap\" : { type: \"t\", value: null },\r\n\t\t\t\t\"roughnessOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\t\t\"roughnessGainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t\t\t\t\"metallic\": { type: \"f\", value: 0.5 },\r\n\t\t\t\t\"metallicMap\" : { type: \"t\", value: null },\r\n\t\t\t\t\"metallicOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\t\t\"metallicGainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t\t\t\t\"anisotropy\": { type: \"f\", value: 0.0 },\r\n\t\t\t\t\"anisotropyMap\" : { type: \"t\", value: null },\r\n\t\t\t\t\"anisotropyOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\t\t\"anisotropyGainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t\t\t\t\"anisotropyRotation\": { type: \"f\", value: 0.0 },\r\n\t\t\t\t\"anisotropyRotationMap\" : { type: \"t\", value: null },\r\n\t\t\t\t\"anisotropyRotationOffsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\t\t\t\"anisotropyRotationGainBrightness\" : { type: \"v4\", value: new THREE.Vector4( 0, 1, 0, 1 ) },\r\n\r\n\t\t\t\t\"translucency\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"translucencyMap\" : { type: \"t\", value: null },\r\n\t\t\t\t\"translucencyNormalAlpha\": { type: \"f\", value: 0.75 },\r\n\t\t\t\t\"translucencyNormalPower\": { type: \"f\", value: 2.0 },\r\n\t\t\t\t\"translucencyViewAlpha\": { type: \"f\", value: 0.75 },\r\n\t\t\t\t\"translucencyViewPower\": { type: \"f\", value: 2.0 },\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"attribute vec4 tangent;\",\r\n\r\n\t\t\t\"#define PHONG\",\r\n\t\t\t\"#define PHYSICAL\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"roughnessmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"opacitymap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"anisotropymap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"anisotropyrotationmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"metallicmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"translucencymap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_physical_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"normalmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"roughnessmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"opacitymap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"anisotropymap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"anisotropyrotationmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"metallicmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"translucencymap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"bumpmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_physical_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"#ifdef TEXTURE_CUBE_LOD_EXT\",\r\n\t\t\t\t\"#extension GL_EXT_shader_texture_lod : enable\",\r\n\t\t\t\"#endif\",\r\n\t\t\t\"#define PHYSICAL\",\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform vec3 ambient;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 falloffColor;\",\r\n\t\t\t\"uniform vec4 falloffBlendParams;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float roughness;\",\r\n\t\t\t\"uniform float metallic;\",\r\n\t\t\t\"uniform float clearCoat;\",\r\n\t\t\t\"uniform float clearCoatRoughness;\",\r\n\r\n\t\t\t\"uniform vec3 translucency;\",\r\n\t\t\t\"uniform float translucencyNormalAlpha;\",\r\n\t\t\t\"uniform float translucencyNormalPower;\",\r\n\t\t\t\"uniform float translucencyViewPower;\",\r\n\t\t\t\"uniform float translucencyViewAlpha;\",\r\n\r\n\t\t\t\"uniform float anisotropy;\",\r\n\t\t\t\"uniform float anisotropyRotation;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"falloffmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"opacitymap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"translucencymap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"diffuseenvmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_physical_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"anisotropymap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"anisotropyrotationmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"metallicmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"roughnessmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"reflectivitymap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightattenuation_func_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 0.0 ), opacity );\",\r\n\t\t\t\t\"vec3 diffuseColor = diffuse;\",\r\n\t\t\t\t\"vec3 translucencyColor = translucency;\",\r\n\t\t\t\t\"vec3 normal = normalize( vNormal );\",\r\n\t\t\t\t\"vec3 viewDirection = normalize( vViewPosition );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"opacitymap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"anisotropymap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"anisotropyrotationmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"roughnessmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"metallicmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"translucencymap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"reflectivitymap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_physical_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\t\"gl_FragColor.xyz *= gl_FragColor.w;\",\t\t// premultipled, must be used with CustomBlender, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n\t\t\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define LAMBERT\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"varying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightattenuation_func_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"varying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\r\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\r\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\r\n\t\t\t\t\t\"else\",\r\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bumpmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"specularmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"opacitymap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"opacitymap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"normalmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"bumpmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"opacitymap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform vec3 ambient;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"opacitymap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightattenuation_func_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\r\n\t\t\t\t\"vec3 diffuseColor = diffuse;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"opacitymap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'particle_basic': {\r\n\r\n\t\tuniforms:  THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float size;\",\r\n\t\t\t\"uniform float scale;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\t\"#else\",\r\n\t\t\t\t\t\"gl_PointSize = size;\",\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\r\n\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float scale;\",\r\n\t\t\t\"attribute float lineDistance;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\t\"vLineDistance = scale * lineDistance;\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\"uniform float totalSize;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n\t\t\t\t\t\"discard;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float mNear;\",\r\n\t\t\t\"uniform float mFar;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\t\t\t\"float color = clamp( ( depth - mNear ) / ( mFar - mNear ), 0.0, 1.0 );\",\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tNormal map shader\r\n\t//\t\t- Blinn-Phong\r\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\r\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'normalmap' : {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\r\n\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\r\n\r\n\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\r\n\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\r\n\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\r\n\r\n\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\r\n\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\r\n\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\r\n\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\"specular\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\"ambient\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\"opacity\": { type: \"f\", value: 1 },\r\n\r\n\t\t\t\"useRefract\": { type: \"i\", value: 0 },\r\n\t\t\t\"refractionRatio\": { type: \"f\", value: 0.98 },\r\n\t\t\t\"reflectivity\": { type: \"f\", value: 0.5 },\r\n\r\n\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\r\n\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\r\n\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 ambient;\",\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform bool enableDiffuse;\",\r\n\t\t\t\"uniform bool enableSpecular;\",\r\n\t\t\t\"uniform bool enableAO;\",\r\n\t\t\t\"uniform bool enableReflection;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform sampler2D tNormal;\",\r\n\t\t\t\"uniform sampler2D tSpecular;\",\r\n\t\t\t\"uniform sampler2D tAO;\",\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\r\n\t\t\t\"uniform vec2 uNormalScale;\",\r\n\r\n\t\t\t\"uniform bool useRefract;\",\r\n\t\t\t\"uniform float refractionRatio;\",\r\n\t\t\t\"uniform float reflectivity;\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), opacity );\",\r\n\r\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\r\n\r\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\r\n\t\t\t\t\"normalTex = normalize( normalTex );\",\r\n\r\n\t\t\t\t\"if( enableDiffuse ) {\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableAO ) {\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\r\n\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableSpecular )\",\r\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\r\n\r\n\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\r\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\r\n\r\n\t\t\t\t\"#ifdef FLIP_SIDED\",\r\n\r\n\t\t\t\t\t\"finalNormal = -finalNormal;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\r\n\t\t\t\t\"vec3 viewDirection = normalize( vViewPosition );\",\r\n\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float pointDistance = 1.0;\",\r\n\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewDirection );\",\r\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// spot lights\r\n\r\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float spotDistance = 1.0;\",\r\n\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\r\n\r\n\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewDirection );\",\r\n\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewDirection );\",\r\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// hemisphere lights\r\n\r\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\r\n\r\n\t\t\t\t\t\t// specular (sky light)\r\n\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewDirection );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewDirection );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\r\n\r\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\r\n\t\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\r\n\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// all lights contribution summation\r\n\r\n\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += dirSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += pointSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += spotSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef METAL\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"if ( enableReflection ) {\",\r\n\r\n\t\t\t\t\t\"vec3 vReflect;\",\r\n\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\r\n\r\n\t\t\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, refractionRatio );\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"attribute vec4 tangent;\",\r\n\r\n\t\t\t\"uniform vec2 uOffset;\",\r\n\t\t\t\"uniform vec2 uRepeat;\",\r\n\r\n\t\t\t\"uniform bool enableDisplacement;\",\r\n\r\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\r\n\t\t\t\t\"uniform float uDisplacementScale;\",\r\n\t\t\t\t\"uniform float uDisplacementBias;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\r\n\t\t\t\t// normal, tangent and binormal vectors\r\n\r\n\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\r\n\r\n\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\r\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\r\n\r\n\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\r\n\r\n\t\t\t\t// displacement mapping\r\n\r\n\t\t\t\t\"vec3 displacedPosition;\",\r\n\r\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\t\"if ( enableDisplacement ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\r\n\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\r\n\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"displacedPosition = position;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t// shadows\r\n\r\n\t\t\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 },\r\n\t\t\t\t\t\"tEncoding\": { type: \"i\", value: 0 },\r\n\t\t\t\t\t\"blurring\": { type: \"f\", value: 0 }\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t  \"#ifdef TEXTURE_CUBE_LOD_EXT\",\r\n\t\t    \"#extension GL_EXT_shader_texture_lod : enable\",\r\n\t\t  \"#endif\",\r\n\r\n\t\t  THREE.ShaderChunk[ \"common\" ],\r\n\r\n\t\t  \"uniform samplerCube tCube;\",\r\n\t\t  \"uniform float tFlip;\",\r\n\t\t  \"uniform int tEncoding;\",\r\n\t\t  \"uniform float blurring;\",\r\n\r\n\t\t  \"varying vec3 vWorldPosition;\",\r\n\r\n\t\t  \"void main() {\",\r\n\r\n\t\t  \t\"vec3 queryVector = vec3( tFlip * vWorldPosition.x, vWorldPosition.yz );\",\r\n\r\n\t\t\t\"#if defined( TEXTURE_CUBE_LOD_EXT )\",\r\n\r\n\t\t\t\t\"vec4 color = textureCubeLodEXT( tCube, queryVector, blurring );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t    \"vec4 color = textureCube( tCube, queryVector );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t    \"color = texelDecode( color, tEncoding );\",\r\n\r\n\t\t    \"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t      \"color.xyz = sqrt( color.xyz );\",\r\n\r\n\t\t    \"#endif\",\r\n\r\n\t\t    \"gl_FragColor = color;\",\r\n\r\n\t\t  \"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t// Depth encoding into RGBA texture\r\n\t// \tbased on SpiderGL shadow map example\r\n\t// \t\thttp://spidergl.org/example.php?id=6\r\n\t// \toriginally from\r\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t// \tsee also here:\r\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\r\n\t'depthRGBA': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"vec4 pack_depth( const float depth ) {\",\r\n\r\n\t\t\t\"\t\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\"\tres -= res.xxyz * bit_mask;\",\r\n\t\t\t\"\treturn res;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t// Depth encoding into RGBA texture\r\n\t// \tbased on SpiderGL shadow map example\r\n\t// \t\thttp://spidergl.org/example.php?id=6\r\n\t// \toriginally from\r\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t// \tsee also here:\r\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\r\n\t'linearDepthRGBA': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"zNear\": { type: \"f\", value: 0.5 },\r\n\t\t\t\"zFar\": { type: \"f\", value: 1000 }\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float zNear;\",\r\n\t\t\t\"uniform float zFar;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"vec4 pack_depth( const float depth ) {\",\r\n\r\n\t\t\t\"\t\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\"\tres -= res.xxyz * bit_mask;\",\r\n\t\t\t\"\treturn res;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = pack_depth( clamp( ( vViewPosition.z - zNear ) / ( zFar - zNear ), 0.0, 1.0 ) );\",\r\n\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n * @author bhouston / http://clara.io/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'mediump',\r\n\r\n\t_buffers = {},\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0;\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\r\n\t\t\t\t? parameters.devicePixelRatio\r\n\t\t\t\t: self.devicePixelRatio !== undefined\r\n\t\t\t\t\t? self.devicePixelRatio\r\n\t\t\t\t\t: 1;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\tthis.autoUpdateObjects = true;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaInput = true;\r\n\tthis.gammaOutput = true;\r\n\r\n\t// shadow map\r\n\r\n\tthis.shadowMapEnabled = false;\r\n\tthis.shadowMapAutoUpdate = true;\r\n\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\tthis.shadowMapDebug = false;\r\n\tthis.shadowMapCascade = false;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// custom render plugins\r\n\r\n\tthis.renderPluginsPre = [];\r\n\tthis.renderPluginsPost = [];\r\n\r\n\t// info\r\n\r\n\tthis.info = {\r\n\r\n\t\tmemory: {\r\n\r\n\t\t\tprograms: 0,\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\r\n\t\t},\r\n\r\n\t\trender: {\r\n\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t_programs = [],\r\n\t_programs_counter = 0,\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = -1,\r\n\t_currentGeometryGroupHash = null,\r\n\t_currentCamera = null,\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t// GL state cache\r\n\r\n\t_oldDoubleSided = -1,\r\n\t_oldFlipSided = -1,\r\n\r\n\t_oldBlending = -1,\r\n\r\n\t_oldBlendEquation = -1,\r\n\t_oldBlendSrc = -1,\r\n\t_oldBlendDst = -1,\r\n\r\n\t_oldDepthTest = -1,\r\n\t_oldDepthWrite = -1,\r\n\r\n\t_oldPolygonOffset = null,\r\n\t_oldPolygonOffsetFactor = null,\r\n\t_oldPolygonOffsetUnits = null,\r\n\r\n\t_oldLineWidth = null,\r\n\r\n\t_viewportX = 0,\r\n\t_viewportY = 0,\r\n\t_viewportWidth = _canvas.width,\r\n\t_viewportHeight = _canvas.height,\r\n\t_currentWidth = 0,\r\n\t_currentHeight = 0,\r\n\r\n\t_enabledAttributes = new Uint8Array( 16 ),\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t // camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t_projScreenMatrixPS = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\t_width = new THREE.Vector3(),\r\n\t_height = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_direction = new THREE.Vector3(),\r\n\r\n\t_lightsNeedUpdate = true,\r\n\r\n\t_lights = {\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\r\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), decayExponents: new Array() },\r\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), decayExponents: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\r\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() },\r\n\t\tarea: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), decayExponents: new Array(), widths: new Array(), heights: new Array() }\r\n\r\n\t};\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\tvar _glExtensionTextureFloat;\r\n\tvar _glExtensionTextureFloatLinear;\r\n\tvar _glExtensionStandardDerivatives;\r\n\tvar _glExtensionShaderTextureLOD;\r\n\tvar _glExtensionTextureFilterAnisotropic;\r\n\tvar _glExtensionCompressedTextureS3TC;\r\n\r\n\tinitGL();\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\r\n\t// GPU capabilities\r\n\r\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\r\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\r\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\r\n\r\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\r\n\r\n\t//\r\n\r\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\r\n\r\n\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\r\n\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\r\n\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\r\n\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\r\n\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\r\n\r\n\t// clamp precision to maximum available\r\n\r\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\r\n\tif ( _precision === \"highp\" && ! highpAvailable ) {\r\n\r\n\t\tif ( mediumpAvailable ) {\r\n\r\n\t\t\t_precision = \"mediump\";\r\n\t\t\tTHREE.onwarning( \"WebGLRenderer: highp not supported, using mediump\" );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_precision = \"lowp\";\r\n\t\t\tTHREE.onwarning( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\r\n\r\n\t\t_precision = \"lowp\";\r\n\t\tTHREE.onwarning( \"WebGLRenderer: mediump not supported, using lowp\" );\r\n\r\n\t}\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.supportsVertexTextures = function () {\r\n\r\n\t\treturn _supportsVertexTextures;\r\n\r\n\t};\r\n\r\n\tthis.supportsFloatTextures = function () {\r\n\r\n\t\treturn _glExtensionTextureFloat;\r\n\r\n\t};\r\n\r\n\tthis.supportsStandardDerivatives = function () {\r\n\r\n\t\treturn _glExtensionStandardDerivatives;\r\n\r\n\t};\r\n\r\n\tthis.supportsCompressedTextureS3TC = function () {\r\n\r\n\t\treturn _glExtensionCompressedTextureS3TC;\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy  = function () {\r\n\r\n\t\treturn _maxAnisotropy;\r\n\r\n\t};\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn _precision;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_canvas.width = width * this.devicePixelRatio;\r\n\t\t_canvas.height = height * this.devicePixelRatio;\r\n\r\n\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewportX = x * this.devicePixelRatio;\r\n\t\t_viewportY = y * this.devicePixelRatio;\r\n\r\n\t\t_viewportWidth = width * this.devicePixelRatio;\r\n\t\t_viewportHeight = height * this.devicePixelRatio;\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t_gl.scissor(\r\n\t\t\tx * this.devicePixelRatio,\r\n\t\t\ty * this.devicePixelRatio,\r\n\t\t\twidth * this.devicePixelRatio,\r\n\t\t\theight * this.devicePixelRatio\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.enableScissorTest = function ( enable ) {\r\n\r\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.setClearColorHex = function ( hex, alpha ) {\r\n\r\n\t\tTHREE.onwarning( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\r\n\t\tthis.setClearColor( hex, alpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Plugins\r\n\r\n\tthis.addPostPlugin = function ( plugin ) {\r\n\r\n\t\tplugin.init( this );\r\n\t\tthis.renderPluginsPost.push( plugin );\r\n\r\n\t};\r\n\r\n\tthis.addPrePlugin = function ( plugin ) {\r\n\r\n\t\tplugin.init( this );\r\n\t\tthis.renderPluginsPre.push( plugin );\r\n\r\n\t};\r\n\r\n\t// Rendering\r\n\r\n\tthis.updateShadowMap = function ( scene, camera ) {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_oldBlending = -1;\r\n\t\t_oldDepthTest = -1;\r\n\t\t_oldDepthWrite = -1;\r\n\t\t_currentGeometryGroupHash = -1;\r\n\t\t_currentMaterialId = -1;\r\n\t\t_lightsNeedUpdate = true;\r\n\t\t_oldDoubleSided = -1;\r\n\t\t_oldFlipSided = -1;\r\n\r\n\t\tthis.shadowMapPlugin.update( scene, camera );\r\n\r\n\t};\r\n\r\n\t// Internal functions\r\n\r\n\t// Buffer allocation\r\n\r\n\tfunction createParticleBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createLineBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createMeshBuffers ( geometryGroup ) {\r\n\r\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tvar onGeometryDispose = function ( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdeallocateGeometry( geometry );\r\n\r\n\t};\r\n\r\n\tvar onTextureDispose = function ( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\r\n\t};\r\n\r\n\tvar onRenderTargetDispose = function ( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\t};\r\n\r\n\tvar onMaterialDispose = function ( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t};\r\n\r\n\t// Buffer deallocation\r\n\r\n\tvar deleteBuffers = function ( geometry ) {\r\n\r\n\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\r\n\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\r\n\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\r\n\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\r\n\r\n\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\r\n\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\r\n\r\n\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\r\n\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\r\n\r\n\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\r\n\t\t// custom attributes\r\n\r\n\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\r\n\r\n\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tvar deallocateGeometry = function ( geometry ) {\r\n\r\n\t\tgeometry.__webglInit = undefined;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\t\tif ( attributes[ key ].buffer !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.deleteBuffer( attributes[ key ].buffer );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.memory.geometries --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( geometry.geometryGroups !== undefined ) {\r\n\r\n\t\t\t\tfor ( var g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeleteBuffers( geometryGroup );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdeleteBuffers( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( ! texture.__webglInit ) return;\r\n\r\n\t\t\ttexture.__webglInit = false;\r\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\r\n\r\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateMaterial = function ( material, optionalDisconnectedProgram ) {\r\n\r\n\t\tvar program = optionalDisconnectedProgram || material.program;\r\n\r\n\t\tif ( program === undefined ) return;\r\n\r\n\t\tif( ! optionalDisconnectedProgram ) {\r\n\t\t\tmaterial.program = undefined;\r\n\t\t}\r\n\r\n\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t// (that's how it's constructed)\r\n\r\n\t\tvar i, il, programInfo;\r\n\t\tvar deleteProgram = false;\r\n\r\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\tif ( programInfo.program === program ) {\r\n\r\n\t\t\t\tprogramInfo.usedTimes --;\r\n\r\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\r\n\t\t\t\t\tdeleteProgram = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( deleteProgram === true ) {\r\n\r\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\r\n\t\t\tvar newPrograms = [];\r\n\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\t\tif ( programInfo.program !== program ) {\r\n\r\n\t\t\t\t\tnewPrograms.push( programInfo );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_programs = newPrograms;\r\n\r\n\t\t\t_gl.deleteProgram( program );\r\n\r\n\t\t\t_this.info.memory.programs --;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer initialization\r\n\r\n\tfunction initCustomAttributes ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\t\tvar attribute = material.attributes[ a ];\r\n\r\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\r\n\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction initParticleBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__sortArray = [];\r\n\r\n\t\tgeometry.__webglParticleCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initLineBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\r\n\t\tgeometry.__webglLineCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tfaces3 = geometryGroup.faces3,\r\n\r\n\t\t\tnvertices = faces3.length * 3,\r\n\t\t\tntris     = faces3.length * 1,\r\n\t\t\tnlines    = faces3.length * 3,\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\r\n\r\n\t\t\tuvType = bufferGuessUVType( material ),\r\n\t\t\tnormalType = bufferGuessNormalType( material ),\r\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\r\n\r\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tif ( normalType ) {\r\n\r\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.hasTangents ) {\r\n\r\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( vertexColorType ) {\r\n\r\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvType ) {\r\n\r\n\t\t\tif ( geometry.faceVertexUvs.length > 0 ) {\r\n\r\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.faceVertexUvs.length > 1 ) {\r\n\r\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\r\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\r\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\r\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\r\n\r\n\t\t\t\tvar attribute = {};\r\n\r\n\t\t\t\tfor ( var property in originalAttribute ) {\r\n\r\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\r\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\r\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\r\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\r\n\r\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\tattribute.__original = originalAttribute;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__inittedArrays = true;\r\n\r\n\t};\r\n\r\n\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n\tfunction materialNeedsSmoothNormals ( material ) {\r\n\r\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessNormalType ( material ) {\r\n\r\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\r\n\r\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\r\n\r\n\t\t\treturn THREE.SmoothShading;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn THREE.FlatShading;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessVertexColorType( material ) {\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\treturn material.vertexColors;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessUVType( material ) {\r\n\r\n\t\t// material must use some texture to require uvs\r\n\r\n\t\tif ( material.map ||\r\n\t\t     material.opacityMap ||\r\n\t\t     material.lightMap ||\r\n\t\t     material.emissiveMap ||\r\n\t\t     material.bumpMap ||\r\n\t\t     material.normalMap ||\r\n\t\t     material.specularMap ||\r\n\t\t     material.reflectivityMap ||\r\n\t\t     material.roughnessMap ||\r\n\t\t     material.falloffMap ||\r\n\t\t     material.anisotropyMap ||\r\n\t\t     material.anisotropyRotationMap ||\r\n\t\t     material.metallicMap ||\r\n\t\t     material.translucencyMap ||\r\n\t\t     ( material.anisotropy && material.anisotropy !== 0.0 ) ||\r\n\t\t     material instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction initDirectBuffers( geometry ) {\r\n\r\n\t\tvar a, attribute, type;\r\n\r\n\t\tfor ( a in geometry.attributes ) {\r\n\r\n\t\t\tif ( a === \"index\" ) {\r\n\r\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattribute = geometry.attributes[ a ];\r\n\r\n\t\t\tattribute.buffer = _gl.createBuffer();\r\n\r\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\r\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer setting\r\n\r\n\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\r\n\t\tvar v, c, vertex, offset, index, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tvl = vertices.length,\r\n\r\n\t\tcolors = geometry.colors,\r\n\t\tcl = colors.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\r\n\t\tsortArray = geometry.__sortArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\ti, il,\r\n\t\ta, ca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( object.sortParticles ) {\r\n\r\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\r\n\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\t_vector3.copy( vertex );\r\n\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\r\n\r\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsortArray.sort( numericalSort );\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( customAttributes ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( dirtyColors ) {\r\n\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( customAttributes ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\r\n\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyVertices || object.sortParticles ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors || object.sortParticles ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tfunction setLineBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, d, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tlineDistances = geometry.lineDistances,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tdl = lineDistances.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\r\n\t\ti, il,\r\n\t\ta, ca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyLineDistances ) {\r\n\r\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\r\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\r\n\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalType = bufferGuessNormalType( material ),\r\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\r\n\t\tuvType = bufferGuessUVType( material ),\r\n\r\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\r\n\r\n\t\tvar f, fl, fi, face,\r\n\t\tvertexNormals, faceNormal, normal,\r\n\t\tvertexColors, faceColor,\r\n\t\tvertexTangents,\r\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\r\n\t\tc1, c2, c3, c4,\r\n\t\tsw1, sw2, sw3, sw4,\r\n\t\tsi1, si2, si3, si4,\r\n\t\tsa1, sa2, sa3, sa4,\r\n\t\tsb1, sb2, sb3, sb4,\r\n\t\tm, ml, i, il,\r\n\t\tvn, uvi, uv2i,\r\n\t\tvk, vkl, vka,\r\n\t\tnka, chf, faceVertexNormals,\r\n\t\ta,\r\n\r\n\t\tvertexIndex = 0,\r\n\r\n\t\toffset = 0,\r\n\t\toffset_uv = 0,\r\n\t\toffset_uv2 = 0,\r\n\t\toffset_face = 0,\r\n\t\toffset_normal = 0,\r\n\t\toffset_tangent = 0,\r\n\t\toffset_line = 0,\r\n\t\toffset_color = 0,\r\n\t\toffset_skin = 0,\r\n\t\toffset_morphTarget = 0,\r\n\t\toffset_custom = 0,\r\n\t\toffset_customSrc = 0,\r\n\r\n\t\tvalue,\r\n\r\n\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\tuvArray = geometryGroup.__uvArray,\r\n\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\tcolorArray = geometryGroup.__colorArray,\r\n\r\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\r\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\r\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\tcustomAttribute,\r\n\r\n\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\tlineArray = geometryGroup.__lineArray,\r\n\r\n\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\tobj_faces = geometry.faces,\r\n\r\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\r\n\t\tobj_colors = geometry.colors,\r\n\r\n\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\tobj_skinWeights = geometry.skinWeights,\r\n\r\n\t\tmorphTargets = geometry.morphTargets,\r\n\t\tmorphNormals = geometry.morphNormals;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\toffset += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyMorphTargets ) {\r\n\r\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\r\n\t\t\t\toffset_morphTarget = 0;\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 9;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\r\n\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( obj_skinWeights.length ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\toffset_skin += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_skin > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors && vertexColorType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\toffset_color += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_color > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\r\n\t\t\tvar tmp = new THREE.Vector3( 0, 0, 0 );\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ] || tmp;\r\n\t\t\t\tt2 = vertexTangents[ 1 ] || tmp;\r\n\t\t\t\tt3 = vertexTangents[ 2 ] || tmp;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\toffset_tangent += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals && normalType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv2 > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyElements ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_face += 3;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_line += 6;\r\n\r\n\t\t\t\tvertexIndex += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\r\n\t\t\t\toffset_custom = 0;\r\n\t\t\t\toffset_customSrc = 0;\r\n\r\n\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\tvar pp;\r\n\r\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// used by renderBufferDirect for THREE.Line\r\n\tfunction setupLinesVertexAttributes( material, programAttributes, geometryAttributes, startIndex ) {\r\n\r\n\t\tvar attributeItem, attributeName, attributePointer, attributeSize;\r\n\r\n\t\tfor ( attributeName in programAttributes ) {\r\n\r\n\t\t\tattributePointer = programAttributes[ attributeName ];\r\n\t\t\tattributeItem = geometryAttributes[ attributeName ];\r\n\r\n\t\t\tif ( attributePointer >= 0 ) {\r\n\r\n\t\t\t\tif ( attributeItem ) {\r\n\r\n\t\t\t\t\tattributeSize = attributeItem.itemSize;\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\r\n\t\t\t\t\tenableAttribute( attributePointer );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\r\n\r\n\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setDirectBuffers( geometry, hint ) {\r\n\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar attributeName, attributeItem;\r\n\r\n\t\tfor ( attributeName in attributes ) {\r\n\r\n\t\t\tattributeItem = attributes[ attributeName ];\r\n\r\n\t\t\tif ( attributeItem.needsUpdate ) {\r\n\r\n\t\t\t\tif ( attributeName === 'index' ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattributeItem.needsUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\r\n\t\t\tif ( material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\tnormalArray,\r\n\t\t\t\t\ti, il = object.count * 3;\r\n\r\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tnormalArray = object.normalArray;\r\n\r\n\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\r\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\r\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\r\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\r\n\t\t\t\t\tnormalArray[ i ] \t = nx;\r\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tvar linewidth, a, attribute;\r\n\t\tvar attributeItem, attributeName, attributePointer, attributeSize;\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tvar programAttributes = program.attributes;\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\r\n\r\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\r\n\r\n\t\t\t_currentGeometryGroupHash = geometryHash;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tdisableAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar index = geometryAttributes[ \"index\" ];\r\n\r\n\t\t\t// indexed triangles\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tfor ( attributeName in programAttributes ) {\r\n\r\n\t\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\r\n\t\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\r\n\r\n\t\t\t\t\t\t\tif ( attributePointer >= 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( attributeItem ) {\r\n\r\n\t\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\r\n\t\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\r\n\t\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// indices\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// render indexed triangles\r\n\r\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t// non-indexed triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tfor ( attributeName in programAttributes ) {\r\n\r\n\t\t\t\t\t\tif ( attributeName === 'index') continue;\r\n\r\n\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\r\n\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\r\n\r\n\t\t\t\t\t\tif ( attributePointer >= 0 ) {\r\n\r\n\t\t\t\t\t\t\tif ( attributeItem ) {\r\n\r\n\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\r\n\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\r\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\r\n\t\t\t\t// render non-indexed triangles\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.array.length / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += position.array.length / 3;\r\n\t\t\t\t_this.info.render.faces += position.array.length / 3 / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\tfor ( attributeName in programAttributes ) {\r\n\r\n\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\r\n\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\r\n\r\n\t\t\t\t\tif ( attributePointer >= 0 ) {\r\n\r\n\t\t\t\t\t\tif ( attributeItem ) {\r\n\r\n\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributePointer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\r\n\r\n\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar position = geometryAttributes[ \"position\" ];\r\n\r\n\t\t\t// render particles\r\n\r\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.points += position.array.length / 3;\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\r\n\t\t\tvar index = geometryAttributes[ \"index\" ];\r\n\r\n\t\t\t// indexed lines\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupLinesVertexAttributes(material, programAttributes, geometryAttributes, startIndex);\r\n\r\n\t\t\t\t\t\t// indices\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// render indexed lines\r\n\r\n\t\t\t\t\t_gl.drawElements( _gl.LINES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16Array\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// non-indexed lines\r\n\r\n\t\t\telse {\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupLinesVertexAttributes(material, programAttributes, geometryAttributes, 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometryAttributes[ \"position\" ];\r\n\r\n\t\t\t\t_gl.drawArrays( primitives, 0, position.array.length / 3 );\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += position.array.length;\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tvar linewidth, a, attribute, i, il;\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tvar attributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\r\n\r\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\r\n\r\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tdisableAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.morphTargetBase ) {\r\n\r\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t// custom attributes\r\n\r\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\r\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// colors\r\n\r\n\t\t\tif ( attributes.color >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( attributes.normal >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// tangents\r\n\r\n\t\t\tif ( attributes.tangent >= 0 ) {\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tif ( attributes.uv >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.faceVertexUvs[0] ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.faceVertexUvs[1] ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t\tenableAttribute( attributes.uv2 );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.skinning &&\r\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\tenableAttribute( attributes.skinIndex );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\tenableAttribute( attributes.skinWeight );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// line distances\r\n\r\n\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\t\t\t\tenableAttribute( attributes.lineDistance );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// wireframe\r\n\r\n\t\t\tif ( material.wireframe ) {\r\n\r\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t// triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\r\n\t\t// render lines\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\r\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction enableAttribute( attribute ) {\r\n\r\n\t\tif ( _enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\t_gl.enableVertexAttribArray( attribute );\r\n\t\t\t_enabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction disableAttributes() {\r\n\r\n\t\tfor ( var attribute in _enabledAttributes ) {\r\n\r\n\t\t\tif ( _enabledAttributes[ attribute ] === 1 ) {\r\n\r\n\t\t\t\t_gl.disableVertexAttribArray( attribute );\r\n\t\t\t\t_enabledAttributes[ attribute ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\r\n\t\t// set base\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\t\t\tenableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t} else if ( attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\tenableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\r\n\t\t\t// set forced order\r\n\r\n\t\t\tvar m = 0;\r\n\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\r\n\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\r\n\t\t\t\tm ++;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the most influencing\r\n\r\n\t\t\tvar influence, activeInfluenceIndices = [];\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\tvar i, il = influences.length;\r\n\r\n\t\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\t\tinfluence = influences[ i ];\r\n\r\n\t\t\t\tif ( influence > 0 ) {\r\n\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar influenceIndex, m = 0;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\r\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\r\n\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// load updated influences uniform\r\n\r\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\r\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Sorting\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction numericalSort ( a, b ) {\r\n\r\n\t\treturn b[ 0 ] - a[ 0 ];\r\n\r\n\t};\r\n\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tTHREE.onerror( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il,\r\n\r\n\t\twebglObject, object,\r\n\t\trenderList,\r\n\r\n\t\tlights = scene.__lights,\r\n\t\tfog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentMaterialId = -1;\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t// update WebGL objects\r\n\r\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\r\n\r\n\t\t// custom render plugins (pre pass)\r\n\r\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\t_this.info.render.calls = 0;\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\t\t_this.info.render.points = 0;\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for regular objects (frustum culled)\r\n\r\n\t\trenderList = scene.__webglObjects;\r\n\r\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\twebglObject.id = i;\r\n\t\t\twebglObject.render = false;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\r\n\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\tif ( this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.sortObjects ) {\r\n\r\n\t\t\trenderList.sort( painterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for immediate objects\r\n\r\n\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar material = scene.overrideMaterial;\r\n\r\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\tthis.setDepthTest( material.depthTest );\r\n\t\t\tthis.setDepthWrite( material.depthWrite );\r\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = null;\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tthis.setBlending( THREE.NoBlending );\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\r\n\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget && renderTarget.generateMipmaps &&\r\n\t\t\trenderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter &&\r\n\t\t\tTHREE.isPowerOfTwo( renderTarget.width ) && THREE.isPowerOfTwo( renderTarget.height ) ) {\r\n\r\n\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tthis.setDepthTest( true );\r\n\t\tthis.setDepthWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction renderPlugins( plugins, scene, camera ) {\r\n\r\n\t\tif ( ! plugins.length ) return;\r\n\r\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\r\n\r\n\t\t\t// reset state for plugin (to start from clean slate)\r\n\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\r\n\t\t\t_oldBlending = -1;\r\n\t\t\t_oldDepthTest = -1;\r\n\t\t\t_oldDepthWrite = -1;\r\n\t\t\t_oldDoubleSided = -1;\r\n\t\t\t_oldFlipSided = -1;\r\n\t\t\t_currentGeometryGroupHash = -1;\r\n\t\t\t_currentMaterialId = -1;\r\n\r\n\t\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n\t\t\t// reset state after plugin (anything could have changed)\r\n\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\r\n\t\t\t_oldBlending = -1;\r\n\t\t\t_oldDepthTest = -1;\r\n\t\t\t_oldDepthWrite = -1;\r\n\t\t\t_oldDoubleSided = -1;\r\n\t\t\t_oldFlipSided = -1;\r\n\t\t\t_currentGeometryGroupHash = -1;\r\n\t\t\t_currentMaterialId = -1;\r\n\r\n\t\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction renderObjects( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n\t\tvar webglObject, object, buffer, material, start, end, delta;\r\n\r\n\t\tif ( reverse ) {\r\n\r\n\t\t\tstart = renderList.length - 1;\r\n\t\t\tend = -1;\r\n\t\t\tdelta = -1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = 0;\r\n\t\t\tend = renderList.length;\r\n\t\t\tdelta = 1;\r\n\t\t}\r\n\r\n\t\tfor ( var i = start; i !== end; i += delta ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\r\n\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\r\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\r\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.setMaterialFaces( material );\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n\t\tvar webglObject, object, material, program;\r\n\r\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\r\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\r\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\t_currentGeometryGroupHash = -1;\r\n\r\n\t\t_this.setMaterialFaces( material );\r\n\r\n\t\tif ( object.immediateRenderCallback ) {\r\n\r\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tglobject.transparent = material;\r\n\t\t\tglobject.opaque = null;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tglobject.opaque = material;\r\n\t\t\tglobject.transparent = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object;\r\n\t\tvar buffer = globject.buffer;\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\tvar materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;\r\n\r\n\t\t\tmaterial = material.materials[ materialIndex ];\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\tglobject.transparent = material;\r\n\t\t\t\tglobject.opaque = null;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tglobject.opaque = material;\r\n\t\t\t\tglobject.transparent = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( material ) {\r\n\r\n\t\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\t\tglobject.transparent = material;\r\n\t\t\t\t\tglobject.opaque = null;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tglobject.opaque = material;\r\n\t\t\t\t\tglobject.transparent = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects refresh\r\n\r\n\tthis.initWebGLObjects = function ( scene ) {\r\n\r\n\t\tif ( !scene.__webglObjects ) {\r\n\r\n\t\t\tscene.__webglObjects = [];\r\n\t\t\tscene.__webglObjectsImmediate = [];\r\n\t\t\tscene.__webglSprites = [];\r\n\t\t\tscene.__webglFlares = [];\r\n\r\n\t\t}\r\n\r\n\t\twhile ( scene.__objectsAdded.length ) {\r\n\r\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\r\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( scene.__objectsRemoved.length ) {\r\n\r\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\r\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// update must be called after objects adding / removal\r\n\r\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tvar object = scene.__webglObjects[ o ].object;\r\n\r\n\t\t\t// TODO: Remove this hack (WebGLRenderer refactoring)\r\n\r\n\t\t\tif ( object.__webglInit === undefined ) {\r\n\r\n\t\t\t\tif ( object.__webglActive !== undefined ) {\r\n\r\n\t\t\t\t\tremoveObject( object, scene );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddObject( object, scene );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tupdateObject( object );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects adding\r\n\r\n\tfunction addObject( object, scene ) {\r\n\r\n\t\tvar g, geometry, material, geometryGroup;\r\n\r\n\t\tif ( object.__webglInit === undefined ) {\r\n\r\n\t\t\tobject.__webglInit = true;\r\n\r\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\r\n\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\r\n\r\n\t\t\t\tobject.geometry.__webglInit = true;\r\n\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\tif ( geometry === undefined ) {\r\n\r\n\t\t\t\t// fail silently for now\r\n\r\n\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tmaterial = object.material;\r\n\r\n\t\t\t\tif ( geometry.geometryGroups === undefined ) {\r\n\r\n\t\t\t\t\tgeometry.makeGroups( material instanceof THREE.MeshFaceMaterial );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create separate VBOs per geometry chunk\r\n\r\n\t\t\t\tfor ( g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\t// initialise VBO on the first access\r\n\r\n\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tcreateLineBuffers( geometry );\r\n\t\t\t\t\tinitLineBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.__webglActive === undefined ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ||\r\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tscene.__webglSprites.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tscene.__webglFlares.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.__webglActive = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction addBuffer( objlist, buffer, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tid: null,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null,\r\n\t\t\t\tz: 0\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tfunction addBufferImmediate( objlist, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tid: null,\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null,\r\n\t\t\t\tz: 0\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\t// Objects updates\r\n\r\n\tfunction updateObject( object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tgeometryGroup, customAttributesDirty, material;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// check all geometry groups\r\n\r\n\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\r\n\r\n\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\t\t\tif ( geometry.buffersNeedUpdate ) {\r\n\r\n\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\tgeometry.buffersNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometry );\r\n\r\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometry );\r\n\r\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects updates - custom attributes check\r\n\r\n\tfunction areCustomAttributesDirty( material ) {\r\n\r\n\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\tfunction clearCustomAttributes( material ) {\r\n\r\n\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects removal\r\n\r\n\tfunction removeObject( object, scene ) {\r\n\r\n\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t object instanceof THREE.ParticleSystem ||\r\n\t\t\t object instanceof THREE.Line ) {\r\n\r\n\t\t\tremoveInstances( scene.__webglObjects, object );\r\n\r\n\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\r\n\r\n\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\r\n\r\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\r\n\r\n\t\t}\r\n\r\n\t\tdelete object.__webglActive;\r\n\r\n\t};\r\n\r\n\tfunction removeInstances( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ].object === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction removeInstancesDirect( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ] === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Materials\r\n\r\n\tthis.initMaterial = function ( material, lights, fog, object ) {\r\n\r\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\r\n\r\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\tshaderID = 'depth';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\tshaderID = 'normal';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'basic';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\tshaderID = 'lambert';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\tshaderID = 'phong';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\r\n\r\n\t\t\tshaderID = 'physical';\r\n\r\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'basic';\r\n\r\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\tshaderID = 'dashed';\r\n\r\n\t\t} else if ( material instanceof THREE.ParticleSystemMaterial ) {\r\n\r\n\t\t\tshaderID = 'particle_basic';\r\n\r\n\t\t}\r\n\r\n\t\tif ( shaderID && THREE.ShaderLib[ shaderID ] ) {\r\n\r\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\r\n\r\n\t\t}\r\n\r\n\t\tif( ! shaderID ) {\r\n\t\t\tshaderID = material.shaderID;\r\n\t\t}\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tmaxLightCount = allocateLights( lights );\r\n\r\n\t\tmaxShadows = allocateShadows( lights );\r\n\r\n\t\tmaxBones = allocateBones( object );\r\n\r\n\t\tparameters = {\r\n\r\n\t\t\tmap: !!material.map,\r\n\t\t\topacityMap: !!material.opacityMap,\r\n\t\t\tenvMap: !!material.envMap,\r\n\t\t\tdiffuseEnvMap: !!material.diffuseEnvMap,\r\n\t\t\tlightMap: !!material.lightMap,\r\n\t\t\temissiveMap: !!material.emissiveMap,\r\n\t\t\tbumpMap: !!material.bumpMap,\r\n\t\t\tnormalMap: !!material.normalMap,\r\n\t\t\tspecularMap: !!material.specularMap,\r\n\t\t\treflectivityMap: !!material.reflectivityMap,\r\n\t\t\troughnessMap: !!material.roughnessMap,\r\n\t\t\ttranslucencyMap: !!material.translucencyMap,\r\n\t\t\tmetallicMap: !!material.metallicMap,\r\n\t\t\tfalloffMap: !!material.falloffMap,\r\n\r\n\t\t\tclearCoat: (( material.clearCoat !== undefined )&&( material.clearCoat !== 0 )),\r\n\r\n\t\t\tanisotropy: (( material.anisotropy !== undefined )&&( material.anisotropy !== 0 ))||( !! material.anisotropyMap ),\r\n\t\t\tanisotropyMap: !! material.anisotropyMap,\r\n\t\t\tanisotropyRotation: (( material.anisotropyRotation !== undefined )&&( material.anisotropyRotation !== 0 ))||( !! material.anisotropyRotationMap ),\r\n\t\t\tanisotropyRotationMap: !! material.anisotropyRotationMap,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tsizeAttenuation: !! material.sizeAttenuation,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\r\n\r\n\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\t\t\tmaxAreaLights: maxLightCount.area,\r\n\r\n\t\t\tmaxShadows: maxShadows,\r\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,\r\n\t\t\tshadowMapType: this.shadowMapType,\r\n\t\t\tshadowMapDebug: this.shadowMapDebug,\r\n\t\t\tshadowMapCascade: this.shadowMapCascade,\r\n\r\n\t\t\ttranslucency: material.translucency && ( material.translucency.getHex() > 0 ),\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tfalloff: ( material.falloff || false ),\r\n\t\t\twrapAround: material.wrapAround,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide\r\n\r\n\t\t};\r\n\r\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tvar id, base = \"morphTarget\";\r\n\r\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tvar id, base = \"morphNormal\";\r\n\r\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.uniformsList = [];\r\n\r\n\t\tfor ( u in material.uniforms ) {\r\n\r\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setMaterialShaders( material, shaders ) {\r\n\r\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\r\n\t\tmaterial.vertexShader = shaders.vertexShader;\r\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\r\n\r\n\t};\r\n\r\n\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tvar oldProgram = material.program;\r\n\r\n\t\t\t_this.initMaterial( material, lights, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t\tif ( oldProgram ) deallocateMaterial( material, oldProgram );\r\n\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshMaterial = false;\r\n\r\n\t\tvar program = material.program,\r\n\t\t\tp_uniforms = program.uniforms,\r\n\t\t\tm_uniforms = material.uniforms;\r\n\r\n\t\tif ( program !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program );\r\n\t\t\t_currentProgram = program;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\r\n\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhysicalMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetupLights( program, lights );\r\n\t\t\t\t\t_lightsNeedUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhysicalMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.ParticleSystemMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n \t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load common uniforms\r\n\r\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhysicalMaterial ||\r\n\t\t\t\t material.envMap ||\r\n\t\t\t\t material.diffuseEnvMap ) {\r\n\r\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhysicalMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsMatrices( p_uniforms, object );\r\n\r\n\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tvar map = material.map;\r\n\t\t\tuniforms.offsetRepeat.value.set( map.offset.x, map.offset.y, map.repeat.x, map.repeat.y );\r\n\t\t\tuniforms.gainBrightness.value.set( map.gainPivot, map.gain, map.brightness, map.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.specularMap ) {\r\n\r\n\t\t\tvar specularMap = material.specularMap;\r\n\t\t\tuniforms.specularMap.value = specularMap;\r\n\t\t\tuniforms.specularOffsetRepeat.value.set( specularMap.offset.x, specularMap.offset.y, specularMap.repeat.x, specularMap.repeat.y );\r\n\t\t\tuniforms.specularGainBrightness.value.set( specularMap.gainPivot, specularMap.gain, specularMap.brightness, specularMap.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.opacityMap ) {\r\n\r\n\t\t\tvar opacityMap = material.opacityMap;\r\n\t\t\tuniforms.opacityMap.value = opacityMap;\r\n\t\t\tuniforms.opacityOffsetRepeat.value.set( opacityMap.offset.x, opacityMap.offset.y, opacityMap.repeat.x, opacityMap.repeat.y );\r\n\t\t\tuniforms.opacityGainBrightness.value.set( opacityMap.gainPivot, opacityMap.gain, opacityMap.brightness, opacityMap.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tvar bumpMap = material.bumpMap;\r\n\t\t\tuniforms.bumpOffsetRepeat.value.set( bumpMap.offset.x, bumpMap.offset.y, bumpMap.repeat.x, bumpMap.repeat.y );\r\n\t\t\t//uniforms.bumpGainBrightness.value.set( bumpMap.gainPivot, bumpMap.gain, bumpMap.brightness, 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tvar normalMap = material.normalMap;\r\n\t\t\tuniforms.normalOffsetRepeat.value.set( normalMap.offset.x, normalMap.offset.y, normalMap.repeat.x, normalMap.repeat.y );\r\n\t\t\t//uniforms.normalGainBrightness.value.set( normalMap.gainPivot, normalMap.gain, normalMap.brightness, 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.anisotropyMap ) {\r\n\r\n\t\t\tvar anisotropyMap = material.anisotropyMap;\r\n\t\t\tuniforms.anisotropyOffsetRepeat.value.set( anisotropyMap.offset.x, anisotropyMap.offset.y, anisotropyMap.repeat.x, anisotropyMap.repeat.y );\r\n\t\t\tuniforms.anisotropyGainBrightness.value.set( anisotropyMap.gainPivot, anisotropyMap.gain, anisotropyMap.brightness, anisotropyMap.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.anisotropyRotationMap ) {\r\n\r\n\t\t\tvar anisotropyRotationMap = material.anisotropyRotationMap;\r\n\t\t\tuniforms.anisotropyRotationOffsetRepeat.value.set( anisotropyRotationMap.offset.x, anisotropyRotationMap.offset.y, anisotropyRotationMap.repeat.x, anisotropyRotationMap.repeat.y );\r\n\t\t\tuniforms.anisotropyRotationGainBrightness.value.set( anisotropyRotationMap.gainPivot, anisotropyRotationMap.gain, anisotropyRotationMap.brightness, anisotropyRotationMap.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.roughnessMap ) {\r\n\r\n\t\t\tvar roughnessMap = material.roughnessMap;\r\n\t\t\tuniforms.roughnessOffsetRepeat.value.set( roughnessMap.offset.x, roughnessMap.offset.y, roughnessMap.repeat.x, roughnessMap.repeat.y );\r\n\t\t\tuniforms.roughnessGainBrightness.value.set( roughnessMap.gainPivot, roughnessMap.gain, roughnessMap.brightness, roughnessMap.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.metallicMap ) {\r\n\r\n\t\t\tvar metallicMap = material.metallicMap;\r\n\t\t\tuniforms.metallicOffsetRepeat.value.set( metallicMap.offset.x, metallicMap.offset.y, metallicMap.repeat.x, metallicMap.repeat.y );\r\n\t\t\tuniforms.metallicGainBrightness.value.set( metallicMap.gainPivot, metallicMap.gain, metallicMap.brightness, metallicMap.invert ? -1.0 : 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.translucencyMap ) {\r\n\r\n\t\t\tvar translucencyMap = material.translucencyMap;\r\n\t\t\tuniforms.translucencyMap.value = translucencyMap;\r\n\t\t\t//uniforms.translucencyOffsetRepeat.value.set( translucencyMap.offset.x, translucencyMap.offset.y, translucencyMap.repeat.x, translucencyMap.repeat.y );\r\n\t\t\t//uniforms.translucencyGainBrightness.value.set( translucencyMap.gainPivot, translucencyMap.gain, translucencyMap.brightness, 1.0 );\r\n\r\n\t\t}\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\r\n\t\tuniforms.envEncoding.value = ( material.envMap ) ? material.envMap.encoding : 0;\r\n\t\tuniforms.diffuseEnvMap.value = material.diffuseEnvMap;\r\n\t\tuniforms.diffuseEnvEncoding.value =  ( material.diffuseEnvMap ) ? material.diffuseEnvMap.encoding : 0;\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\tuniforms.combine.value = material.combine;\r\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\r\n\t\tuniforms.psColor.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size;\r\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacityMap.value = material.opacityMap;\r\n\r\n\t\tuniforms.shininess.value = material.shininess;\r\n\r\n\t\tuniforms.ambient.value = material.ambient;\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\t\tuniforms.specular.value = material.specular;\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacityMap.value = material.opacityMap;\r\n\r\n\t\tuniforms.falloffBlendParams.value = material.falloffBlendParams;\r\n\t\tuniforms.falloffMap.value = material.falloffMap;\r\n\r\n\t\tuniforms.roughness.value = material.roughness;\r\n\t\tuniforms.metallic.value = material.metallic;\r\n\r\n\t\tuniforms.clearCoat.value = material.clearCoat;\r\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\r\n\r\n\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\t\tuniforms.metallicMap.value = material.metallicMap;\r\n\r\n\t\tuniforms.translucencyMap.value = material.translucencyMap;\r\n\t\tuniforms.translucencyNormalAlpha.value = material.translucencyNormalAlpha;\r\n\t\tuniforms.translucencyNormalPower.value = material.translucencyNormalPower;\r\n\t\tuniforms.translucencyViewAlpha.value = material.translucencyViewAlpha;\r\n\t\tuniforms.translucencyViewPower.value = material.translucencyViewPower;\r\n\r\n\t\tuniforms.anisotropyMap.value = material.anisotropyMap;\r\n\t\tuniforms.anisotropy.value = material.anisotropy;\r\n\t\tuniforms.anisotropyRotation.value = material.anisotropyRotation;\r\n\t\tuniforms.anisotropyRotationMap.value = material.anisotropyRotationMap;\r\n\r\n\t\tuniforms.ambient.value = material.ambient;\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\t\tuniforms.falloffColor.value = material.falloffColor;\r\n\t\tuniforms.specular.value = material.specular;\r\n\t\tuniforms.translucency.value = material.translucency;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tuniforms.ambient.value = material.ambient;\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\r\n\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\r\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\t\tuniforms.pointLightDecayExponent.value = lights.point.decayExponents;\r\n\r\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\tuniforms.spotLightDecayExponent.value = lights.spot.decayExponents;\r\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n\t\tuniforms.areaLightColor.value = lights.area.colors;\r\n\t\tuniforms.areaLightPosition.value = lights.area.positions;\r\n\t\tuniforms.areaLightDistance.value = lights.area.distances;\r\n\t\tuniforms.areaLightDecayExponent.value = lights.area.decayExponents;\r\n\t\tuniforms.areaLightWidth.value = lights.area.widths;\r\n\t\tuniforms.areaLightHeight.value = lights.area.heights;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n\t\tif ( uniforms.shadowMatrix ) {\r\n\r\n\t\t\tvar j = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\r\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Uniforms (load to GPU)\r\n\r\n\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\r\n\t\tif ( uniforms.normalMatrix ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction getTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= _maxTextures ) {\r\n\r\n\t\t\tTHREE.onwarning( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t};\r\n\r\n\tfunction loadUniformsGeneric ( program, uniforms ) {\r\n\r\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\r\n\r\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\r\n\t\t\tif ( !location ) continue;\r\n\r\n\t\t\tuniform = uniforms[ j ][ 0 ];\r\n\r\n\t\t\ttype = uniform.type;\r\n\t\t\tvalue = uniform.value;\r\n\r\n\t\t\tif ( type === \"i\" ) { // single integer\r\n\r\n\t\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t\t} else if ( type === \"f\" ) { // single float\r\n\r\n\t\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\r\n\r\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\r\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\r\n\r\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\r\n\r\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\r\n\r\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 2;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 3;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 4;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue.flattenToArray( uniform._array );\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\r\n\r\n\t\t\t\ttexture = value;\r\n\t\t\t\ttextureUnit = getTextureUnit();\r\n\r\n\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\r\n\t\t\t\tif ( !texture ) continue;\r\n\r\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\r\n\r\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\r\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\r\n\t\t\t\t\tif ( !texture ) continue;\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.onwarning( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMatrices ( object, camera ) {\r\n\r\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\r\n\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\r\n\t\tarray[ offset ]     = color.r * intensity;\r\n\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\r\n\t};\r\n\r\n\tfunction setupLights ( program, lights ) {\r\n\r\n\t\tvar l, ll, light, n,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor, skyColor, groundColor,\r\n\t\tintensity,  intensitySq,\r\n\t\tposition,\r\n\t\tdistance,\r\n\r\n\t\tzlights = _lights,\r\n\r\n\t\tdirColors = zlights.directional.colors,\r\n\t\tdirPositions = zlights.directional.positions,\r\n\r\n\t\tpointColors = zlights.point.colors,\r\n\t\tpointPositions = zlights.point.positions,\r\n\t\tpointDistances = zlights.point.distances,\r\n\t\tpointDecayExponents = zlights.point.decayExponents,\r\n\r\n\t\tspotColors = zlights.spot.colors,\r\n\t\tspotPositions = zlights.spot.positions,\r\n\t\tspotDistances = zlights.spot.distances,\r\n\t\tspotDecayExponents = zlights.spot.decayExponents,\r\n\t\tspotDirections = zlights.spot.directions,\r\n\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\tspotExponents = zlights.spot.exponents,\r\n\r\n\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\themiPositions = zlights.hemi.positions,\r\n\r\n\t\tareaColors = zlights.area.colors,\r\n\t\tareaPositions = zlights.area.positions,\r\n\t\tareaDistances = zlights.area.distances,\r\n\t\tareaDecayExponents = zlights.area.decayExponents,\r\n\t\tareaWidths = zlights.area.widths,\r\n\t\tareaHeights = zlights.area.heights,\r\n\r\n\t\tdirLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0,\r\n\t\tareaLength = 0,\r\n\r\n\t\tdirCount = 0,\r\n\t\tpointCount = 0,\r\n\t\tspotCount = 0,\r\n\t\themiCount = 0,\r\n\t\tareaCount = 0,\r\n\r\n\t\tdirOffset = 0,\r\n\t\tpointOffset = 0,\r\n\t\tspotOffset = 0,\r\n\t\themiOffset = 0,\r\n\t\tareaOffset = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tr += color.r;\r\n\t\t\t\tg += color.g;\r\n\t\t\t\tb += color.b;\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdirCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\t// skip lights with undefined direction\r\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\r\n\r\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\r\n\r\n\t\t\t\tdirOffset = dirLength * 3;\r\n\r\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n\r\n\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n\t\t\t\tdirLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tpointCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tpointOffset = pointLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\r\n\t\t\t\tif( light.physicalFalloff ) {\r\n\t\t\t\t\t// magic value of -1 switches the equation to UE4 physical quadratic falloff.\r\n\t\t\t\t\tpointDecayExponents[ pointLength ] = -1.0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tpointDecayExponents[ pointLength ] = ( distance === 0 ) ? 0.0 : light.decayExponent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpointLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tspotCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tspotOffset = spotLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\r\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\r\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\r\n\t\t\t\tif( light.physicalFalloff ) {\r\n\t\t\t\t\t// magic value of -1 switches the equation to UE4 physical quadratic falloff.\r\n\t\t\t\t\tspotDecayExponents[ pointLength ] = -1.0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tspotDecayExponents[ pointLength ] = ( distance === 0 ) ? 0.0 : light.decayExponent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_direction.copy( _vector3 );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\r\n\t\t\t\tspotLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\themiCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\t// skip lights with undefined direction\r\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\r\n\r\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\r\n\r\n\t\t\t\themiOffset = hemiLength * 3;\r\n\r\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tskyColor = light.color;\r\n\t\t\t\tgroundColor = light.groundColor;\r\n\r\n\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n\t\t\t\themiLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.AreaLight ) {\r\n\r\n\t\t\t\tareaCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tareaOffset = areaLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( areaColors, areaOffset, color, intensity );\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tareaPositions[ areaOffset ]     = _vector3.x;\r\n\t\t\t\tareaPositions[ areaOffset + 1 ] = _vector3.y;\r\n\t\t\t\tareaPositions[ areaOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tareaDistances[ areaLength ] = distance;\r\n\t\t\t\tareaDecayExponents[ areaLength ] = light.decayExponent;\r\n\r\n\t\t\t\tlight.matrixWorld.extractBasis( _width, _height, _vector3 );\r\n\t\t\t\t_width.multiplyScalar( light.width );\r\n\t\t\t\t_height.multiplyScalar( light.height );\r\n\r\n\t\t\t\tareaWidths[ areaOffset ]     = _width.x;\r\n\t\t\t\tareaWidths[ areaOffset + 1 ] = _width.y;\r\n\t\t\t\tareaWidths[ areaOffset + 2 ] = _width.z;\r\n\r\n\t\t\t\tareaHeights[ areaOffset ]     = _height.x;\r\n\t\t\t\tareaHeights[ areaOffset + 1 ] = _height.y;\r\n\t\t\t\tareaHeights[ areaOffset + 2 ] = _height.z;\r\n\r\n\t\t\t\tareaLength += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// null eventual remains from removed lights\r\n\t\t// (this is to avoid if in shader)\r\n\r\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\t\tfor ( l = areaLength * 3, ll = Math.max( areaColors.length, areaCount * 3 ); l < ll; l ++ ) areaColors[ l ] = 0.0;\r\n\r\n\t\tzlights.directional.length = dirLength;\r\n\t\tzlights.point.length = pointLength;\r\n\t\tzlights.spot.length = spotLength;\r\n\t\tzlights.hemi.length = hemiLength;\r\n\t\tzlights.area.length = areaLength;\r\n\r\n\t\tzlights.ambient[ 0 ] = r;\r\n\t\tzlights.ambient[ 1 ] = g;\r\n\t\tzlights.ambient[ 2 ] = b;\r\n\r\n\t};\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMaterialFaces = function ( material ) {\r\n\r\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\r\n\t\tvar flipSided = material.side === THREE.BackSide;\r\n\r\n\t\tif ( _oldDoubleSided !== doubleSided ) {\r\n\r\n\t\t\tif ( doubleSided ) {\r\n\r\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldDoubleSided = doubleSided;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _oldFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( _oldDepthTest !== depthTest ) {\r\n\r\n\t\t\tif ( depthTest ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldDepthTest = depthTest;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\tif ( _oldDepthWrite !== depthWrite ) {\r\n\r\n\t\t\t_gl.depthMask( depthWrite );\r\n\t\t\t_oldDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setLineWidth ( width ) {\r\n\r\n\t\tif ( width !== _oldLineWidth ) {\r\n\r\n\t\t\t_gl.lineWidth( width );\r\n\r\n\t\t\t_oldLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\r\n\r\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\r\n\r\n\t\t\tif ( polygonoffset ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldPolygonOffset = polygonoffset;\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\t_gl.polygonOffset( factor, units );\r\n\r\n\t\t\t_oldPolygonOffsetFactor = factor;\r\n\t\t\t_oldPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\r\n\r\n\t\tif ( blending !== _oldBlending ) {\r\n\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldBlending = blending;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\r\n\r\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\r\n\r\n\t\t\t\t_oldBlendEquation = blendEquation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\r\n\r\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\r\n\r\n\t\t\t\t_oldBlendSrc = blendSrc;\r\n\t\t\t\t_oldBlendDst = blendDst;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_oldBlendEquation = null;\r\n\t\t\t_oldBlendSrc = null;\r\n\t\t\t_oldBlendDst = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Defines\r\n\r\n\tfunction generateDefines ( defines ) {\r\n\r\n\t\tvar value, chunk, chunks = [];\r\n\r\n\t\tfor ( var d in defines ) {\r\n\r\n\t\t\tvalue = defines[ d ];\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunk = \"#define \" + d + \" \" + value;\r\n\t\t\tchunks.push( chunk );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( \"\\n\" );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction buildProgram( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {\r\n\r\n\t\tvar p, pl, d, program, code;\r\n\t\tvar simpleChunks = [];\r\n\t\tvar chunks = [];\r\n\r\n\t\t// Generate code\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tchunks.push( shaderID );\r\n\t\t\tsimpleChunks.push( shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchunks.push( fragmentShader );\r\n\t\t\tchunks.push( vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( d in defines ) {\r\n\r\n\t\t\tchunks.push( d );\r\n\t\t\tchunks.push( defines[ d ] );\r\n\t\t\tsimpleChunks.push( d );\r\n\t\t\tsimpleChunks.push( defines[ d ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( p in parameters ) {\r\n\r\n\t\t\tchunks.push( p );\r\n\t\t\tchunks.push( parameters[ p ] );\r\n\r\n\t\t\tsimpleChunks.push( p );\r\n\t\t\tsimpleChunks.push( parameters[ p ] );\r\n\r\n\t\t}\r\n\r\n\t\tcode = chunks.join();\r\n\t\tvar simpleCode = simpleChunks.join();\r\n\r\n\t\t// Check if code has been already compiled\r\n\r\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = _programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code.length === code.length && programInfo.code === code ) {\r\n\r\n\t\t\t\tprogramInfo.usedTimes ++;\r\n\r\n\t\t\t\treturn programInfo.program;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\r\n\r\n\t\t}\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\tprogram = _gl.createProgram();\r\n\r\n\t\tvar supportsShaderTextureLOD = ( _glExtensionShaderTextureLOD !== null );\r\n\r\n\t\tvar prefix_vertex = [\r\n\r\n\t\t\t\"precision \" + _precision + \" float;\",\r\n\t\t\t\"precision \" + _precision + \" int;\",\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\r\n\r\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\r\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\r\n\r\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\r\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\r\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\r\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\r\n\t\t\t\"#define MAX_AREA_LIGHTS \" + parameters.maxAreaLights,\r\n\r\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\r\n\r\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\r\n\r\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\r\n\t\t\tparameters.opacityMap ? \"#define USE_OPACITYMAP\" : \"\",\r\n\t\t\tparameters.falloffMap ? \"#define USE_FALLOFFMAP\" : \"\",\r\n\t\t\tparameters.translucencyMap ? \"#define USE_TRANSLUCENCYMAP\" : \"\",\r\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\r\n\t\t\tparameters.diffuseEnvMap ? \"#define USE_DIFFUSEENVMAP\" : \"\",\r\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\r\n\t\t\tparameters.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\r\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\r\n\t\t\tparameters.reflectivityMap ? \"#define USE_REFLECTIVITYMAP\" : \"\",\r\n\t\t\tparameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\r\n\t\t\tparameters.metallicMap ? \"#define USE_METALLICMAP\" : \"\",\r\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\r\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\r\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\r\n\t\t\tparameters.clearCoat ? \"#define CLEARCOAT\" : \"\",\r\n\r\n\t\t\tparameters.anisotropy ? \"#define ANISOTROPY\" : \"\",\r\n\t\t\tparameters.anisotropyMap ? \"#define USE_ANISOTROPYMAP\" : \"\",\r\n\t\t\t( parameters.anisotropy && parameters.anisotropyRotation ) ? \"#define ANISOTROPYROTATION\" : \"\",\r\n\t\t\t( parameters.anisotropy && parameters.anisotropyRotationMap ) ? \"#define USE_ANISOTROPYROTATIONMAP\" : \"\",\r\n\r\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\r\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\r\n\r\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\r\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\r\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\r\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\r\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\r\n\r\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\r\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\r\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\r\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\r\n\r\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\r\n\r\n\t\t\t\"uniform mat4 modelMatrix;\",\r\n\t\t\t\"uniform mat4 modelViewMatrix;\",\r\n\t\t\t\"uniform mat4 projectionMatrix;\",\r\n\t\t\t\"uniform mat4 viewMatrix;\",\r\n\t\t\t\"uniform mat3 normalMatrix;\",\r\n\t\t\t\"uniform vec3 cameraPosition;\",\r\n\r\n\t\t\t\"attribute vec3 position;\",\r\n\t\t\t\"attribute vec3 normal;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\t\t\t\"attribute vec2 uv2;\",\r\n\r\n\t\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\t\"attribute vec3 color;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\t\"attribute vec3 morphTarget0;\",\r\n\t\t\t\t\"attribute vec3 morphTarget1;\",\r\n\t\t\t\t\"attribute vec3 morphTarget2;\",\r\n\t\t\t\t\"attribute vec3 morphTarget3;\",\r\n\r\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\"attribute vec4 skinIndex;\",\r\n\t\t\t\t\"attribute vec4 skinWeight;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"\"\r\n\r\n\t\t].join(\"\\n\");\r\n\r\n\r\n\t\tvar prefix_fragment = [\r\n\r\n\t\t\t\"precision \" + _precision + \" float;\",\r\n\t\t\t\"precision \" + _precision + \" int;\",\r\n\r\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\r\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\r\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\r\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\r\n\t\t\t\"#define MAX_AREA_LIGHTS \" + parameters.maxAreaLights,\r\n\r\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\r\n\r\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\r\n\r\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\r\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\r\n\r\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\r\n\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\r\n\r\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\r\n\t\t\tparameters.opacityMap ? \"#define USE_OPACITYMAP\" : \"\",\r\n\t\t\tparameters.falloffMap ? \"#define USE_FALLOFFMAP\" : \"\",\r\n\t\t\tparameters.translucencyMap ? \"#define USE_TRANSLUCENCYMAP\" : \"\",\r\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\r\n\t\t\tparameters.diffuseEnvMap ? \"#define USE_DIFFUSEENVMAP\" : \"\",\r\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\r\n\t\t\tparameters.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\r\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\r\n\t\t\tparameters.reflectivityMap ? \"#define USE_REFLECTIVITYMAP\" : \"\",\r\n\t\t\tparameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\r\n\t\t\tparameters.metallicMap ? \"#define USE_METALLICMAP\" : \"\",\r\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\r\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\r\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\r\n\t\t\tparameters.clearCoat ? \"#define CLEARCOAT\" : \"\",\r\n\r\n\t\t\tparameters.translucency ? \"#define TRANSLUCENCY\" : \"\",\r\n\r\n\t\t\tparameters.anisotropy ? \"#define ANISOTROPY\" : \"\",\r\n\t\t\tparameters.anisotropyMap ? \"#define USE_ANISOTROPYMAP\" : \"\",\r\n\t\t\t( parameters.anisotropy && parameters.anisotropyRotation ) ? \"#define ANISOTROPYROTATION\" : \"\",\r\n\t\t\t( parameters.anisotropy && parameters.anisotropyRotationMap ) ? \"#define USE_ANISOTROPYROTATIONMAP\" : \"\",\r\n\r\n\t\t\tparameters.falloff ? \"#define FALLOFF\" : \"\",\r\n\r\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\r\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\r\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\r\n\r\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\r\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\r\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\r\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\r\n\r\n\t\t\tsupportsShaderTextureLOD ? \"#define TEXTURE_CUBE_LOD_EXT\" : \"\",\r\n\r\n\t\t\t\"uniform mat4 viewMatrix;\",\r\n\t\t\t\"uniform vec3 cameraPosition;\",\r\n\t\t\t\"\"\r\n\r\n\t\t].join(\"\\n\");\r\n\r\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader, shaderID, simpleCode );\r\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader, shaderID, simpleCode );\r\n\r\n\t\t_gl.attachShader( program, glVertexShader, code );\r\n\t\t_gl.attachShader( program, glFragmentShader, code );\r\n\r\n\t\t// Force a particular attribute to index 0.\r\n\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\r\n\t\t// And, color, for example is often automatically bound to index 0 so disabling it\r\n\t\tif ( index0AttributeName !== undefined ) {\r\n\r\n\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\tvar programLogInfo = _gl.getProgramInfoLog( program );\r\n\r\n\t\tif ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {\r\n\r\n\t\t\tvar gl_error_message = _gl.getError();\r\n\t\t\tTHREE.onerror( shaderID + ' shader program error: ' + gl_error_message + '\\n ' + programLogInfo, {\r\n\t\t\t\tshaderID: shaderID,\r\n\t\t\t\tprogramInfo: programLogInfo,\r\n\t\t\t\tglError: gl_error_message,\r\n\t\t\t\tvertexShader: prefix_vertex + vertexShader,\r\n\t\t\t\tfragmentShader: prefix_fragment + fragmentShader, \r\n\t\t\t\tgetProgramParameter_LINK_STATUS: _gl.getProgramParameter( program, _gl.LINK_STATUS ),\r\n\t\t\t\tgetProgramParameter_VALIDATE_STATUS: _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ),\r\n\t\t\t\tgetProgramParameter_ATTACHED_SHADERS: _gl.getProgramParameter( program, _gl.ATTACHED_SHADERS ),\r\n\t\t\t\tgetProgramParameter_ACTIVE_ATTRIBUTES: _gl.getProgramParameter( program, _gl.ACTIVE_ATTRIBUTES ),\r\n\t\t\t\tgetProgramParameter_ACTIVE_UNIFORMS: _gl.getProgramParameter( program, _gl.ACTIVE_UNIFORMS ),\r\n\t\t\t\tgl_MAX_VARYING_VECTORS: _gl.getParameter(_gl.MAX_VARYING_VECTORS),\r\n\t\t\t\tgl_MAX_VERTEX_ATTRIBS: _gl.getParameter(_gl.MAX_VERTEX_ATTRIBS),\r\n\t\t\t\tgl_MAX_VERTEX_UNIFORM_VECTORS: _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS),\r\n\t\t\t\tgl_MAX_VERTEX_TEXTURE_IMAGE_UNITS: _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\r\n\t\t\t\tgl_MAX_FRAGMENT_UNIFORM_VECTORS: _gl.getParameter(_gl.MAX_FRAGMENT_UNIFORM_VECTORS),\r\n\t\t\t\tgl_MAX_TEXTURE_IMAGE_UNITS: _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS)\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\t_gl.deleteShader( glFragmentShader );\r\n\t\t_gl.deleteShader( glVertexShader );\r\n\r\n\t\tprogram.uniforms = {};\r\n\t\tprogram.attributes = {};\r\n\r\n\t\tvar identifiers, u, a, i;\r\n\r\n\t\t// cache uniform locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\r\n\t\t\t'morphTargetInfluences'\r\n\r\n\t\t];\r\n\r\n\t\tif ( parameters.useVertexTexture ) {\r\n\r\n\t\t\tidentifiers.push( 'boneTexture' );\r\n\t\t\tidentifiers.push( 'boneTextureWidth' );\r\n\t\t\tidentifiers.push( 'boneTextureHeight' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( u in uniforms ) {\r\n\r\n\t\t\tidentifiers.push( u );\r\n\r\n\t\t}\r\n\r\n\t\tcacheUniformLocations( program, identifiers );\r\n\r\n\t\t// cache attributes locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\r\n\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\r\n\r\n\t\t];\r\n\r\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( \"morphTarget\" + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( \"morphNormal\" + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( a in attributes ) {\r\n\r\n\t\t\tidentifiers.push( a );\r\n\r\n\t\t}\r\n\r\n\t\tcacheAttributeLocations( program, identifiers );\r\n\r\n\t\tprogram.id = _programs_counter ++;\r\n\r\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\r\n\r\n\t\t_this.info.memory.programs = _programs.length;\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\t// Shader parameters cache\r\n\r\n\tfunction cacheUniformLocations ( program, identifiers ) {\r\n\r\n\t\tvar i, l, id;\r\n\r\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tid = identifiers[ i ];\r\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction cacheAttributeLocations ( program, identifiers ) {\r\n\r\n\t\tvar i, l, id;\r\n\r\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tid = identifiers[ i ];\r\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction addLineNumbers ( string ) {\r\n\r\n\t\tvar chunks = string.split( \"\\n\" );\r\n\r\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\r\n\r\n\t\t\t// Chrome reports shader errors on lines\r\n\t\t\t// starting counting from 1\r\n\r\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( \"\\n\" );\r\n\r\n\t};\r\n\r\n\tfunction getShader ( type, string, shaderID, simpleCode ) {\r\n\r\n\t\tvar shader;\r\n\r\n\t\tif ( type === \"fragment\" ) {\r\n\r\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\r\n\t\t} else if ( type === \"vertex\" ) {\r\n\r\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.shaderSource( shader, string );\r\n\t\t_gl.compileShader( shader );\r\n\r\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\r\n\r\n\t\t\tTHREE.onerror( \"shader error: \" + shaderID + \".\" + type, {\r\n\t\t\t\tgetShaderParameter: _gl.getShaderParameter( shader, _gl.COMPILE_STATUS ),\r\n\t\t\t\tshaderInfoLog: _gl.getShaderInfoLog( shader ),\r\n\t\t\t\tshaderCode: addLineNumbers( string ),\r\n\t\t\t\tgetError: _gl.getError(),\r\n\t\t\t\tsimpleCode: simpleCode,\r\n\t\t\t\tgl_MAX_VARYING_VECTORS: _gl.getParameter(_gl.MAX_VARYING_VECTORS),\r\n\t\t\t\tgl_MAX_VERTEX_ATTRIBS: _gl.getParameter(_gl.MAX_VERTEX_ATTRIBS),\r\n\t\t\t\tgl_MAX_VERTEX_UNIFORM_VECTORS: _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS),\r\n\t\t\t\tgl_MAX_VERTEX_TEXTURE_IMAGE_UNITS: _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\r\n\t\t\t\tgl_MAX_FRAGMENT_UNIFORM_VECTORS: _gl.getParameter(_gl.MAX_FRAGMENT_UNIFORM_VECTORS),\r\n\t\t\t\tgl_MAX_TEXTURE_IMAGE_UNITS: _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS)\r\n\t\t\t} );\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n\t\tif ( isImagePowerOfTwo ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\r\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar _reportIfError = function ( description, optionalData ) {\r\n\t\tvar errorCode = _gl.getError();\r\n\t\tif( errorCode === _gl.NO_ERROR ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar errorMessage = \"\";\r\n\t\tif( errorCode === _gl.OUT_OF_MEMORY ) {\r\n\t\t\terrorMessage = \"OUT_OF_MEMORY\";\r\n\t\t}\r\n\t\telse if( errorCode === _gl.INVALID_ENUM ) {\r\n\t\t\terrorMessage = \"INVALID_ENUM\";\r\n\t\t}\r\n\t\telse if( errorCode === _gl.INVALID_OPERATION ) {\r\n\t\t\terrorMessage = \"INVALID_OPERATION\";\r\n\t\t}\r\n\t\telse if( errorCode === _gl.INVALID_VALUE ) {\r\n\t\t\terrorMessage = \"INVALID_VALUE\";\r\n\t\t}\r\n\t\telse if( errorCode === _gl.INVALID_FRAMEBUFFER_OPERATION ) {\r\n\t\t\terrorMessage = \"INVALID_FRAMEBUFFER_OPERATION\";\r\n\t\t}\r\n\t\telse if( errorCode === _gl.CONTEXT_LOST_WEBGL ) {\r\n\t\t\terrorMessage = \"CONTEXT_LOST_WEBGL\";\r\n\t\t}\r\n\t\telse if( errorCode === _gl.NO_ERROR ) {\r\n\t\t\terrorMessage = \"NO_ERROR\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\terrorMessage = \"Unknown code: \" + errorCode;\r\n\t\t}\r\n\t\tTHREE.onerror( \"WebGL Error: \" + errorMessage + \" (\" + description + \")\", optionalData );\r\n\t};\r\n\r\n\tthis.setTexture = function ( texture, slot ) {\t\r\n\r\n\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\tif ( ! texture.__webglInit ) {\r\n\r\n\t\t\t\ttexture.__webglInit = true;\r\n\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\t\tvar image = texture.image,\r\n\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\t\t\t\t\t_reportIfError( \"_gl.texImage2D DataTexture Mipmaps, texture.name: \" + texture.name, texture );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\t\t\t\t_reportIfError( \"_gl.texImage2D DataTexture, texture.name: \" + texture.name, texture );\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tif ( texture.format!==THREE.RGBAFormat ) {\r\n\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\t\t\t\t\t_reportIfError( \"_gl.texImage2D CompressedTexture Non RGBA, texture.name: \" + texture.name, texture );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\t\t\t\t\t_reportIfError( \"_gl.texImage2D CompressedTexture, texture.name: \" + texture.name, texture );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // regular Texture (image, video, canvas)\r\n\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\t\t\t\t\t\t_reportIfError( \"_gl.texImage2D Mipmaps, texture.name: \" + texture.name, texture );\r\n\t\t\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\t\t\t\t\t_reportIfError( \"_gl.texImage2D, texture.name: \" + texture.name, texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\t_reportIfError( \"_gl.generateMipmap, texture.name: \" + texture.name, texture );\r\n\t\t\t}\r\n\t\t\r\n\r\n\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\r\n\r\n\t\t\treturn image;\r\n\r\n\t\t}\r\n\r\n\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t// premultiplied alpha.\r\n\r\n\t\tvar maxDimension = Math.max( image.width, image.height );\r\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\r\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = newWidth;\r\n\t\tcanvas.height = newHeight;\r\n\r\n\t\tvar ctx = canvas.getContext( \"2d\" );\r\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\r\n\r\n\t\treturn canvas;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif( !isCompressed ) {\r\n\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\t\t\t\t\t\t_reportIfError( \"_gl.texImage2D CubeMap, texture.name: \" + texture.name, { texture: texture, cubeImage: cubeImage, index: i } );\r\n\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\t\t\t\t\t\tif ( texture.format!==THREE.RGBAFormat ) {\r\n\r\n\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\t\t\t\t\t\t\t_reportIfError( \"_gl.compressedTexImage2D CubeMap Mipmaps Compressed, texture.name: \" + texture.name, texture );\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\t\t\t\t\t\t\t_reportIfError( \"_gl.texImage2D CubeMap Mipmaps Compressed RGBA, texture.name: \" + texture.name, texture );\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\t\t_reportIfError( \"_gl.generateMipmap CubeMap Mipmaps, texture.name: \" + texture.name, texture );\r\n\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\r\n\t};\r\n\r\n\t// Render targets\r\n\r\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\r\n\t};\r\n\r\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tvar optionsString = \"\";\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t\toptionsString = \"renderTarget: \" + renderTarget.width + \"+\" + renderTarget.height + \" DEPTH_ATTACHMENT\";\r\n\r\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t*/\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t\toptionsString = \"renderTarget: \" + renderTarget.width + \"+\" + renderTarget.height + \" DEPTH_STENCIL_ATTACHMENT\";\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t\toptionsString = \"renderTarget: \" + renderTarget.width + \"+\" + renderTarget.height + \" RGBA4\";\r\n\r\n\t\t}\r\n\r\n\t\tif (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) != _gl.FRAMEBUFFER_COMPLETE) {\r\n\t\t\tconsole.log( renderTarget );\r\n\t    \tthrow new Error('(A) Rendering to this texture (renderTarget.name: ' + renderTarget.name + ') is not supported (incomplete framebuffer) ' + optionsString );\r\n\t    }\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\r\n\r\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t// Setup texture, create render and frame buffers\r\n\r\n\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t\t\t\t_reportIfError( \"_gl.texImage2D CubeMap, renderTarget.name: \" + renderTarget.name, renderTarget );\r\n\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) {\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\t\t_reportIfError( \"_gl.generateMipmap, CubeMap, renderTarget.name: \" + renderTarget.name, renderTarget );\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t\t\t_reportIfError( \"_gl.texImage2D, renderTarget.name: \" + renderTarget.name, renderTarget );\r\n\r\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\tvar optionsString = \"glFormat: \" + glFormat + \" glType: \" + glType;\r\n\r\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t\toptionsString = \" renderTarget: \" + renderTarget.width + \"+\" + renderTarget.height + \" DEPTH_ATTACHMENT\";\r\n\r\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t\toptionsString = \" renderTarget: \" + renderTarget.width + \"+\" + renderTarget.height + \" DEPTH_STENCIL_ATTACHMENT\";\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) != _gl.FRAMEBUFFER_COMPLETE) {\r\n\t\t\t\t\t\tthrow new Error('(B) Rendering to this texture (renderTarget.name: ' + renderTarget.name + ') is not supported (incomplete framebuffer) ' + optionsString );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) {\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\t\t_reportIfError( \"_gl.generateMipmap, renderTarget.name: \" + renderTarget.name, renderTarget );\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Release everything\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer, width, height, vx, vy;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = renderTarget.width;\r\n\t\t\theight = renderTarget.height;\r\n\r\n\t\t\tvx = 0;\r\n\t\t\tvy = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\twidth = _viewportWidth;\r\n\t\t\theight = _viewportHeight;\r\n\r\n\t\t\tvx = _viewportX;\r\n\t\t\tvy = _viewportY;\r\n\r\n\t\t}\r\n\r\n\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.viewport( vx, vy, width, height );\r\n\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\t_currentWidth = width;\r\n\t\t_currentHeight = height;\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t_reportIfError( \"_gl.generateMipmap CubeMap, renderTarget.name: \" + renderTarget.name, renderTarget );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t_reportIfError( \"_gl.generateMipmap, renderTarget.name: \" + renderTarget.name, renderTarget );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t};\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\t\tif ( p === THREE.HalfType ) return 0x8D61;\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\t// Allocations\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader\r\n\t\t\t//   to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t// \t- leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.bones.length ) {\r\n\r\n\t\t\t\t\tTHREE.onwarning( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction allocateLights( lights ) {\r\n\r\n\t\tvar dirLights = 0;\r\n\t\tvar pointLights = 0;\r\n\t\tvar spotLights = 0;\r\n\t\tvar hemiLights = 0;\r\n\t\tvar areaLights = 0;\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow || light.visible === false ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\t\t\tif ( light instanceof THREE.AreaLight ) areaLights ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights, 'area': areaLights };\r\n\r\n\t};\r\n\r\n\tfunction allocateShadows( lights ) {\r\n\r\n\t\tvar maxShadows = 0;\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn maxShadows;\r\n\r\n\t};\r\n\r\n\t// Initialization\r\n\r\n\tfunction initGL() {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tvar attributes = {\r\n\t\t\t\talpha: _alpha,\r\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\t\tantialias: _antialias,\r\n\t\t\t\tstencil: _stencil,\r\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t\t};\r\n\r\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n\t\t\tif ( _gl === null ) {\r\n\r\n\t\t\t\tTHREE.onerror( 'Error creating WebGL context.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tTHREE.onerror( error );\r\n\r\n\t\t}\r\n\r\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\r\n\t\t_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );\r\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\r\n\t\t_glExtensionShaderTextureLOD = _gl.getExtension( 'EXT_shader_texture_lod' );\r\n\r\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\r\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( ! _glExtensionTextureFloat ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionStandardDerivatives ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionShaderTextureLOD ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Shader texture LOD not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t\t_gl.getShaderPrecisionFormat = function() {\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"rangeMin\"  : 1,\r\n\t\t\t\t\t\"rangeMax\"  : 1,\r\n\t\t\t\t\t\"precision\" : 1\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setDefaultGLState () {\r\n\r\n\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t_gl.clearDepth( 1 );\r\n\t\t_gl.clearStencil( 0 );\r\n\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( _gl.BACK );\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t_gl.enable( _gl.BLEND );\r\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\t// default plugins (order is important)\r\n\r\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\r\n\tthis.addPrePlugin( this.shadowMapPlugin );\r\n\r\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\r\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\r\n\r\n};\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options, name ) {\r\n\r\n\tthis.name = name || \"\";\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n\tthis.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\r\n\r\n\tthis.shareDepthFrom = null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n\tconstructor: THREE.WebGLRenderTarget,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height, null, this.name + \" Clone\" );\r\n\r\n\t\ttmp.wrapS = this.wrapS;\r\n\t\ttmp.wrapT = this.wrapT;\r\n\r\n\t\ttmp.magFilter = this.magFilter;\r\n\t\ttmp.minFilter = this.minFilter;\r\n\r\n\t\ttmp.anisotropy = this.anisotropy;\r\n\r\n\t\ttmp.offset.copy( this.offset );\r\n\t\ttmp.repeat.copy( this.repeat );\r\n\r\n\t\ttmp.format = this.format;\r\n\t\ttmp.type = this.type;\r\n\r\n\t\ttmp.depthBuffer = this.depthBuffer;\r\n\t\ttmp.stencilBuffer = this.stencilBuffer;\r\n\r\n\t\ttmp.generateMipmaps = this.generateMipmaps;\r\n\r\n\t\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\r\n\t\treturn tmp;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableVertex = function () {\r\n\r\n\tthis.position = new THREE.Vector3();\r\n\tthis.positionWorld = new THREE.Vector3();\r\n\tthis.positionScreen = new THREE.Vector4();\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\r\n\r\n\tthis.positionWorld.copy( vertex.positionWorld );\r\n\tthis.positionScreen.copy( vertex.positionScreen );\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableFace = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\tthis.v3 = new THREE.RenderableVertex();\r\n\r\n\tthis.centroidModel = new THREE.Vector3();\r\n\r\n\tthis.normalModel = new THREE.Vector3();\r\n\r\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\tthis.vertexNormalsLength = 0;\r\n\r\n\tthis.color = null;\r\n\tthis.material = null;\r\n\tthis.uvs = [[]];\r\n\r\n\tthis.z = 0;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableObject = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.object = null;\r\n\tthis.z = 0;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableSprite = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.object = null;\r\n\r\n\tthis.x = 0;\r\n\tthis.y = 0;\r\n\tthis.z = 0;\r\n\r\n\tthis.rotation = 0;\r\n\tthis.scale = new THREE.Vector2();\r\n\r\n\tthis.material = null;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableLine = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\r\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\r\n\tthis.material = null;\r\n\r\n\tthis.z = 0;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\r\n\r\n\tmerge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {\r\n\r\n\t\tvar matrix, normalMatrix,\r\n\t\tvertexOffset = geometry1.vertices.length,\r\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\r\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\r\n\t\tvertices1 = geometry1.vertices,\r\n\t\tvertices2 = geometry2.vertices,\r\n\t\tfaces1 = geometry1.faces,\r\n\t\tfaces2 = geometry2.faces,\r\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( object2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\r\n\r\n\t\t\tmatrix = object2.matrix;\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaceCopy.centroid.copy( face.centroid );\r\n\r\n\t\t\tif ( matrix ) {\r\n\r\n\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Get random point in triangle (via barycentric coordinates)\r\n\t// \t(uniform distribution)\r\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\r\n\r\n\trandomPointInTriangle: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\t\tvar point = new THREE.Vector3();\r\n\r\n\t\t\tvar a = THREE.Math.random16();\r\n\t\t\tvar b = THREE.Math.random16();\r\n\r\n\t\t\tif ( ( a + b ) > 1 ) {\r\n\r\n\t\t\t\ta = 1 - a;\r\n\t\t\t\tb = 1 - b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar c = 1 - a - b;\r\n\r\n\t\t\tpoint.copy( vectorA );\r\n\t\t\tpoint.multiplyScalar( a );\r\n\r\n\t\t\tvector.copy( vectorB );\r\n\t\t\tvector.multiplyScalar( b );\r\n\r\n\t\t\tpoint.add( vector );\r\n\r\n\t\t\tvector.copy( vectorC );\r\n\t\t\tvector.multiplyScalar( c );\r\n\r\n\t\t\tpoint.add( vector );\r\n\r\n\t\t\treturn point;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// Get random point in face (triangle / quad)\r\n\t// (uniform distribution)\r\n\r\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\r\n\r\n\t\tvar vA, vB, vC, vD;\r\n\r\n\t\tvA = geometry.vertices[ face.a ];\r\n\t\tvB = geometry.vertices[ face.b ];\r\n\t\tvC = geometry.vertices[ face.c ];\r\n\r\n\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\r\n\r\n\t},\r\n\r\n\t// Get uniformly distributed random points in mesh\r\n\t// \t- create array with cumulative sums of face areas\r\n\t//  - pick random number from 0 to total area\r\n\t//  - find corresponding place in area array by binary search\r\n\t//\t- get random point in face\r\n\r\n\trandomPointsInGeometry: function ( geometry, n ) {\r\n\r\n\t\tvar face, i,\r\n\t\t\tfaces = geometry.faces,\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\til = faces.length,\r\n\t\t\ttotalArea = 0,\r\n\t\t\tcumulativeAreas = [],\r\n\t\t\tvA, vB, vC, vD;\r\n\r\n\t\t// precompute face areas\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tface = faces[ i ];\r\n\r\n\t\t\tvA = vertices[ face.a ];\r\n\t\t\tvB = vertices[ face.b ];\r\n\t\t\tvC = vertices[ face.c ];\r\n\r\n\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\r\n\r\n\t\t\ttotalArea += face._area;\r\n\r\n\t\t\tcumulativeAreas[ i ] = totalArea;\r\n\r\n\t\t}\r\n\r\n\t\t// binary search cumulative areas array\r\n\r\n\t\tfunction binarySearchIndices( value ) {\r\n\r\n\t\t\tfunction binarySearch( start, end ) {\r\n\r\n\t\t\t\t// return closest larger index\r\n\t\t\t\t// if exact number is not found\r\n\r\n\t\t\t\tif ( end < start )\r\n\t\t\t\t\treturn start;\r\n\r\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\r\n\r\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\r\n\r\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( mid + 1, end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn mid;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// pick random face weighted by face area\r\n\r\n\t\tvar r, index,\r\n\t\t\tresult = [];\r\n\r\n\t\tvar stats = {};\r\n\r\n\t\tfor ( i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tr = THREE.Math.random16() * totalArea;\r\n\r\n\t\t\tindex = binarySearchIndices( r );\r\n\r\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\r\n\r\n\t\t\tif ( ! stats[ index ] ) {\r\n\r\n\t\t\t\tstats[ index ] = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstats[ index ] += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Get triangle area (half of parallelogram)\r\n\t//\thttp://mathworld.wolfram.com/TriangleArea.html\r\n\r\n\ttriangleArea: function () {\r\n\r\n\t\tvar vector1 = new THREE.Vector3();\r\n\t\tvar vector2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\t\tvector1.subVectors( vectorB, vectorA );\r\n\t\t\tvector2.subVectors( vectorC, vectorA );\r\n\t\t\tvector1.cross( vector2 );\r\n\r\n\t\t\treturn 0.5 * vector1.length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// Center geometry so that 0,0,0 is in center of bounding box\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t\tvar bb = geometry.boundingBox;\r\n\r\n\t\tvar offset = new THREE.Vector3();\r\n\r\n\t\toffset.addVectors( bb.min, bb.max );\r\n\t\toffset.multiplyScalar( -0.5 );\r\n\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\ttriangulateQuads: function ( geometry ) {\r\n\r\n\t\tvar i, il, j, jl;\r\n\r\n\t\tvar faces = [];\r\n\t\tvar faceVertexUvs = [];\r\n\r\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tfaceVertexUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = geometry.faces[ i ];\r\n\r\n\t\t\tfaces.push( face );\r\n\r\n\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.faces = faces;\r\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\r\n\r\n\t\tgeometry.computeCentroids();\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\r\n\t\tvar texture = new THREE.Texture( undefined, mapping );\r\n\r\n\t\tvar image = loader.load( url, function () {\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t} );\r\n\r\n\t\ttexture.image = image;\r\n\t\ttexture.sourceFile = url;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.mapping = mapping;\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\trequest.onload = function () {\r\n\r\n\t\t\tvar buffer = request.response;\r\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\ttexture.format = dds.format;\r\n\r\n\t\t\ttexture.mipmaps = dds.mipmaps;\r\n\t\t\ttexture.image.width = dds.width;\r\n\t\t\ttexture.image.height = dds.height;\r\n\r\n\t\t\t// gl.generateMipmap fails for compressed textures\r\n\t\t\t// mipmaps must be embedded in the DDS file\r\n\t\t\t// or texture filters must not use mipmapping\r\n\r\n\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t}\r\n\r\n\t\trequest.onerror = onError;\r\n\r\n\t\trequest.open( 'GET', url, true );\r\n\t\trequest.responseType = \"arraybuffer\";\r\n\t\trequest.send( null );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.Texture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping needed for cube textures\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\tvar cubeImage = new Image();\r\n\t\t\timages[ i ] = cubeImage;\r\n\r\n\t\t\tcubeImage.onload = function () {\r\n\r\n\t\t\t\timages.loadCount += 1;\r\n\r\n\t\t\t\tif ( images.loadCount === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tcubeImage.onerror = onError;\r\n\r\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\r\n\t\t\tcubeImage.src = array[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\r\n\t\ttexture.generateMipmaps = false;\r\n\r\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\r\n\r\n\t\t\treturn function () {\r\n\r\n\t\t\t\tvar buffer = rq.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\timg.format = dds.format;\r\n\r\n\t\t\t\timg.mipmaps = dds.mipmaps;\r\n\t\t\t\timg.width = dds.width;\r\n\t\t\t\timg.height = dds.height;\r\n\r\n\t\t\t\timages.loadCount += 1;\r\n\r\n\t\t\t\tif ( images.loadCount === 6 ) {\r\n\r\n\t\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compressed cubemap textures as 6 separate DDS files\r\n\r\n\t\tif ( array instanceof Array ) {\r\n\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tvar cubeImage = {};\r\n\t\t\t\timages[ i ] = cubeImage;\r\n\r\n\t\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\r\n\t\t\t\trequest.onerror = onError;\r\n\r\n\t\t\t\tvar url = array[ i ];\r\n\r\n\t\t\t\trequest.open( 'GET', url, true );\r\n\t\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\t\trequest.send( null );\r\n\r\n\t\t\t}\r\n\r\n\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar url = array;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\trequest.onload = function( ) {\r\n\r\n\t\t\t\tvar buffer = request.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\tif ( dds.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\r\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\r\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\trequest.onerror = onError;\r\n\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.send( null );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadDDSTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\r\n\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t{\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\trequest.onload = function( ) {\r\n\r\n\t\t\t\tvar buffer = request.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\tif ( dds.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\r\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\r\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttexture.image.width = dds.width;\r\n\t\t\t\t\ttexture.image.height = dds.height;\r\n\t\t\t\t\ttexture.mipmaps = dds.mipmaps;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\trequest.onerror = onError;\r\n\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.send( null );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tparseDDS: function ( buffer, loadMipmaps ) {\r\n\r\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\r\n\r\n\t\t// Adapted from @toji's DDS utils\r\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\r\n\r\n\t\t// All values and structures referenced from:\r\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\n\r\n\t\tvar DDS_MAGIC = 0x20534444;\r\n\r\n\t\tvar DDSD_CAPS = 0x1,\r\n\t\t\tDDSD_HEIGHT = 0x2,\r\n\t\t\tDDSD_WIDTH = 0x4,\r\n\t\t\tDDSD_PITCH = 0x8,\r\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\r\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\r\n\t\t\tDDSD_LINEARSIZE = 0x80000,\r\n\t\t\tDDSD_DEPTH = 0x800000;\r\n\r\n\t\tvar DDSCAPS_COMPLEX = 0x8,\r\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\r\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\r\n\r\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\r\n\r\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\r\n\t\t\tDDPF_ALPHA = 0x2,\r\n\t\t\tDDPF_FOURCC = 0x4,\r\n\t\t\tDDPF_RGB = 0x40,\r\n\t\t\tDDPF_YUV = 0x200,\r\n\t\t\tDDPF_LUMINANCE = 0x20000;\r\n\r\n\t\tfunction fourCCToInt32( value ) {\r\n\r\n\t\t\treturn value.charCodeAt(0) +\r\n\t\t\t\t(value.charCodeAt(1) << 8) +\r\n\t\t\t\t(value.charCodeAt(2) << 16) +\r\n\t\t\t\t(value.charCodeAt(3) << 24);\r\n\r\n\t\t}\r\n\r\n\t\tfunction int32ToFourCC( value ) {\r\n\r\n\t\t\treturn String.fromCharCode(\r\n\t\t\t\tvalue & 0xff,\r\n\t\t\t\t(value >> 8) & 0xff,\r\n\t\t\t\t(value >> 16) & 0xff,\r\n\t\t\t\t(value >> 24) & 0xff\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\r\n\t\t\tvar dataLength = width*height*4;\r\n\t\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\r\n\t\t\tvar byteArray = new Uint8Array( dataLength );\r\n\t\t\tvar dst = 0;\r\n\t\t\tvar src = 0;\r\n\t\t\tfor ( var y = 0; y < height; y++ ) {\r\n\t\t\t\tfor ( var x = 0; x < width; x++ ) {\r\n\t\t\t\t\tvar b = srcBuffer[src]; src++;\r\n\t\t\t\t\tvar g = srcBuffer[src]; src++;\r\n\t\t\t\t\tvar r = srcBuffer[src]; src++;\r\n\t\t\t\t\tvar a = srcBuffer[src]; src++;\r\n\t\t\t\t\tbyteArray[dst] = r; dst++;\t//r\r\n\t\t\t\t\tbyteArray[dst] = g; dst++;\t//g\r\n\t\t\t\t\tbyteArray[dst] = b; dst++;\t//b\r\n\t\t\t\t\tbyteArray[dst] = a; dst++;\t//a\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn byteArray;\r\n\t\t}\r\n\r\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n\t\t// Offsets into the header array\r\n\r\n\t\tvar off_magic = 0;\r\n\r\n\t\tvar off_size = 1;\r\n\t\tvar off_flags = 2;\r\n\t\tvar off_height = 3;\r\n\t\tvar off_width = 4;\r\n\r\n\t\tvar off_mipmapCount = 7;\r\n\r\n\t\tvar off_pfFlags = 20;\r\n\t\tvar off_pfFourCC = 21;\r\n\t\tvar off_RGBBitCount = 22;\r\n\t\tvar off_RBitMask = 23;\r\n\t\tvar off_GBitMask = 24;\r\n\t\tvar off_BBitMask = 25;\r\n\t\tvar off_ABitMask = 26;\r\n\r\n\t\tvar off_caps = 27;\r\n\t\tvar off_caps2 = 28;\r\n\t\tvar off_caps3 = 29;\r\n\t\tvar off_caps4 = 30;\r\n\r\n\t\t// Parse header\r\n\r\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\r\n\r\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\r\n\r\n\t\t\tTHREE.onerror( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\r\n\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\r\n\r\n\t\t\tTHREE.onerror( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\r\n\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tvar blockBytes;\r\n\r\n\t\tvar fourCC = header[ off_pfFourCC ];\r\n\r\n\t\tvar isRGBAUncompressed = false;\r\n\r\n\t\tswitch ( fourCC ) {\r\n\r\n\t\t\tcase FOURCC_DXT1:\r\n\r\n\t\t\t\tblockBytes = 8;\r\n\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FOURCC_DXT3:\r\n\r\n\t\t\t\tblockBytes = 16;\r\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FOURCC_DXT5:\r\n\r\n\t\t\t\tblockBytes = 16;\r\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tif( header[off_RGBBitCount] ==32 \r\n\t\t\t\t\t&& header[off_RBitMask]&0xff0000\r\n\t\t\t\t\t&& header[off_GBitMask]&0xff00 \r\n\t\t\t\t\t&& header[off_BBitMask]&0xff\r\n\t\t\t\t\t&& header[off_ABitMask]&0xff000000  ) {\r\n\t\t\t\t\tisRGBAUncompressed = true;\r\n\t\t\t\t\tblockBytes = 64;\r\n\t\t\t\t\tdds.format = THREE.RGBAFormat;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tTHREE.onerror( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\r\n\t\t\t\t\treturn dds;\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tdds.mipmapCount = 1;\r\n\r\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\r\n\r\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\r\n\r\n\t\t}\r\n\r\n\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\r\n\r\n\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\r\n\r\n\t\tdds.width = header[ off_width ];\r\n\t\tdds.height = header[ off_height ];\r\n\r\n\t\tvar dataOffset = header[ off_size ] + 4;\r\n\r\n\t\t// Extract mipmaps buffers\r\n\r\n\t\tvar width = dds.width;\r\n\t\tvar height = dds.height;\r\n\r\n\t\tvar faces = dds.isCubemap ? 6 : 1;\r\n\r\n\t\tfor ( var face = 0; face < faces; face ++ ) {\r\n\r\n\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\tif( isRGBAUncompressed ) {\r\n\t\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\r\n\t\t\t\t\tvar dataLength = byteArray.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\r\n\t\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\r\n\t\t\t\tdds.mipmaps.push( mipmap );\r\n\r\n\t\t\t\tdataOffset += dataLength;\r\n\r\n\t\t\t\twidth = Math.max( width * 0.5, 1 );\r\n\t\t\t\theight = Math.max( height * 0.5, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = dds.width;\r\n\t\t\theight = dds.height;\r\n\r\n\t\t}\r\n\r\n\t\treturn dds;\r\n\r\n\t},\r\n\r\n\tgetNormalMap: function ( image, depth ) {\r\n\r\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n\t\tvar cross = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar subtract = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar normalize = function ( a ) {\r\n\r\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n\t\t}\r\n\r\n\t\tdepth = depth | 1;\r\n\r\n\t\tvar width = image.width;\r\n\t\tvar height = image.height;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\tvar imageData = context.createImageData( width, height );\r\n\t\tvar output = imageData.data;\r\n\r\n\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n\t\t\t\tvar points = [];\r\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n\t\t\t\tvar normals = [];\r\n\t\t\t\tvar num_points = points.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\r\n\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\r\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\r\n\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\r\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 3 ] = 255;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn canvas;\r\n\r\n\t},\r\n\r\n\tgenerateDataTexture: function ( width, height, color ) {\r\n\r\n\t\tvar size = width * height;\r\n\t\tvar data = new Uint8Array( 3 * size );\r\n\r\n\t\tvar r = Math.floor( color.r * 255 );\r\n\t\tvar g = Math.floor( color.g * 255 );\r\n\t\tvar b = Math.floor( color.b * 255 );\r\n\r\n\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\tdata[ i * 3 ] \t  = r;\r\n\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\tdata[ i * 3 + 2 ] = b;\r\n\r\n\t\t}\r\n\r\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Object3D();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach : function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n * \ttypeface.js and canvastext\r\n * \t\tFor converting fonts and rendering with javascript\r\n *\t\thttp://typeface.neocracy.org\r\n *\r\n *\tTriangulation ported from AS3\r\n *\t\tSimple Polygon Triangulation\r\n *\t\thttp://actionsnippet.com/?p=1462\r\n *\r\n * \tA Method to triangulate shapes with holes\r\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n\tfaces : {},\r\n\r\n\t// Just for now. face[weight][style]\r\n\r\n\tface : \"helvetiker\",\r\n\tweight: \"normal\",\r\n\tstyle : \"normal\",\r\n\tsize : 150,\r\n\tdivisions : 10,\r\n\r\n\tgetFace : function() {\r\n\r\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\r\n\t},\r\n\r\n\tloadFace : function( data ) {\r\n\r\n\t\tvar family = data.familyName.toLowerCase();\r\n\r\n\t\tvar ThreeFont = this;\r\n\r\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tdrawText : function( text ) {\r\n\r\n\t\tvar characterPts = [], allPts = [];\r\n\r\n\t\t// RenderText\r\n\r\n\t\tvar i, p,\r\n\t\t\tface = this.getFace(),\r\n\t\t\tscale = this.size / face.resolution,\r\n\t\t\toffset = 0,\r\n\t\t\tchars = String( text ).split( '' ),\r\n\t\t\tlength = chars.length;\r\n\r\n\t\tvar fontPaths = [];\r\n\r\n\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\toffset += ret.offset;\r\n\r\n\t\t\tfontPaths.push( ret.path );\r\n\r\n\t\t}\r\n\r\n\t\t// get the width\r\n\r\n\t\tvar width = offset / 2;\r\n\t\t//\r\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t//\r\n\t\t// \tallPts[ p ].x -= width;\r\n\t\t//\r\n\t\t// }\r\n\r\n\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t//extract.contour = allPts;\r\n\r\n\t\t//extract.paths = fontPaths;\r\n\t\t//extract.offset = width;\r\n\r\n\t\treturn { paths : fontPaths, offset : width };\r\n\r\n\t},\r\n\r\n\r\n\r\n\r\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\r\n\r\n\t\tvar pts = [];\r\n\r\n\t\tvar i, i2, divisions,\r\n\t\t\toutline, action, length,\r\n\t\t\tscaleX, scaleY,\r\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\tlaste,\r\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n\t\tif ( !glyph ) return;\r\n\r\n\t\tif ( glyph.o ) {\r\n\r\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\tlength = outline.length;\r\n\r\n\t\t\tscaleX = scale;\r\n\t\t\tscaleY = scale;\r\n\r\n\t\t\tfor ( i = 0; i < length; ) {\r\n\r\n\t\t\t\taction = outline[ i ++ ];\r\n\r\n\t\t\t\t//console.log( action );\r\n\r\n\t\t\t\tswitch( action ) {\r\n\r\n\t\t\t\tcase 'm':\r\n\r\n\t\t\t\t\t// Move To\r\n\r\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l':\r\n\r\n\t\t\t\t\t// Line To\r\n\r\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\r\n\t\t\t\t\tpath.lineTo(x,y);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'q':\r\n\r\n\t\t\t\t\t// QuadraticCurveTo\r\n\r\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t  }\r\n\r\n\t\t\t\t  }\r\n\r\n\t\t\t\t  break;\r\n\r\n\t\t\t\tcase 'b':\r\n\r\n\t\t\t\t\t// Cubic Bezier Curve\r\n\r\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\r\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\r\n\r\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn { offset: glyph.ha*scale, path:path};\r\n\t}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\r\n\r\n\t// Parameters \r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\r\n\r\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\r\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\r\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\r\n\r\n\tTHREE.FontUtils.size = size;\r\n\tTHREE.FontUtils.divisions = curveSegments;\r\n\r\n\tTHREE.FontUtils.face = font;\r\n\tTHREE.FontUtils.weight = weight;\r\n\tTHREE.FontUtils.style = style;\r\n\r\n\t// Get a Font data json object\r\n\r\n\tvar data = THREE.FontUtils.drawText( text );\r\n\r\n\tvar paths = data.paths;\r\n\tvar shapes = [];\r\n\r\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t}\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function( namespace ) {\r\n\r\n\tvar EPSILON = 0.0000000001;\r\n\r\n\t// takes in an contour array and returns\r\n\r\n\tvar process = function( contour, indices ) {\r\n\r\n\t\tvar n = contour.length;\r\n\r\n\t\tif ( n < 3 ) return null;\r\n\r\n\t\tvar result = [],\r\n\t\t\tverts = [],\r\n\t\t\tvertIndices = [];\r\n\r\n\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\tvar u, v, w;\r\n\r\n\t\tif ( area( contour ) > 0.0 ) {\r\n\r\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t}\r\n\r\n\t\tvar nv = n;\r\n\r\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\tfor( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\tif ( ( count-- ) <= 0 ) {\r\n\r\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\tTHREE.onwarning( \"Warning, unable to triangulate polygon!\" );\r\n\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\ta = verts[ u ];\r\n\t\t\t\tb = verts[ v ];\r\n\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\r\n\r\n\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnv--;\r\n\r\n\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices ) return vertIndices;\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tvar area = function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t};\r\n\r\n\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n\t\tvar p;\r\n\t\tvar ax, ay, bx, by;\r\n\t\tvar cx, cy, px, py;\r\n\r\n\t\tax = contour[ verts[ u ] ].x;\r\n\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\tbx = contour[ verts[ v ] ].x;\r\n\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\tcx = contour[ verts[ w ] ].x;\r\n\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\r\n\r\n\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\taX = cx - bx;  aY = cy - by;\r\n\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\tfor ( p = 0; p < n; p++ ) {\r\n\r\n\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\tpy = contour[ verts[ p ] ].y\r\n\r\n\t\t\tif ( ( (px === ax) && (py === ay) ) ||\r\n\t\t\t\t ( (px === bx) && (py === by) ) ||\r\n\t\t\t\t ( (px === cx) && (py === cy) ) )\tcontinue;\r\n\r\n\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\taCROSSbp = aX*bpy - aY*bpx;\r\n\t\t\tcCROSSap = cX*apy - cY*apx;\r\n\t\t\tbCROSScp = bX*cpy - bY*cpx;\r\n\r\n\t\t\tif ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n\r\n\tnamespace.Triangulate = process;\r\n\tnamespace.Triangulate.area = area;\r\n\r\n\treturn namespace;\r\n\r\n})(THREE.FontUtils);\r\n\r\n// To use the typeface.js face files, hook up the API\r\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\nTHREE.typeface_js = self._typeface_js;\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//\t- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n\tTHREE.onwarning( \"Warning, getPoint() not implemented!\" );\r\n\treturn null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n\tvar lengths = this.getLengths();\r\n\treturn lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\r\n\r\n\tif ( this.cacheArcLengths\r\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t&& !this.needsUpdate) {\r\n\r\n\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\treturn this.cacheArcLengths;\r\n\r\n\t}\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n\tvar cache = [];\r\n\tvar current, last = this.getPoint( 0 );\r\n\tvar p, sum = 0;\r\n\r\n\tcache.push( 0 );\r\n\r\n\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\tsum += current.distanceTo( last );\r\n\t\tcache.push( sum );\r\n\t\tlast = current;\r\n\r\n\t}\r\n\r\n\tthis.cacheArcLengths = cache;\r\n\r\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n\tthis.needsUpdate = true;\r\n\tthis.getLengths();\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n\tvar arcLengths = this.getLengths();\r\n\r\n\tvar i = 0, il = arcLengths.length;\r\n\r\n\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\tif ( distance ) {\r\n\r\n\t\ttargetArcLength = distance;\r\n\r\n\t} else {\r\n\r\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t}\r\n\r\n\t//var time = Date.now();\r\n\r\n\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\tvar low = 0, high = il - 1, comparison;\r\n\r\n\twhile ( low <= high ) {\r\n\r\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\tlow = i + 1;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\thigh = i - 1;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else {\r\n\r\n\t\t\thigh = i;\r\n\t\t\tbreak;\r\n\r\n\t\t\t// DONE\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ti = high;\r\n\r\n\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\r\n\t\tvar t = i / ( il - 1 );\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\r\n\tvar lengthBefore = arcLengths[ i ];\r\n    var lengthAfter = arcLengths[ i + 1 ];\r\n\r\n    var segmentLength = lengthAfter - lengthBefore;\r\n\r\n    // determine where we are between the 'before' and 'after' points\r\n\r\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n    // add that fractional amount to t\r\n\r\n    var t = ( i + segmentFraction ) / ( il -1 );\r\n\r\n\treturn t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n\tvar delta = 0.0001;\r\n\tvar t1 = t - delta;\r\n\tvar t2 = t + delta;\r\n\r\n\t// Capping in case of danger\r\n\r\n\tif ( t1 < 0 ) t1 = 0;\r\n\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\tvar pt1 = this.getPoint( t1 );\r\n\tvar pt2 = this.getPoint( t2 );\r\n\r\n\tvar vec = pt2.clone().sub(pt1);\r\n\treturn vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getTangent( t );\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\r\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\t},\r\n\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\tvar h01 = -6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\tthis.bends = [];\r\n\t\r\n\tthis.autoClose = false; // Automatically closes the path\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[0].getPoint(0);\r\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\r\n\t\r\n\tif (!startPoint.equals(endPoint)) {\r\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t}\r\n\t\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0, diff, curve;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\tcurve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t};\r\n\r\n\t// Get length of subsurve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\tvar i, il = this.curves.length;\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates, as well as centroid\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n\tvar points = this.getPoints();\r\n\r\n\tvar maxX, maxY, maxZ;\r\n\tvar minX, minY, minZ;\r\n\r\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\tminX = minY = Number.POSITIVE_INFINITY;\r\n\r\n\tvar p, i, il, sum;\r\n\r\n\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\r\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\tp = points[ i ];\r\n\r\n\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\telse if ( p.x < minX ) minX = p.x;\r\n\r\n\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\telse if ( p.y < minY ) minY = p.y;\r\n\r\n\t\tif ( v3 ) {\r\n\r\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tsum.add( p );\r\n\r\n\t}\r\n\r\n\tvar ret = {\r\n\r\n\t\tminX: minX,\r\n\t\tminY: minY,\r\n\t\tmaxX: maxX,\r\n\t\tmaxY: maxY,\r\n\t\tcentroid: sum.divideScalar( il )\r\n\r\n\t};\r\n\r\n\tif ( v3 ) {\r\n\r\n\t\tret.maxZ = maxZ;\r\n\t\tret.minZ = minZ;\r\n\r\n\t}\r\n\r\n\treturn ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or ParticleSystem objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistance sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tBend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n\tthis.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\tvar i, il;\r\n\r\n\tif ( !bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getSpacedPoints( segments );\r\n\r\n\tvar i, il;\r\n\r\n\tif ( !bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n\tvar bounds = this.getBoundingBox();\r\n\r\n\tvar i, il, p, oldX, oldY, xNorm;\r\n\r\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n\t\tp = oldPts[ i ];\r\n\r\n\t\toldX = p.x;\r\n\t\toldY = p.y;\r\n\r\n\t\txNorm = oldX / bounds.maxX;\r\n\r\n\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n\t\t// check for out of bounds?\r\n\r\n\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\tvar normal = path.getTangent( xNorm );\r\n\t\tnormal.set( -normal.y, normal.x ).multiplyScalar( oldY );\r\n\r\n\t\tp.x = pathPt.x + normal.x;\r\n\t\tp.y = pathPt.y + normal.y;\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );\r\n\t\t\tthis.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );\r\n\r\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\r\n\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call(this);\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\r\nTHREE.PathActions = {\r\n\r\n\tMOVE_TO: 'moveTo',\r\n\tLINE_TO: 'lineTo',\r\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\tELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\r\n\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n//---\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint(1);\r\n\targs.push(lastPoint.x);\r\n\targs.push(lastPoint.y);\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\t// if ( closedPath ) {\r\n\t//\r\n\t// \tpoints.push( points[ 0 ] );\r\n\t//\r\n\t// }\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\tconsole.log('tata');\r\n\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t}\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar points = [];\r\n\r\n\tvar i, il, item, action, args;\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, j,\r\n\t\tt, tx, ty;\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\taction = item.action;\r\n\t\targs = item.args;\r\n\r\n\t\tswitch( action ) {\r\n\r\n\t\tcase THREE.PathActions.MOVE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.LINE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.ARC:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !!args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t  break;\r\n\t\t  \r\n\t\tcase THREE.PathActions.ELLIPSE:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !!args[ 6 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t  break;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1];\r\n\tvar EPSILON = 0.0000000001;\r\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\tpoints.splice( points.length - 1, 1);\r\n\tif ( closedPath ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n// Breaks path into shapes\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW ) {\r\n\r\n\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t// inPt on polygon contour => immediate success    or\r\n\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\tvar inside = false;\r\n\t\tfor( var p = polyLen - 1, q = 0; q < polyLen; p = q++ ) {\r\n\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\tif ( Math.abs(edgeDy) > EPSILON ) {\t\t\t// not parallel\r\n\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = -edgeDx;\r\n\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = -edgeDy;\r\n\t\t\t\t}\r\n\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\tif ( inPt.y == edgeLowPt.y ) {\r\n\t\t\t\t\tif ( inPt.x == edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n\t\t\t\t\tif ( perpEdge == 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\tinside = !inside;\t\t// true intersection left of inPt\r\n\t\t\t\t}\r\n\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\tif ( inPt.y != edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t// egde lies on the same horizontal line as inPt\r\n\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t// continue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn\tinside;\r\n\t}\r\n\r\n\tvar i, il, item, action, args;\r\n\r\n\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\targs = item.args;\r\n\t\taction = item.action;\r\n\r\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\r\n\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t}\r\n\r\n\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\tsubPaths.push( lastPath );\r\n\r\n\t}\r\n\r\n\t// console.log(subPaths);\r\n\r\n\tif ( subPaths.length == 0 ) return [];\r\n\r\n\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\tif ( subPaths.length == 1) {\r\n\r\n\t\ttmpPath = subPaths[0];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\tholesFirst = isCCW ? !holesFirst : holesFirst;\r\n\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\t\r\n\tvar betterShapeHoles = [];\r\n\tvar newShapes = [];\r\n\tvar newShapeHoles = [];\r\n\tvar mainIdx = 0;\r\n\tvar tmpPoints;\r\n\r\n\tnewShapes[mainIdx] = undefined;\r\n\tnewShapeHoles[mainIdx] = [];\r\n\r\n\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\ttmpPath = subPaths[ i ];\r\n\t\ttmpPoints = tmpPath.getPoints();\r\n\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n\t\tsolid = isCCW ? !solid : solid;\r\n\r\n\t\tif ( solid ) {\r\n\r\n\t\t\tif ( (! holesFirst ) && ( newShapes[mainIdx] ) )\tmainIdx++;\r\n\r\n\t\t\tnewShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\tnewShapes[mainIdx].s.actions = tmpPath.actions;\r\n\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\r\n\t\t\t\r\n\t\t\tif ( holesFirst )\tmainIdx++;\r\n\t\t\tnewShapeHoles[mainIdx] = [];\r\n\r\n\t\t\t//console.log('cw', i);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );\r\n\r\n\t\t\t//console.log('ccw', i);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( newShapes.length > 1 ) {\r\n\t\tvar ambigious = false;\r\n\t\tvar toChange = [];\r\n\r\n\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {\r\n\t\t\tbetterShapeHoles[sIdx] = [];\r\n\t\t}\r\n\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {\r\n\t\t\tvar sh = newShapes[sIdx];\r\n\t\t\tvar sho = newShapeHoles[sIdx];\r\n\t\t\tfor (var hIdx = 0; hIdx < sho.length; hIdx++ ) {\r\n\t\t\t\tvar ho = sho[hIdx];\r\n\t\t\t\tvar hole_unassigned = true;\r\n\t\t\t\tfor (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++ ) {\r\n\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {\r\n\t\t\t\t\t\tif ( sIdx != s2Idx )\t\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push( ho );\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tambigious = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }\r\n\t\t\t}\r\n\t\t}\r\n\t\t// console.log(\"ambigious: \", ambigious);\r\n\t\tif ( toChange.length > 0 ) {\r\n\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\tif (! ambigious)\tnewShapeHoles = betterShapeHoles;\r\n\t\t}\r\n\t}\r\n\r\n\tvar tmpHoles, j, jl;\r\n\tfor ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\ttmpShape = newShapes[i].s;\r\n\t\tshapes.push( tmpShape );\r\n\t\ttmpHoles = newShapeHoles[i];\r\n\t\tfor ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\t\ttmpShape.holes.push( tmpHoles[j].h );\r\n\t\t}\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\treturn extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t}\r\n\r\n\treturn this.extractAllPoints(divisions);\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// \treturn {\r\n//\r\n// \t\tshape: this.transform( bend, divisions ),\r\n// \t\tholes: this.getPointsHoles( divisions, bend )\r\n//\r\n// \t};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\t\t// inOtherPt needs to be colinear to the inSegment\r\n\t\t\tif ( inSegPt1.x != inSegPt2.x ) {\r\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n\t\t\tif ( Math.abs(limit) > EPSILON ) {\t\t\t// not parallel\r\n\r\n\t\t\t\tvar perpSeg2;\r\n\t\t\t\tif ( limit > 0 ) {\r\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\tif ( perpSeg2 == 0 ) {\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn  [ inSeg1Pt1 ];\r\n\t\t\t\t}\r\n\t\t\t\tif ( perpSeg2 == limit ) {\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn  [ inSeg1Pt2 ];\r\n\t\t\t\t}\r\n\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\tif ( perpSeg1 == 0 )\t\treturn  [ inSeg2Pt1 ];\r\n\t\t\t\tif ( perpSeg1 == limit )\treturn  [ inSeg2Pt2 ];\r\n\r\n\t\t\t\t// return real intersection point\r\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\tif ( ( perpSeg1 != 0 ) ||\r\n\t\t\t\t\t ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\r\n\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\tvar seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );\t// segment1 ist just a point?\r\n\t\t\t\tvar seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );\t// segment2 ist just a point?\r\n\t\t\t\t// both segments are points\r\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\t\t\t\tif ( (inSeg1Pt1.x != inSeg2Pt1.x) ||\r\n\t\t\t\t\t\t (inSeg1Pt1.y != inSeg2Pt1.y) )\t\treturn [];   \t// they are distinct  points\r\n\t\t\t\t\treturn  [ inSeg1Pt1 ];                 \t\t\t\t\t// they are the same point\r\n\t\t\t\t}\r\n\t\t\t\t// segment#1  is a single point\r\n\t\t\t\tif ( seg1Pt ) {\r\n\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\treturn  [ inSeg1Pt1 ];\r\n\t\t\t\t}\r\n\t\t\t\t// segment#2  is a single point\r\n\t\t\t\tif ( seg2Pt ) {\r\n\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\treturn  [ inSeg2Pt1 ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\tif (seg1dx != 0) {\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\tif ( seg1maxVal == seg2minVal )\t{\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg2min ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\tif ( seg1minVal == seg2maxVal )\t{\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg1min ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\t\t// The order of legs is important\r\n\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\r\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n\t\t\tif ( Math.abs(from2toAngle) > EPSILON ) {\t\t\t// angle != 180 deg.\r\n\r\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n\t\t\t\tif ( from2toAngle > 0 ) {\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\t\t\t} else {\t\t\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\t\t\t}\r\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction removeHoles( contour, holes ) {\r\n\r\n\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\tvar hole;\r\n\r\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\r\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\r\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\r\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );\r\n\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\r\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\r\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\r\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );\r\n\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\ttrue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx++ ) {\r\n\t\t\t\t\tnextIdx = sIdx+1; nextIdx %= shape.length;\r\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );\r\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\tfalse;\r\n\t\t\t}\r\n\r\n\t\t\tvar indepHoles = [];\r\n\r\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx++ ) {\r\n\t\t\t\t\tchkHole = holes[indepHoles[ihIdx]];\r\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx++ ) {\r\n\t\t\t\t\t\tnextIdx = hIdx+1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn\tfalse;\r\n\t\t\t}\r\n\r\n\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\tshapePt, holePt,\r\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\ttmpHole1, tmpHole2;\r\n\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tindepHoles.push( h );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\t\t\tcounter --;\r\n\t\t\t\tif ( counter < 0 ) {\r\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t// which can be connected without intersections\r\n\t\t\t\tfor ( shapeIndex = 0; shapeIndex < shape.length; shapeIndex++ ) {\r\n\r\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\tholeIndex\t= -1;\r\n\r\n\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\t\t\t\t\tholeIdx = indepHoles[h];\r\n\r\n\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\tif ( failedCuts[cutKey] !== undefined )\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thole = holes[holeIdx];\r\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\tif (! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\tindepHoles.splice(h,1);\r\n\r\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex+1 );\r\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex+1 );\r\n\r\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t\t\tfailedCuts[cutKey] = true;\t\t\t// remember failure\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\t}\r\n\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {};\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\tvar allpoints = contour.concat();\r\n\r\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, holes[h] );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tconsole.log( \"Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n\t\tvar triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat();\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * p;\r\n\r\n\t},\r\n\r\n\tb2p1: function ( t, p ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t},\r\n\r\n\tb2p2: function ( t, p ) {\r\n\r\n\t\treturn t * t * p;\r\n\r\n\t},\r\n\r\n\tb2: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n\t},\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * k * p;\r\n\r\n\t},\r\n\r\n\tb3p1: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * k * t * p;\r\n\r\n\t},\r\n\r\n\tb3p2: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3p3: function ( t, p ) {\r\n\r\n\t\treturn t * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub(this.v1);\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub(this.v1);\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\t// returns unit vector\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = (points == undefined) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar v = new THREE.Vector2();\r\n\tvar c = [];\r\n\tvar points = this.points, point, intPoint, weight;\r\n\tpoint = ( points.length - 1 ) * t;\r\n\r\n\tintPoint = Math.floor( point );\r\n\tweight = point - intPoint;\r\n\r\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n\tc[ 1 ] = intPoint;\r\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\r\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\r\n\r\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\r\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\r\n\r\n\treturn v;\r\n\r\n};\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar angle;\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n\tif ( this.aClockwise === true ) {\r\n\r\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n\t} else {\r\n\r\n\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\r\n\t}\r\n\r\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar r = new THREE.Vector3();\r\n\r\n\r\n\t\tr.subVectors( this.v2, this.v1 ); // diff\r\n\t\tr.multiplyScalar( t );\r\n\t\tr.add( this.v1 );\r\n\r\n\t\treturn r;\r\n\r\n\t}\r\n\r\n);\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar tx, ty, tz;\r\n\r\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n);\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar tx, ty, tz;\r\n\r\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n);\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = (points == undefined) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\t\tvar c = [];\r\n\t\tvar points = this.points, point, intPoint, weight;\r\n\t\tpoint = ( points.length - 1 ) * t;\r\n\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\r\n\r\n\t\tvar pt0 = points[ c[0] ],\r\n\t\t\tpt1 = points[ c[1] ],\r\n\t\t\tpt2 = points[ c[2] ],\r\n\t\t\tpt3 = points[ c[3] ];\r\n\r\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\r\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\r\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\r\n// \t\tvar v = new THREE.Vector3();\r\n// \t\tvar c = [];\r\n// \t\tvar points = this.points, point, intPoint, weight;\r\n// \t\tpoint = ( points.length - 1 ) * t;\r\n\r\n// \t\tintPoint = Math.floor( point );\r\n// \t\tweight = point - intPoint;\r\n\r\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n// \t\tc[ 1 ] = intPoint;\r\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\r\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\r\n\r\n// \t\tvar pt0 = points[ c[0] ],\r\n// \t\t\tpt1 = points[ c[1] ],\r\n// \t\t\tpt2 = points[ c[2] ],\r\n// \t\t\tpt3 = points[ c[3] ];\r\n\r\n// \t// t = weight;\r\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\r\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\r\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\r\n\r\n// \treturn v;\r\n\r\n// }\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = (points == undefined) ? [] : points;\r\n\r\n\t},\r\n\r\n    function ( t ) {\r\n\r\n        var v = new THREE.Vector3();\r\n        var c = [];\r\n        var points = this.points, point, intPoint, weight;\r\n        point = ( points.length - 0 ) * t;\r\n            // This needs to be from 0-length +1\r\n\r\n        intPoint = Math.floor( point );\r\n        weight = point - intPoint;\r\n\r\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\r\n        c[ 1 ] = ( intPoint ) % points.length;\r\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\r\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\r\n\r\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\r\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\r\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\r\n\r\n        return v;\r\n\r\n    }\r\n\r\n);\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = (function() {\r\n\r\n\tvar playing = [];\r\n\tvar library = {};\r\n\tvar that    = {};\r\n\r\n\r\n\t//--- update ---\r\n\r\n\tthat.update = function( deltaTimeMS ) {\r\n\r\n\t\tfor( var i = 0; i < playing.length; i ++ )\r\n\t\t\tplaying[ i ].update( deltaTimeMS );\r\n\r\n\t};\r\n\r\n\r\n\t//--- add ---\r\n\r\n\tthat.addToUpdate = function( animation ) {\r\n\r\n\t\tif ( playing.indexOf( animation ) === -1 )\r\n\t\t\tplaying.push( animation );\r\n\r\n\t};\r\n\r\n\r\n\t//--- remove ---\r\n\r\n\tthat.removeFromUpdate = function( animation ) {\r\n\r\n\t\tvar index = playing.indexOf( animation );\r\n\r\n\t\tif( index !== -1 )\r\n\t\t\tplaying.splice( index, 1 );\r\n\r\n\t};\r\n\r\n\r\n\t//--- add ---\r\n\r\n\tthat.add = function( data ) {\r\n\r\n\t\tif ( library[ data.name ] !== undefined )\r\n\t\t\tTHREE.onwarning( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\r\n\r\n\t\tlibrary[ data.name ] = data;\r\n\t\tinitData( data );\r\n\r\n\t};\r\n\r\n\r\n\t//--- get ---\r\n\r\n\tthat.get = function( name ) {\r\n\r\n\t\tif ( typeof name === \"string\" ) {\r\n\r\n\t\t\tif ( library[ name ] ) {\r\n\r\n\t\t\t\treturn library[ name ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.onwarning( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// todo: add simple tween library\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//--- parse ---\r\n\r\n\tthat.parse = function( root ) {\r\n\r\n\t\t// setup hierarchy\r\n\r\n\t\tvar hierarchy = [];\r\n\r\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\r\n\r\n\t\t\t\thierarchy.push( root.bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\r\n\t\t}\r\n\r\n\t\treturn hierarchy;\r\n\r\n\t};\r\n\r\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\r\n\r\n\t\thierarchy.push( root );\r\n\r\n\t\tfor( var c = 0; c < root.children.length; c++ )\r\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n\t}\r\n\r\n\r\n\t//--- init data ---\r\n\r\n\tvar initData = function( data ) {\r\n\r\n\t\tif( data.initialized === true )\r\n\t\t\treturn;\r\n\r\n\r\n\t\t// loop through all keys\r\n\r\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t// remove minus times\r\n\r\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n\r\n\t\t\t\t// create quaternions\r\n\r\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// prepare morph target keys\r\n\r\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n\t\t\t\t// get all used\r\n\r\n\t\t\t\tvar usedMorphTargets = {};\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n\t\t\t\t// set all used on all frames\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tvar influences = {};\r\n\r\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// remove all keys that are on the same time\r\n\r\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\tk --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// set index\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// done\r\n\r\n\t\tdata.initialized = true;\r\n\r\n\t};\r\n\r\n\r\n\t// interpolation types\r\n\r\n\tthat.LINEAR = 0;\r\n\tthat.CATMULLROM = 1;\r\n\tthat.CATMULLROM_FORWARD = 2;\r\n\r\n\treturn that;\r\n\r\n}());\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, name ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.get( name );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 1;\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\r\n\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.play = function ( startTime ) {\r\n\r\n\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\r\n\tif ( this.isPlaying === false ) {\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t\tthis.reset();\r\n\t\tthis.update( 0 );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = false;\r\n\r\n\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.pause = function() {\r\n\r\n\tif ( this.isPaused === true ) {\r\n\r\n\t\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = !this.isPaused;\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.stop = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused  = false;\r\n\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.reset = function () {\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\tvar object = this.hierarchy[ h ];\r\n\r\n\t\tobject.matrixAutoUpdate = true;\r\n\r\n\t\tif ( object.animationCache === undefined ) {\r\n\r\n\t\t\tobject.animationCache = {};\r\n\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\r\n\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\r\n\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\r\n\r\n\t\t}\r\n\r\n\t\tvar prevKey = object.animationCache.prevKey;\r\n\t\tvar nextKey = object.animationCache.nextKey;\r\n\r\n\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\r\n\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\r\n\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.update = (function(){\r\n\r\n\tvar points = [];\r\n\tvar target = new THREE.Vector3();\r\n\t\r\n\t// Catmull-Rom spline\r\n\r\n\tvar interpolateCatmullRom = function ( points, scale ) {\r\n\r\n\t\tvar c = [], v3 = [],\r\n\t\tpoint, intPoint, weight, w2, w3,\r\n\t\tpa, pb, pc, pd;\r\n\t\r\n\t\tpoint = ( points.length - 1 ) * scale;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\t\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\t\r\n\t\tpa = points[ c[ 0 ] ];\r\n\t\tpb = points[ c[ 1 ] ];\r\n\t\tpc = points[ c[ 2 ] ];\r\n\t\tpd = points[ c[ 3 ] ];\r\n\t\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\t\r\n\t\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\t\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\t\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\t\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t};\r\n\t\r\n\treturn function ( delta ) {\r\n\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\tthis.currentTime += delta * this.timeScale;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar vector;\r\n\t\tvar types = [ \"pos\", \"rot\", \"scl\" ];\r\n\t\r\n\t\tvar duration = this.data.length;\r\n\t\r\n\t\tif ( this.loop === true && this.currentTime > duration ) {\r\n\t\r\n\t\t\tthis.currentTime %= duration;\r\n\t\t\tthis.reset();\r\n\t\r\n\t\t} else if ( this.loop === false && this.currentTime > duration ) {\r\n\t\r\n\t\t\tthis.stop();\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.currentTime = Math.min( this.currentTime, duration );\r\n\t\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\tvar animationCache = object.animationCache;\r\n\t\r\n\t\t\t// loop through pos/rot/scl\r\n\t\r\n\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\t\r\n\t\t\t\t// get keys\r\n\t\r\n\t\t\t\tvar type    = types[ t ];\r\n\t\t\t\tvar prevKey = animationCache.prevKey[ type ];\r\n\t\t\t\tvar nextKey = animationCache.nextKey[ type ];\r\n\t\r\n\t\t\t\tif ( nextKey.time <= this.currentTime ) {\r\n\t\r\n\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\t\r\n\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.matrixAutoUpdate = true;\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\t\r\n\t\t\t\tvar prevXYZ = prevKey[ type ];\r\n\t\t\t\tvar nextXYZ = nextKey[ type ];\r\n\t\r\n\t\t\t\tif ( scale < 0 ) scale = 0;\r\n\t\t\t\tif ( scale > 1 ) scale = 1;\r\n\t\r\n\t\t\t\t// interpolate\r\n\t\r\n\t\t\t\tif ( type === \"pos\" ) {\r\n\t\r\n\t\t\t\t\tvector = object.position;\r\n\t\r\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\t\r\n\t\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\t\r\n\t\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\t\t\tpoints[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\t\tpoints[ 1 ] = prevXYZ;\r\n\t\t\t\t\t\tpoints[ 2 ] = nextXYZ;\r\n\t\t\t\t\t\tpoints[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\t\r\n\t\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\t\r\n\t\t\t\t\t\tvar currentPoint = interpolateCatmullRom( points, scale );\r\n\t\r\n\t\t\t\t\t\tvector.x = currentPoint[ 0 ];\r\n\t\t\t\t\t\tvector.y = currentPoint[ 1 ];\r\n\t\t\t\t\t\tvector.z = currentPoint[ 2 ];\r\n\t\r\n\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\t\t\t\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\t\r\n\t\t\t\t\t\t\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\t\ttarget.sub( vector );\r\n\t\t\t\t\t\t\ttarget.y = 0;\r\n\t\t\t\t\t\t\ttarget.normalize();\r\n\t\r\n\t\t\t\t\t\t\tvar angle = Math.atan2( target.x, target.z );\r\n\t\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( type === \"rot\" ) {\r\n\t\r\n\t\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\r\n\t\r\n\t\t\t\t} else if ( type === \"scl\" ) {\r\n\t\r\n\t\t\t\t\tvector = object.scale;\r\n\t\r\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\r\n\t};\r\n\r\n})();\r\n\r\n\r\n\r\n\r\n\r\n// Get next key with\r\n\r\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n\t} else {\r\n\r\n\t\tkey = key % keys.length;\r\n\r\n\t}\r\n\r\n\tfor ( ; key < keys.length; key++ ) {\r\n\r\n\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\tkey = key > 0 ? key : 0;\r\n\r\n\t} else {\r\n\r\n\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t}\r\n\r\n\r\n\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function ( root, data ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.get( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 0.001;\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\r\n\t// initialize to first keyframes\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\tif ( keys.length && sids ) {\r\n\r\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\r\n\r\n\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\r\n\t\t\t\tif ( next ) {\r\n\r\n\t\t\t\t\tnext.apply( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Play\r\n\r\nTHREE.KeyFrameAnimation.prototype.play = function ( startTime ) {\r\n\r\n\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\r\n\tif ( this.isPlaying === false ) {\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t\t// reset key cache\r\n\r\n\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\tobject,\r\n\t\t\tnode;\r\n\r\n\t\tfor ( h = 0; h < hl; h++ ) {\r\n\r\n\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\tnode = this.data.hierarchy[ h ];\r\n\r\n\t\t\tif ( node.animationCache === undefined ) {\r\n\r\n\t\t\t\tnode.animationCache = {};\r\n\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\r\n\t\t\tif (keys.length) {\r\n\r\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\r\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.update( 0 );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = false;\r\n\r\n\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n};\r\n\r\n\r\n\r\n// Pause\r\n\r\nTHREE.KeyFrameAnimation.prototype.pause = function() {\r\n\r\n\tif( this.isPaused ) {\r\n\r\n\t\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = !this.isPaused;\r\n\r\n};\r\n\r\n\r\n// Stop\r\n\r\nTHREE.KeyFrameAnimation.prototype.stop = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused  = false;\r\n\r\n\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t// reset JIT matrix and remove cache\r\n\r\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\r\n        \r\n\t\tvar obj = this.hierarchy[ h ];\r\n\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\tif ( node.animationCache !== undefined ) {\r\n\r\n\t\t\tvar original = node.animationCache.originalMatrix;\r\n\r\n\t\t\tif( obj instanceof THREE.Bone ) {\r\n\r\n\t\t\t\toriginal.copy( obj.skinMatrix );\r\n\t\t\t\tobj.skinMatrix = original;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\tobj.matrix = original;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete node.animationCache;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Update\r\n\r\nTHREE.KeyFrameAnimation.prototype.update = function ( delta ) {\r\n\r\n\tif ( this.isPlaying === false ) return;\r\n\r\n\tthis.currentTime += delta * this.timeScale;\r\n\r\n\t//\r\n\r\n\tvar duration = this.data.length;\r\n\r\n\tif ( this.loop === true && this.currentTime > duration ) {\r\n\r\n\t\tthis.currentTime %= duration;\r\n\r\n\t}\r\n\r\n\tthis.currentTime = Math.min( this.currentTime, duration );\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\tvar object = this.hierarchy[ h ];\r\n\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\tvar keys = node.keys,\r\n\t\t\tanimationCache = node.animationCache;\r\n\r\n\r\n\t\tif ( keys.length ) {\r\n\r\n\t\t\tvar prevKey = animationCache.prevKey;\r\n\t\t\tvar nextKey = animationCache.nextKey;\r\n\r\n\t\t\tif ( nextKey.time <= this.currentTime ) {\r\n\r\n\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\tanimationCache.nextKey = nextKey;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nextKey.time >= this.currentTime ) {\r\n\r\n\t\t\t\tprevKey.interpolate( nextKey, this.currentTime );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tprevKey.interpolate( nextKey, nextKey.time );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\r\n\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Get next key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\tkey = key % keys.length;\r\n\r\n\tfor ( ; key < keys.length; key++ ) {\r\n\r\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\tfor ( ; key >= 0; key-- ) {\r\n\r\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn keys[ keys.length - 1 ];\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com\r\n */\r\n\r\nTHREE.MorphAnimation = function ( mesh ) {\r\n\r\n\tthis.mesh = mesh;\r\n\tthis.frames = mesh.morphTargetInfluences.length;\r\n\tthis.currentTime = 0;\r\n\tthis.duration = 1000;\r\n\tthis.loop = true;\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimation.prototype = {\r\n\r\n\tplay: function () {\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t},\r\n\r\n\tpause: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\t},\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar lastFrame = 0;\r\n\t\tvar currentFrame = 0;\r\n\r\n\t\treturn function ( delta ) {\r\n\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\t\tthis.currentTime += delta;\r\n\r\n\t\t\tif ( this.loop === true && this.currentTime > this.duration ) {\r\n\r\n\t\t\t\tthis.currentTime %= this.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.currentTime = Math.min( this.currentTime, this.duration );\r\n\r\n\t\t\tvar interpolation = this.duration / this.frames;\r\n\t\t\tvar frame = Math.floor( this.currentTime / interpolation );\r\n\r\n\t\t\tif ( frame != currentFrame ) {\r\n\r\n\t\t\t\tthis.mesh.morphTargetInfluences[ lastFrame ] = 0;\r\n\t\t\t\tthis.mesh.morphTargetInfluences[ currentFrame ] = 1;\r\n\t\t\t\tthis.mesh.morphTargetInfluences[ frame ] = 0;\r\n\r\n\t\t\t\tlastFrame = currentFrame;\r\n\t\t\t\tcurrentFrame = frame;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;\r\n\t\t\tthis.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];\r\n\r\n\t\t}\r\n\r\n\t} )()\r\n\r\n};\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\tthis.className = \"CubeCamera\";\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, -1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, -1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, -1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, -1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, -1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n\t\trenderTarget.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n/**\r\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\r\n *\r\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\r\n *\t\tand switching between perspective and orthographic views easily.\r\n *\t\tUse this only if you do not wish to manage\r\n *\t\tboth a Orthographic and Perspective Camera\r\n *\r\n */\r\n\r\n\r\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\tthis.className = \"CombinedCamera\";\r\n\r\n\tthis.fov = fov;\r\n\r\n\tthis.left = -width / 2;\r\n\tthis.right = width / 2\r\n\tthis.top = height / 2;\r\n\tthis.bottom = -height / 2;\r\n\r\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\r\n\r\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\r\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.toPerspective();\r\n\r\n\tvar aspect = width/height;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\nTHREE.CombinedCamera.prototype.toPerspective = function () {\r\n\r\n\t// Switches to the Perspective Camera\r\n\r\n\tthis.near = this.cameraP.near;\r\n\tthis.far = this.cameraP.far;\r\n\r\n\tthis.cameraP.fov =  this.fov / this.zoom ;\r\n\r\n\tthis.cameraP.updateProjectionMatrix();\r\n\r\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\r\n\r\n\tthis.inPerspectiveMode = true;\r\n\tthis.inOrthographicMode = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\r\n\r\n\t// Switches to the Orthographic camera estimating viewport from Perspective\r\n\r\n\tvar fov = this.fov;\r\n\tvar aspect = this.cameraP.aspect;\r\n\tvar near = this.cameraP.near;\r\n\tvar far = this.cameraP.far;\r\n\r\n\t// The size that we set is the mid plane of the viewing frustum\r\n\r\n\tvar hyperfocus = ( near + far ) / 2;\r\n\r\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\r\n\tvar planeHeight = 2 * halfHeight;\r\n\tvar planeWidth = planeHeight * aspect;\r\n\tvar halfWidth = planeWidth / 2;\r\n\r\n\thalfHeight /= this.zoom;\r\n\thalfWidth /= this.zoom;\r\n\r\n\tthis.cameraO.left = -halfWidth;\r\n\tthis.cameraO.right = halfWidth;\r\n\tthis.cameraO.top = halfHeight;\r\n\tthis.cameraO.bottom = -halfHeight;\r\n\r\n\t// this.cameraO.left = -farHalfWidth;\r\n\t// this.cameraO.right = farHalfWidth;\r\n\t// this.cameraO.top = farHalfHeight;\r\n\t// this.cameraO.bottom = -farHalfHeight;\r\n\r\n\t// this.cameraO.left = this.left / this.zoom;\r\n\t// this.cameraO.right = this.right / this.zoom;\r\n\t// this.cameraO.top = this.top / this.zoom;\r\n\t// this.cameraO.bottom = this.bottom / this.zoom;\r\n\r\n\tthis.cameraO.updateProjectionMatrix();\r\n\r\n\tthis.near = this.cameraO.near;\r\n\tthis.far = this.cameraO.far;\r\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\r\n\r\n\tthis.inPerspectiveMode = false;\r\n\tthis.inOrthographicMode = true;\r\n\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\r\n\r\n\tthis.cameraP.aspect = width / height;\r\n\tthis.left = -width / 2;\r\n\tthis.right = width / 2\r\n\tthis.top = height / 2;\r\n\tthis.bottom = -height / 2;\r\n\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\r\n\r\n\tthis.fov = fov;\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\n// For mantaining similar API with PerspectiveCamera\r\n\r\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toPerspective();\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\n/*\r\n* Uses Focal Length (in mm) to estimate and set FOV\r\n* 35mm (fullframe) camera is used if frame size is not specified;\r\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n*/\r\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\r\n\tthis.setFov( fov );\r\n\r\n\treturn fov;\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\r\n\r\n\tthis.zoom = zoom;\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toFrontView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\r\n\t// should we be modifing the matrix instead?\r\n\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toBackView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = Math.PI;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toLeftView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = - Math.PI / 2;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toRightView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = Math.PI / 2;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toTopView = function() {\r\n\r\n\tthis.rotation.x = - Math.PI / 2;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toBottomView = function() {\r\n\r\n\tthis.rotation.x = Math.PI / 2;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"BoxGeometry\";\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\tthis.depth = depth;\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\tthis.depthSegments = depthSegments || 1;\r\n\r\n\tvar width_half = this.width / 2;\r\n\tvar height_half = this.height / 2;\r\n\tvar depth_half = this.depth / 2;\r\n\r\n\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\r\n\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\r\n\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\r\n\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\r\n\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\r\n\r\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n\t\tvar w, ix, iy,\r\n\t\tgridX = scope.widthSegments,\r\n\t\tgridY = scope.heightSegments,\r\n\t\twidth_half = width / 2,\r\n\t\theight_half = height / 2,\r\n\t\toffset = scope.vertices.length;\r\n\r\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'z';\r\n\r\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'y';\r\n\t\t\tgridY = scope.depthSegments;\r\n\r\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n\t\t\tw = 'x';\r\n\t\t\tgridX = scope.depthSegments;\r\n\r\n\t\t}\r\n\r\n\t\tvar gridX1 = gridX + 1,\r\n\t\tgridY1 = gridY + 1,\r\n\t\tsegment_width = width / gridX,\r\n\t\tsegment_height = height / gridY,\r\n\t\tnormal = new THREE.Vector3();\r\n\r\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\tvector[ w ] = depth;\r\n\r\n\t\t\t\tscope.vertices.push( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\r\n\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\r\n\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"CircleGeometry\";\r\n\r\n\tthis.radius = radius = radius || 50;\r\n\tthis.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tvar i, uvs = [],\r\n\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n\tthis.vertices.push(center);\r\n\tuvs.push( centerUV );\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar segment = thetaStart + i / segments * thetaLength;\r\n\r\n\t\tvertex.x = radius * Math.cos( segment );\r\n\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\tthis.vertices.push( vertex );\r\n\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\r\n\t}\r\n\r\n\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tvar v1 = i;\r\n\t\tvar v2 = i + 1 ;\r\n\t\tvar v3 = 0;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n// DEPRECATED\r\n\r\nTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"CylinderGeometry\";\r\n\r\n\tthis.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tthis.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\tthis.height = height = height !== undefined ? height : 100;\r\n\r\n\tthis.radialSegments = radialSegments = radialSegments || 8;\r\n\tthis.heightSegments = heightSegments = heightSegments || 1;\r\n\r\n\tthis.openEnded = openEnded = openEnded !== undefined ? openEnded : false;\r\n\r\n\tvar heightHalf = height / 2;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tvar v = y / heightSegments;\r\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\r\n\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\tvar na, nb;\r\n\r\n\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\tif ( radiusTop !== 0 ) {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = na.clone();\r\n\t\t\tvar n2 = na.clone();\r\n\t\t\tvar n3 = nb.clone();\r\n\t\t\tvar n4 = nb.clone();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// top cap\r\n\r\n\tif ( openEnded === false && radiusTop > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// bottom cap\r\n\r\n\tif ( openEnded === false && radiusBottom > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n}\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  material: <int> // material index for front and back faces\r\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"ExtrudeGeometry\";\r\n\r\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\r\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\tvar material = options.material;\r\n\tvar extrudeMaterial = options.extrudeMaterial;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar shapebb = this.shapebb;\r\n\t//shapebb = shape.getBoundingBox();\r\n\r\n\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initalization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\tvar bevelPoints = [];\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( !vec ) return THREE.onerror( \"die, vec not specified\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length,\r\n\t\tcont, clen = contour.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\r\n\r\n\r\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\tvar sign = THREE.Math.sign;\r\n\t\t\r\n\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t//   shiftet by 1 unit (length of normalized vector) to the left\r\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t//\r\n\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\t\r\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\r\n\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\t\r\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\t\r\n\t\t// check for colinear edges\r\n\t\tvar colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\r\n\t\tif ( Math.abs( colinear0 ) > EPSILON ) {\t\t// not colinear\r\n\t\t\t\r\n\t\t\t// length of vectors for normalizing\r\n\t\r\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\t\t\r\n\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\r\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\t\t\r\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\r\n\t\t\t// scaling factor for v_prev to intersection point\r\n\t\r\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\t// vector from inPt to intersection point\r\n\t\r\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\r\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t//  but prevent crazy spikes\r\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )\r\n\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\t\t} else {\r\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else {\t\t// handle special case of colinear edges\r\n\r\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\tif ( v_prev_x > EPSILON ) {\r\n\t\t\t\tif ( v_next_x > EPSILON ) { direction_eq = true; }\r\n\t\t\t} else {\r\n\t\t\t\tif ( v_prev_x < -EPSILON ) {\r\n\t\t\t\t\tif ( v_next_x < -EPSILON ) { direction_eq = true; }\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( sign(v_prev_y) == sign(v_next_y) ) { direction_eq = true; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( direction_eq ) {\r\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\tv_trans_x = -v_prev_y;\r\n\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\t\t} else {\r\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t}\r\n\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tvar pt_i = contour[ i ];\r\n\t\tvar pt_j = contour[ j ];\r\n\t\tvar pt_k = contour[ k ];\r\n\r\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\r\n\t\t//bs = bevelSize * t ; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  -z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\r\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( --i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c, isBottom ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\t// normal, color, material\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\r\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\r\n\r\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n \t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\r\n \t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\r\n\r\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\r\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\r\n\r\n \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\r\n\t\tvar ax = geometry.vertices[ indexA ].x,\r\n\t\t\tay = geometry.vertices[ indexA ].y,\r\n\r\n\t\t\tbx = geometry.vertices[ indexB ].x,\r\n\t\t\tby = geometry.vertices[ indexB ].y,\r\n\r\n\t\t\tcx = geometry.vertices[ indexC ].x,\r\n\t\t\tcy = geometry.vertices[ indexC ].y;\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( ax, ay ),\r\n\t\t\tnew THREE.Vector2( bx, by ),\r\n\t\t\tnew THREE.Vector2( cx, cy )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\r\n\r\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\r\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\r\n\t                              contourIndex1, contourIndex2 ) {\r\n\r\n\t\tvar ax = geometry.vertices[ indexA ].x,\r\n\t\t\tay = geometry.vertices[ indexA ].y,\r\n\t\t\taz = geometry.vertices[ indexA ].z,\r\n\r\n\t\t\tbx = geometry.vertices[ indexB ].x,\r\n\t\t\tby = geometry.vertices[ indexB ].y,\r\n\t\t\tbz = geometry.vertices[ indexB ].z,\r\n\r\n\t\t\tcx = geometry.vertices[ indexC ].x,\r\n\t\t\tcy = geometry.vertices[ indexC ].y,\r\n\t\t\tcz = geometry.vertices[ indexC ].z,\r\n\r\n\t\t\tdx = geometry.vertices[ indexD ].x,\r\n\t\t\tdy = geometry.vertices[ indexD ].y,\r\n\t\t\tdz = geometry.vertices[ indexD ].z;\r\n\r\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\r\n\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\r\n\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\r\n\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\r\n\t\t\t];\r\n\t\t} else {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\r\n\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\r\n\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\r\n\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"ShapeGeometry\";\r\n\r\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\r\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\tvar shapebb = this.shapebb;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole, s;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tvar contour = vertices;\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\tvar cont, clen = contour.length;\r\n\r\n\tfor ( i = 0; i < vlen; i++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"LatheGeometry\";\r\n\r\n\tsegments = segments || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || 2 * Math.PI;\r\n\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\r\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar c = Math.cos( phi ),\r\n\t\t\ts = Math.sin( phi );\r\n\r\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar pt = points[ j ];\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\tvertex.z = pt.z;\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar np = points.length;\r\n\r\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n\t\t\tvar base = j + np * i;\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + np;\r\n\t\t\tvar c = base + 1 + np;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\tvar v1 = v0 + inversePointLength;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u0, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"PlaneGeometry\";\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\r\n\tvar ix, iz;\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = this.widthSegments;\r\n\tvar gridZ = this.heightSegments;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridZ1 = gridZ + 1;\r\n\r\n\tvar segment_width = this.width / gridX;\r\n\tvar segment_height = this.height / gridZ;\r\n\r\n\tvar normal = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\t\t\tvar y = iz * segment_height - height_half;\r\n\r\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iz;\r\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\r\n\r\n\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );\r\n\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );\r\n\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );\r\n\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, d );\r\n\t\t\tface.normal.copy( normal );\r\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tface = new THREE.Face3( b, c, d );\r\n\t\t\tface.normal.copy( normal );\r\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"RingGeometry\";\r\n\r\n\tinnerRadius = innerRadius || 0;\r\n\touterRadius = outerRadius || 50;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;\r\n\r\n\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\r\n\tfor ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring\r\n\r\n\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\r\n\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\t\t}\r\n\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\r\n\r\n\t\tvar thetaSegment = i * thetaSegments;\r\n\r\n\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\r\n\r\n\t\t\tvar segment = o + thetaSegment;\r\n\r\n\t\t\tvar v1 = segment + i;\r\n\t\t\tvar v2 = segment + thetaSegments + i;\r\n\t\t\tvar v3 = segment + thetaSegments + 1 + i;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n\t\t\tv1 = segment + i;\r\n\t\t\tv2 = segment + thetaSegments + 1 + i;\r\n\t\t\tv3 = segment + 1 + i;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"SphereGeometry\";\r\n\r\n\tthis.radius = radius = radius || 50;\r\n\r\n\tthis.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\tthis.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tthis.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;\r\n\tthis.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / widthSegments;\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tfor ( y = 0; y < this.heightSegments; y ++ ) {\r\n\r\n\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\r\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\r\n\r\n\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\r\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\r\n\r\n\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: \t\t\t<float>, \t// size of the text\r\n *  height: \t\t<float>, \t// thickness to extrude text\r\n *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n *\r\n *  font: \t\t\t<string>,\t\t// font name\r\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*\tUsage Examples\r\n\r\n\t// TextGeometry wrapper\r\n\r\n\tvar text3d = new TextGeometry( text, options );\r\n\r\n\t// Complete manner\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\tthis.className = \"TextGeometry\";\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"TorusGeometry\";\r\n\t\r\n\tvar scope = this;\r\n\r\n\tthis.radius = radius || 100;\r\n\tthis.tube = tube || 40;\r\n\tthis.radialSegments = radialSegments || 8;\r\n\tthis.tubularSegments = tubularSegments || 6;\r\n\tthis.arc = arc || Math.PI * 2;\r\n\r\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / this.tubularSegments * this.arc;\r\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\r\n\r\n\t\t\tcenter.x = this.radius * Math.cos( u );\r\n\t\t\tcenter.y = this.radius * Math.sin( u );\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = this.tube * Math.sin( v );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\r\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\r\n\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"TorusKnotGeometry\";\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.radius = radius || 100;\r\n\tthis.tube = tube || 40;\r\n\tthis.radialSegments = radialSegments || 64;\r\n\tthis.tubularSegments = tubularSegments || 8;\r\n\tthis.p = p || 2;\r\n\tthis.q = q || 3;\r\n\tthis.heightScale = heightScale || 1;\r\n\tthis.grid = new Array( this.radialSegments );\r\n\r\n\tvar tang = new THREE.Vector3();\r\n\tvar n = new THREE.Vector3();\r\n\tvar bitan = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\r\n\r\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\r\n\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\r\n\t\tvar p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );\r\n\t\tvar p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );\r\n\t\ttang.subVectors( p2, p1 );\r\n\t\tn.addVectors( p2, p1 );\r\n\r\n\t\tbitan.crossVectors( tang, n );\r\n\t\tn.crossVectors( bitan, tang );\r\n\t\tbitan.normalize();\r\n\t\tn.normalize();\r\n\r\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\r\n\t\t\tvar cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tvar cy = this.tube * Math.sin( v );\r\n\r\n\t\t\tvar pos = new THREE.Vector3();\r\n\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\r\n\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\r\n\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\r\n\t\t\tthis.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\r\n\r\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\r\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\r\n\r\n\t\t\tvar a = this.grid[ i ][ j ];\r\n\t\t\tvar b = this.grid[ ip ][ j ];\r\n\t\t\tvar c = this.grid[ ip ][ jp ];\r\n\t\t\tvar d = this.grid[ i ][ jp ];\r\n\r\n\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\r\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\r\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\r\n\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = in_q / in_p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"TubeGeometry\";\r\n\r\n\tthis.path = path;\r\n\tthis.segments = segments || 64;\r\n\tthis.radius = radius || 1;\r\n\tthis.radialSegments = radialSegments || 8;\r\n\tthis.closed = closed || false;\r\n\r\n\tthis.grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = this.segments + 1,\r\n\r\n\t\tx, y, z,\r\n\t\ttx, ty, tz,\r\n\t\tu, v,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\r\n\t// consruct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i++ ) {\r\n\r\n\t\tthis.grid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\r\n\r\n\t\t\tv = j / this.radialSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = this.radius * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < this.segments; i++ ) {\r\n\r\n\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\r\n\r\n\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\r\n\t\t\tjp = (j + 1) % this.radialSegments;\r\n\r\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = this.grid[ ip ][ j ];\r\n\t\t\tc = this.grid[ ip ][ jp ];\r\n\t\t\td = this.grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radialSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\r\n\r\n\tvar\ttangent = new THREE.Vector3(),\r\n\t\tnormal = new THREE.Vector3(),\r\n\t\tbinormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tepsilon = 0.0001,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u, v;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\r\n\tfunction initialNormal3() {\r\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i-1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > epsilon ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = -theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"PolyhedronGeometry\";\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar midpoints = [], p = this.vertices;\r\n\r\n\tvar f = [];\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar v1 = p[ faces[ i ][ 0 ] ];\r\n\t\tvar v2 = p[ faces[ i ][ 1 ] ];\r\n\t\tvar v3 = p[ faces[ i ][ 2 ] ];\r\n\r\n\t\tf[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0, l = f.length; i < l; i ++ ) {\r\n\r\n\t\tsubdivide(f[ i ], detail);\r\n\r\n\t}\r\n\r\n\r\n\t// Handle case when face straddles the seam\r\n\r\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\tvar x0 = uvs[ 0 ].x;\r\n\t\tvar x1 = uvs[ 1 ].x;\r\n\t\tvar x2 = uvs[ 2 ].x;\r\n\r\n\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\r\n\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\r\n\r\n\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Merge vertices\r\n\r\n\tthis.mergeVertices();\r\n\r\n\tthis.computeCentroids();\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3 ) {\r\n\r\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\tthat.faces.push( face );\r\n\r\n\t\tvar azi = azimuth( face.centroid );\r\n\r\n\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\t// Analytically subdivide a face to the required detail level.\r\n\r\n\tfunction subdivide(face, detail ) {\r\n\r\n\t\tvar cols = Math.pow(2, detail);\r\n\t\tvar cells = Math.pow(4, detail);\r\n\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\tvar v = [];\r\n\r\n\t\t// Construct all of the vertices for this subdivision.\r\n\r\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( var j = 0; j <= rows; j ++) {\r\n\r\n\t\t\t\tif ( j == 0 && i == cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Construct all of the faces.\r\n\r\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 == 0 ) {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tv[ i ][ k ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1][ k + 1],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, -vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv.clone();\r\n\r\n\t}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tthis.radius = radius;\r\n\tthis.detail = detail;\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\r\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\r\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\r\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\r\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\r\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\tthis.className = \"IcosahedronGeometry\";\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\tthis.className = \"OctahedronGeometry\";\r\n\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\tthis.className = \"TetrahedronGeometry\";\r\n\r\n\tvar vertices = [\r\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\tthis.className = \"ParametricGeometry\";\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tvar i, il, j, p;\r\n\tvar u, v;\r\n\r\n\tvar stackCount = stacks + 1;\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = (i + 1) * sliceCount + j + 1;\r\n\t\t\td = (i + 1) * sliceCount + j;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size )\r\n\t);\r\n\r\n\tgeometry.colors.push(\r\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\r\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\r\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\tthis.className = \"AxisHelper\";\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  hex - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {\r\n\r\n\t// dir is assumed to be normalized\r\n\r\n\tTHREE.Object3D.call( this );\r\n\tthis.className = \"ArrowHelper\";\r\n\r\n\tif ( hex === undefined ) hex = 0xffff00;\r\n\tif ( length === undefined ) length = 1;\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.position = origin;\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\r\n\tthis.line.matrixAutoUpdate = false;\r\n\tthis.add( this.line );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\r\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\r\n\tthis.cone.matrixAutoUpdate = false;\r\n\tthis.add( this.cone );\r\n\r\n\tthis.setDirection( dir );\r\n\tthis.setLength( length, headLength, headWidth );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = function () {\r\n\r\n\tvar axis = new THREE.Vector3();\r\n\tvar radians;\r\n\r\n\treturn function ( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.line.scale.set( 1, length, 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\r\n\r\n\tthis.line.material.color.setHex( hex );\r\n\tthis.cone.material.color.setHex( hex );\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n\t//   5____4\r\n\t// 1/___0/|\r\n\t// | 6__|_7\r\n\t// 2/___3/\r\n\r\n\tvar vertices = [\r\n\t\tnew THREE.Vector3(   1,   1,   1 ),\r\n\t\tnew THREE.Vector3( - 1,   1,   1 ),\r\n\t\tnew THREE.Vector3( - 1, - 1,   1 ),\r\n\t\tnew THREE.Vector3(   1, - 1,   1 ),\r\n\r\n\t\tnew THREE.Vector3(   1,   1, - 1 ),\r\n\t\tnew THREE.Vector3( - 1,   1, - 1 ),\r\n\t\tnew THREE.Vector3( - 1, - 1, - 1 ),\r\n\t\tnew THREE.Vector3(   1, - 1, - 1 )\r\n\t];\r\n\r\n\tthis.vertices = vertices;\r\n\r\n\t// TODO: Wouldn't be nice if Line had .segments?\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tvertices[ 0 ], vertices[ 1 ],\r\n\t\tvertices[ 1 ], vertices[ 2 ],\r\n\t\tvertices[ 2 ], vertices[ 3 ],\r\n\t\tvertices[ 3 ], vertices[ 0 ],\r\n\r\n\t\tvertices[ 4 ], vertices[ 5 ],\r\n\t\tvertices[ 5 ], vertices[ 6 ],\r\n\t\tvertices[ 6 ], vertices[ 7 ],\r\n\t\tvertices[ 7 ], vertices[ 4 ],\r\n\r\n\t\tvertices[ 0 ], vertices[ 4 ],\r\n\t\tvertices[ 1 ], vertices[ 5 ],\r\n\t\tvertices[ 2 ], vertices[ 6 ],\r\n\t\tvertices[ 3 ], vertices[ 7 ]\r\n\t);\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\r\n\r\n\tif ( object !== undefined ) {\r\n\r\n\t\tthis.update( object );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.BoxHelper.prototype.update = function ( object ) {\r\n\r\n\tvar geometry = object.geometry;\r\n\r\n\tif ( geometry.boundingBox === null ) {\r\n\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t}\r\n\r\n\tvar min = geometry.boundingBox.min;\r\n\tvar max = geometry.boundingBox.max;\r\n\tvar vertices = this.vertices;\r\n\r\n\tvertices[ 0 ].set( max.x, max.y, max.z );\r\n\tvertices[ 1 ].set( min.x, max.y, max.z );\r\n\tvertices[ 2 ].set( min.x, min.y, max.z );\r\n\tvertices[ 3 ].set( max.x, min.y, max.z );\r\n\tvertices[ 4 ].set( max.x, max.y, min.z );\r\n\tvertices[ 5 ].set( min.x, max.y, min.z );\r\n\tvertices[ 6 ].set( min.x, min.y, min.z );\r\n\tvertices[ 7 ].set( max.x, min.y, min.z );\r\n\r\n\tthis.geometry.computeBoundingSphere();\r\n\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.matrixWorld = object.matrixWorld;\r\n\r\n};\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.box = new THREE.Box3();\r\n\r\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n\tthis.box.setFromObject( this.object );\r\n\r\n\tthis.box.size( this.scale );\r\n\r\n\tthis.box.center( this.position );\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n\tthis.camera = camera;\r\n\tthis.matrixWorld = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar camera = new THREE.Camera();\r\n\tvar projector = new THREE.Projector();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( \"c\", 0, 0, -1 );\r\n\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( \"n1\", -w, -h, -1 );\r\n\t\tsetPoint( \"n2\",  w, -h, -1 );\r\n\t\tsetPoint( \"n3\", -w,  h, -1 );\r\n\t\tsetPoint( \"n4\",  w,  h, -1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( \"f1\", -w, -h, 1 );\r\n\t\tsetPoint( \"f2\",  w, -h, 1 );\r\n\t\tsetPoint( \"f3\", -w,  h, 1 );\r\n\t\tsetPoint( \"f4\",  w,  h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\r\n\t\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\r\n\t\tsetPoint( \"u3\",        0, h * 2,   -1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( \"cf1\", -w,  0, 1 );\r\n\t\tsetPoint( \"cf2\",  w,  0, 1 );\r\n\t\tsetPoint( \"cf3\",  0, -h, 1 );\r\n\t\tsetPoint( \"cf4\",  0,  h, 1 );\r\n\r\n\t\tsetPoint( \"cn1\", -w,  0, -1 );\r\n\t\tsetPoint( \"cn2\",  w,  0, -1 );\r\n\t\tsetPoint( \"cn3\",  0, -h, -1 );\r\n\t\tsetPoint( \"cn4\",  0,  h, -1 );\r\n\r\n\t\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\t\tvector.set( x, y, z );\r\n\t\t\tprojector.unprojectVector( vector, camera );\r\n\r\n\t\t\tvar points = scope.pointMap[ point ];\r\n\r\n\t\t\tif ( points !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrixWorld = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tsize = size || 1;\r\n\tvar geometry = new THREE.PlaneGeometry( size, size );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.lightPlane = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightPlane );\r\n\r\n\tgeometry = new THREE.Geometry();\r\n\tgeometry.vertices.push( new THREE.Vector3() );\r\n\tgeometry.vertices.push( new THREE.Vector3() );\r\n\r\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.targetLine = new THREE.Line( geometry, material );\r\n\tthis.add( this.targetLine );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\t\r\n\tthis.lightPlane.geometry.dispose();\r\n\tthis.lightPlane.material.dispose();\r\n\tthis.targetLine.geometry.dispose();\r\n\tthis.targetLine.material.dispose();\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar v3 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tthis.lightPlane.lookAt( v3 );\r\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n\t}\r\n\r\n}();\r\n\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\tvar sortFunction = function ( a, b ) { return a - b };\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar geometry2 = object.geometry.clone();\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar vertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\tvar numEdges = 0;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\tvar key = edge.toString();\r\n\r\n\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thash[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\r\n\r\n\tvar coords = geometry.attributes.position.array;\r\n\r\n\tvar index = 0;\r\n\r\n\tfor ( var key in hash ) {\r\n\r\n\t\tvar h = hash[ key ];\r\n\r\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK\r\n\r\n\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\tcoords[ index ++ ] = vertex.z;\r\n\r\n\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\tcoords[ index ++ ] = vertex.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.matrixWorld = object.matrixWorld;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = this.object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.normalMatrix = new THREE.Matrix3();\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( object ) {\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tv1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\r\n\t\t\tvar idx = 2 * i;\r\n\r\n\t\t\tvertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\tvertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tthis.color1 = new THREE.Color( 0x444444 );\r\n\tthis.color2 = new THREE.Color( 0x888888 );\r\n\r\n\tfor ( var i = - size; i <= size; i += step ) {\r\n\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t);\r\n\r\n\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\r\n\t\tgeometry.colors.push( color, color, color, color );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n\tthis.color1.set( colorCenterLine );\r\n\tthis.color2.set( colorGrid );\r\n\r\n\tthis.geometry.colorsNeedUpdate = true;\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrixWorld = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightSphere );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\tthis.lightSphere.geometry.dispose();\r\n\tthis.lightSphere.material.dispose();\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}();\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.matrixWorld = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\t/*\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightDistance );\r\n\t*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\t\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t/*\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\t*/\r\n\r\n};\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrixWorld = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\r\n\tthis.cone = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar vector2 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar vertices = object.geometry.vertices;\r\n\r\n\tvar faces = object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.normalMatrix = new THREE.Matrix3();\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function( object ) {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar verts = this.object.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\tvar vertex = verts[ vertexId ];\r\n\r\n\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\r\n\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar vertices = object.geometry.vertices;\r\n\r\n\tvar faces = object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function( object ) {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar verts = this.object.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\tvar vertex = verts[ vertexId ];\r\n\r\n\t\t\t\tvar tangent = face.vertexTangents[ j ];\r\n\r\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\r\n\r\n\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\tvar sortFunction = function ( a, b ) { return a - b };\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tvar vertices = object.geometry.vertices;\r\n\t\tvar faces = object.geometry.faces;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\r\n\r\n\t\tvar coords = geometry.attributes.position.array;\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry\r\n\r\n\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\tvar indices = object.geometry.attributes.index.array;\r\n\t\tvar offsets = object.geometry.offsets;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\r\n\t\tfor ( var o = 0, ol = offsets.length; o < ol; ++ o ) {\r\n\r\n\t\t\tvar start = offsets[ o ].start;\r\n\t\t\tvar count = offsets[ o ].count;\r\n\t\t\tvar index = offsets[ o ].index;\r\n\r\n\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\r\n\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\r\n\r\n\t\tvar coords = geometry.attributes.position.array;\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\r\n\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\r\n\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\r\n\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else if ( object.geometry instanceof THREE.BufferGeometry\t) { // non-indexed BufferGeometry\r\n\r\n\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\tvar numEdges = vertices.length / 3;\r\n\t\tvar numTris = numEdges / 3;\r\n\r\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\r\n\r\n\t\tvar coords = geometry.attributes.position.array;\r\n\r\n\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tvar index = 18 * i + 6 * j;\r\n\r\n\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.matrixWorld = object.matrixWorld;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.render = function ( renderCallback ) { };\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif( size === undefined ) size = -1;\r\n\tif( distance === undefined ) distance = 0;\r\n\tif( opacity === undefined ) opacity = 1;\r\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\r\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\t                    scale: 1, \t\t\t\t\t// scale\r\n\t\t                    rotation: 1, \t\t\t\t// rotation\r\n\t\t                    opacity: opacity,\t\t\t// opacity\r\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\r\n\t\t                    blending: blending } );\t\t// blending\r\n\r\n};\r\n\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = -this.positionScreen.x * 2;\r\n\tvar vecY = -this.positionScreen.y * 2;\r\n\r\n\tfor( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\t\t\tvar num = chunks[ 2 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = -1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = -1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.onwarning( \"animation[\" + name + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= -1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function () {\r\n\r\n\tvar _gl, _renderer, _precision, _lensFlare = {};\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\t_precision = renderer.getPrecision();\r\n\r\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\r\n\t\t_lensFlare.faces = new Uint16Array( 6 );\r\n\r\n\t\tvar i = 0;\r\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\r\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\r\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\r\n\r\n\t\ti = 0;\r\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\r\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\r\n\r\n\t\t// buffers\r\n\r\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\r\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\r\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\r\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\r\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\r\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\r\n\r\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\r\n\r\n\t\t\t_lensFlare.hasVertexTexture = false;\r\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_lensFlare.hasVertexTexture = true;\r\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\r\n\r\n\t\t}\r\n\r\n\t\t_lensFlare.attributes = {};\r\n\t\t_lensFlare.uniforms = {};\r\n\r\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\r\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\r\n\r\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\r\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\r\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\r\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\r\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\r\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\r\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\r\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\r\n\r\n\t};\r\n\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\r\n\t *         update transparency of flares. Then they are rendered.\r\n\t *\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tvar flares = scene.__webglFlares,\r\n\t\t\tnFlares = flares.length;\r\n\r\n\t\tif ( ! nFlares ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\tvar size = 16 / viewportHeight,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tvar uniforms = _lensFlare.uniforms,\r\n\t\t\tattributes = _lensFlare.attributes;\r\n\r\n\t\t// set _lensFlare program and reset blending\r\n\r\n\t\t_gl.useProgram( _lensFlare.program );\r\n\r\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\r\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/unforms\r\n\r\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t_gl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\r\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\r\n\r\n\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\t_gl.depthMask( false );\r\n\r\n\t\tvar i, j, jl, flare, sprite;\r\n\r\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewportHeight;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tflare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition )\r\n\r\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( _lensFlare.hasVertexTexture || (\r\n\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\t_gl.disable( _gl.BLEND );\r\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\r\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthMask( true );\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader, precision ) {\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\r\n\r\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\t_gl.compileShader( fragmentShader );\r\n\t\t_gl.compileShader( vertexShader );\r\n\r\n\t\t_gl.attachShader( program, fragmentShader );\r\n\t\t_gl.attachShader( program, vertexShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShadowMapPlugin = function () {\r\n\r\n\tvar _gl,\r\n\t_renderer,\r\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_min = new THREE.Vector3(),\r\n\t_max = new THREE.Vector3(),\r\n\r\n\t_matrixPosition = new THREE.Vector3();\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\r\n\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\r\n\r\n\t\tthis.update( scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( scene, camera ) {\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\tprogram, buffer, material,\r\n\t\twebglObject, object, light,\r\n\t\trenderList,\r\n\r\n\t\tlights = [],\r\n\t\tk = 0,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.setDepthTest( true );\r\n\r\n\t\t// preprocess lights\r\n\t\t// \t- skip lights that are not casting shadows\r\n\t\t//\t- create virtual lights for cascaded shadow maps\r\n\r\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = scene.__lights[ i ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\r\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\r\n\t\t\t\t\tvar virtualLight;\r\n\r\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\r\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\r\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\r\n\r\n\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\r\n\t\t\t\t\t\tcamera.add( gyro );\r\n\r\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\r\n\t\t\t\t\t\t//console.log( \"Created virtualLight\", virtualLight );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tupdateVirtualLight( light, n );\r\n\r\n\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlights[ k ] = light;\r\n\t\t\t\tk ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = lights[ i ];\r\n\r\n\t\t\tif ( ! light.shadowMap ) {\r\n\r\n\t\t\t\tvar shadowFilter = THREE.NearestFilter;\r\n\r\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! light.shadowCamera ) {\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tTHREE.onerror( \"Unsupported light type for shadow\" );\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscene.add( light.shadowCamera );\r\n\r\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\r\n\t\t\t\tupdateShadowCamera( camera, light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowMap = light.shadowMap;\r\n\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\tshadowCamera = light.shadowCamera;\r\n\r\n\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n\t\t\t// compute shadow matrix\r\n\r\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t// render shadow map\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\trenderList = scene.__webglObjects;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\twebglObject.render = false;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// render regular objects\r\n\r\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\r\n\t\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t\t// while rendering depth map\r\n\r\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\r\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// set matrices and render immediate objects\r\n\r\n\t\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction createVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\r\n\t\tvirtualLight.isVirtual = true;\r\n\r\n\t\tvirtualLight.onlyShadow = true;\r\n\t\tvirtualLight.castShadow = true;\r\n\r\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\r\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\r\n\t\tvirtualLight.pointsWorld = [];\r\n\t\tvirtualLight.pointsFrustum = [];\r\n\r\n\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\r\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\r\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\r\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\r\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\r\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\r\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\r\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\r\n\t\treturn virtualLight;\r\n\r\n\t}\r\n\r\n\t// Synchronize virtual light with the original light\r\n\r\n\tfunction updateVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\r\n\t\tvirtualLight.position.copy( light.position );\r\n\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\tvirtualLight.lookAt( virtualLight.target );\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\r\n\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\tpointsFrustum[ 7 ].z = farZ;\r\n\r\n\t}\r\n\r\n\t// Fit shadow camera's ortho frustum to camera frustum\r\n\r\n\tfunction updateShadowCamera( camera, light ) {\r\n\r\n\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\tpointsWorld = light.pointsWorld;\r\n\r\n\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tvar p = pointsWorld[ i ];\r\n\r\n\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\r\n\r\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\r\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\r\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tshadowCamera.left = _min.x;\r\n\t\tshadowCamera.right = _max.x;\r\n\t\tshadowCamera.top = _max.y;\r\n\t\tshadowCamera.bottom = _min.y;\r\n\r\n\t\t// can't really fit near/far\r\n\t\t//shadowCamera.near = _min.z;\r\n\t\t//shadowCamera.far = _max.z;\r\n\r\n\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function () {\r\n\r\n\tvar _gl, _renderer, _texture;\r\n\r\n\tvar vertices, faces, vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvertices = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5, 0, 0, \r\n\t\t\t  0.5, - 0.5, 1, 0,\r\n\t\t\t  0.5,   0.5, 1, 1,\r\n\t\t\t- 0.5,   0.5, 0, 1\r\n\t\t] );\r\n\r\n\t\tfaces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\tvertexBuffer  = _gl.createBuffer();\r\n\t\telementBuffer = _gl.createBuffer();\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );\r\n\r\n\t\tprogram = createProgram();\r\n\r\n\t\tattributes = {\r\n\t\t\tposition:\t\t\t_gl.getAttribLocation ( program, 'position' ),\r\n\t\t\tuv:\t\t\t\t\t_gl.getAttribLocation ( program, 'uv' )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\tuvOffset:\t\t\t_gl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\tuvScale:\t\t\t_gl.getUniformLocation( program, 'uvScale' ),\r\n\r\n\t\t\trotation:\t\t\t_gl.getUniformLocation( program, 'rotation' ),\r\n\t\t\tscale:\t\t\t\t_gl.getUniformLocation( program, 'scale' ),\r\n\r\n\t\t\tcolor:\t\t\t\t_gl.getUniformLocation( program, 'color' ),\r\n\t\t\tmap:\t\t\t\t_gl.getUniformLocation( program, 'map' ),\r\n\t\t\topacity:\t\t\t_gl.getUniformLocation( program, 'opacity' ),\r\n\r\n\t\t\tmodelViewMatrix: \t_gl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\tprojectionMatrix:\t_gl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n\t\t\tfogType:\t\t\t_gl.getUniformLocation( program, 'fogType' ),\r\n\t\t\tfogDensity:\t\t\t_gl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\tfogNear:\t\t\t_gl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\tfogFar:\t\t\t\t_gl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\tfogColor:\t\t\t_gl.getUniformLocation( program, 'fogColor' ),\r\n\r\n\t\t\talphaTest:\t\t\t_gl.getUniformLocation( program, 'alphaTest' )\r\n\t\t};\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 8;\r\n\t\tcanvas.height = 8;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = '#ffffff';\r\n\t\tcontext.fillRect( 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t_texture = new THREE.Texture( canvas );\r\n\t\t_texture.needsUpdate = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tvar sprites = scene.__webglSprites,\r\n\t\t\tnSprites = sprites.length;\r\n\r\n\t\tif ( ! nSprites ) return;\r\n\r\n\t\t// setup gl\r\n\r\n\t\t_gl.useProgram( program );\r\n\r\n\t\t_gl.enableVertexAttribArray( attributes.position );\r\n\t\t_gl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\r\n\t\t_gl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tvar i, sprite, material, fogType, scale = [];\r\n\r\n\t\tfor( i = 0; i < nSprites; i ++ ) {\r\n\r\n\t\t\tsprite = sprites[ i ];\r\n\t\t\tmaterial = sprite.material;\r\n\r\n\t\t\tif ( sprite.visible === false ) continue;\r\n\r\n\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tfor( i = 0; i < nSprites; i ++ ) {\r\n\r\n\t\t\tsprite = sprites[ i ];\r\n\r\n\t\t\tif ( sprite.visible === false ) continue;\r\n\r\n\t\t\tmaterial = sprite.material;\r\n\r\n\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\r\n\t\t\tscale[ 0 ] = sprite.scale.x;\r\n\t\t\tscale[ 1 ] = sprite.scale.y;\r\n\r\n\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfogType = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\t_gl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\t_gl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t_renderer.setDepthTest( material.depthTest );\r\n\t\t\t_renderer.setDepthWrite( material.depthWrite );\r\n\r\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n\t\t\t\t_renderer.setTexture( material.map, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_renderer.setTexture( _texture, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t};\r\n\r\n\tfunction createProgram () {\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\r\n\t\t_gl.shaderSource( vertexShader, [\r\n\r\n\t\t\t'precision ' + _renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform float rotation;',\r\n\t\t\t'uniform vec2 scale;',\r\n\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t'uniform vec2 uvScale;',\r\n\r\n\t\t\t'attribute vec2 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\r\n\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\r\n\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n\t\t\t\t'vec4 finalPosition;',\r\n\r\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n\t\t\t\t'gl_Position = finalPosition;',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\t_gl.shaderSource( fragmentShader, [\r\n\r\n\t\t\t'precision ' + _renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform vec3 color;',\r\n\t\t\t'uniform sampler2D map;',\r\n\t\t\t'uniform float opacity;',\r\n\r\n\t\t\t'uniform int fogType;',\r\n\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t'uniform float fogDensity;',\r\n\t\t\t'uniform float fogNear;',\r\n\t\t\t'uniform float fogFar;',\r\n\t\t\t'uniform float alphaTest;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\r\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\r\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n\t\t\t\t'if ( fogType > 0 ) {',\r\n\r\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t'float fogFactor = 0.0;',\r\n\r\n\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\r\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n\t\t\t\t\t'} else {',\r\n\r\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n\t\t\t\t\t'}',\r\n\r\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n\t\t\t\t'}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\t_gl.compileShader( vertexShader );\r\n\t\t_gl.compileShader( fragmentShader );\r\n\r\n\t\t_gl.attachShader( program, vertexShader );\r\n\t\t_gl.attachShader( program, fragmentShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DepthPassPlugin = function () {\r\n\r\n\tthis.enabled = false;\r\n\tthis.renderTarget = null;\r\n\r\n\tvar _gl,\r\n\t_renderer,\r\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4();\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\r\n\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( ! this.enabled ) return;\r\n\r\n\t\tthis.update( scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( scene, camera ) {\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tprogram, buffer, material,\r\n\t\twebglObject, object, light,\r\n\t\trenderList,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_renderer.setDepthTest( true );\r\n\r\n\t\t// update scene\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t// render depth map\r\n\r\n\t\t_renderer.setRenderTarget( this.renderTarget );\r\n\t\t_renderer.clear();\r\n\r\n\t\t// set object matrices & frustum culling\r\n\r\n\t\trenderList = scene.__webglObjects;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\twebglObject.render = false;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render regular objects\r\n\r\n\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\r\n\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t// todo: create proper depth material for particles\r\n\r\n\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\r\n\r\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\r\n\r\n\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices and render immediate objects\r\n\r\n\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t};\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.ShaderFlares = {\r\n\r\n\t'lensFlareVertexTexture': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// pink square\r\n\r\n\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t// restore\r\n\r\n\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t// flare\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\r\n\t'lensFlare': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"precision mediump float;\",\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// pink square\r\n\r\n\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n\t\t\t\t// restore\r\n\r\n\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t// flare\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\n  })();\n});","/* jshint ignore:start */\n(function() {\n  var WebSocket = window.WebSocket || window.MozWebSocket;\n  var br = window.brunch = (window.brunch || {});\n  var ar = br['auto-reload'] = (br['auto-reload'] || {});\n  if (!WebSocket || ar.disabled) return;\n  if (window._ar) return;\n  window._ar = true;\n\n  var cacheBuster = function(url){\n    var date = Math.round(Date.now() / 1000).toString();\n    url = url.replace(/(\\&|\\\\?)cacheBuster=\\d*/, '');\n    return url + (url.indexOf('?') >= 0 ? '&' : '?') +'cacheBuster=' + date;\n  };\n\n  var browser = navigator.userAgent.toLowerCase();\n  var forceRepaint = ar.forceRepaint || browser.indexOf('chrome') > -1;\n\n  var reloaders = {\n    page: function(){\n      window.location.reload(true);\n    },\n\n    stylesheet: function(){\n      [].slice\n        .call(document.querySelectorAll('link[rel=stylesheet]'))\n        .filter(function(link) {\n          var val = link.getAttribute('data-autoreload');\n          return link.href && val != 'false';\n        })\n        .forEach(function(link) {\n          link.href = cacheBuster(link.href);\n        });\n\n      // Hack to force page repaint after 25ms.\n      if (forceRepaint) setTimeout(function() { document.body.offsetHeight; }, 25);\n    },\n\n    javascript: function(){\n      var scripts = [].slice.call(document.querySelectorAll('script'));\n      var textScripts = scripts.map(function(script) { return script.text }).filter(function(text) { return text.length > 0 });\n      var srcScripts = scripts.filter(function(script) { return script.src });\n\n      var loaded = 0;\n      var all = srcScripts.length;\n      var onLoad = function() {\n        loaded = loaded + 1;\n        if (loaded === all) {\n          textScripts.forEach(function(script) { eval(script); });\n        }\n      }\n\n      srcScripts\n        .forEach(function(script) {\n          var src = script.src;\n          script.remove();\n          var newScript = document.createElement('script');\n          newScript.src = cacheBuster(src);\n          newScript.async = true;\n          newScript.onload = onLoad;\n          document.head.appendChild(newScript);\n        });\n    }\n  };\n  var port = ar.port || 9485;\n  var host = br.server || window.location.hostname || 'localhost';\n\n  var connect = function(){\n    var connection = new WebSocket('ws://' + host + ':' + port);\n    connection.onmessage = function(event){\n      if (ar.disabled) return;\n      var message = event.data;\n      var reloader = reloaders[message] || reloaders.page;\n      reloader();\n    };\n    connection.onerror = function(){\n      if (connection.readyState) connection.close();\n    };\n    connection.onclose = function(){\n      window.setTimeout(connect, 1000);\n    };\n  };\n  connect();\n})();\n/* jshint ignore:end */\n"]}